{
  "version": 3,
  "sources": ["../src/mod.ts", "../src/moduleVersionChecker.ts", "../src/pkgResolver.ts", "../src/moduleTypes.ts", "../src/files.ts", "../src/util.ts", "../src/moduleNameParser.ts", "../src/fileResolver.ts", "../app.json"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as posix from 'posix';\nimport * as cliffy from 'cliffy';\nimport { Module } from './moduleTypes.ts';\nimport checkModuleVersion, {\n  ModuleVersionCheckResult,\n} from './moduleVersionChecker.ts';\nimport { configurations as fileConfigs } from './files.ts';\nimport appInfo from '../app.json' assert { type: 'json' };\n\nconst enumerateFiles = async function* (basePath: string, files: string[]) {\n  for (const filename of files) {\n    for await (const file of fs.expandGlob(posix.resolve(basePath, filename))) {\n      if (file.isFile) {\n        yield [file.path, filename];\n      }\n    }\n  }\n};\n\nconst main = async function () {\n  const appVersionCheckResult = await checkModuleVersion({\n    type: 'raw_github',\n    name: appInfo.repository,\n    version: appInfo.version,\n  }, {\n    usePrerelease: false,\n    level: 'major',\n  });\n  if (\n    appVersionCheckResult &&\n    appVersionCheckResult.outdated !== 'none'\n  ) {\n    if (appVersionCheckResult.outdated !== 'not_found') {\n      console.log(`Update ${appVersionCheckResult.latest} found`);\n      console.log('You can update with $\\x1b[33mdeno cache --reload\\x1b[0m');\n    }\n  }\n\n  const command = new cliffy.Command()\n    .name(appInfo.name)\n    .version(appInfo.version)\n    .description('Dependency scanner for Node.js and Deno project')\n    .option('-l, --level [level:string]', 'version update limit', {\n      default: 'major',\n    })\n    .option('--prerelease', 'use prerelease')\n    .arguments('[path]');\n\n  const { options } = await command.parse(Deno.args);\n  const level_ = (typeof options.level === 'string')\n    ? options.level.toLowerCase()\n    : options.level;\n  if (level_ !== 'major' && level_ !== 'minor' && level_ !== 'patch') {\n    console.error(`${level_} is not a valid level.`);\n    Deno.exit(1);\n  }\n  const level = level_ as 'major' | 'minor' | 'patch';\n  const usePrerelease = options.prerelease === true;\n\n  const cwd = Deno.cwd();\n  const fileGlobs: string[] = [];\n  for (const config of fileConfigs) {\n    if (config.enabled === undefined || config.enabled(cwd)) {\n      fileGlobs.push(config.file);\n    }\n  }\n\n  // gather modules from files\n  const moduleMap = new Map<string, Module>();\n  for await (const [path, globName] of enumerateFiles(cwd, fileGlobs)) {\n    console.log(`Scanning ${path}...`);\n\n    const content = await Deno.readTextFile(path);\n\n    for (const config of fileConfigs) {\n      if (config.file === globName) {\n        config.resolver(content).forEach((module) => {\n          moduleMap.set(`${module.type}-${module.name}`, module);\n        });\n      }\n    }\n  }\n  const modules = [...moduleMap.values()];\n\n  // check updates\n  const results: [Module, ModuleVersionCheckResult][] = [];\n  for (const module of modules) {\n    const result = await checkModuleVersion(module, {\n      level,\n      usePrerelease,\n    });\n\n    if (result === null) {\n      console.log(`\u2754${module.name} cannot be resolved (${module.type})`);\n    } else if (result.outdated === 'not_found') {\n      console.log(`\u2754 ${module.name} not found on remote (${module.type})`);\n    } else if (result.outdated === 'none') {\n      if (result.fixed) {\n        console.log(`\u2705 ${module.name} is up to date`);\n      } else {\n        console.log(`\u26A0\uFE0F ${module.name} may up to date (version not fixed)`);\n      }\n    } else {\n      if (result.fixed) {\n        console.log(`\u274C ${module.name} is outdated (${result.outdated})`);\n      } else {\n        console.log(\n          `\u274C ${module.name} is outdated (${result.outdated}) and version is not fixed`,\n        );\n      }\n    }\n\n    if (result !== null) {\n      results.push([\n        module,\n        result,\n      ]);\n    }\n  }\n\n  // show result\n  const outdatedModules = results.filter(([, result]) => {\n    return result.outdated !== 'none' && result.outdated !== 'not_found';\n  });\n  const notFoundModules = results.filter(([_, result]) =>\n    result.outdated === 'not_found'\n  );\n  const notFixedModules = results.filter(([_, result]) => !result.fixed);\n\n  console.log();\n  console.log(\n    `\\x1b[1m${outdatedModules.length}\\x1b[0m module${\n      outdatedModules.length > 1 ? 's are' : ' is'\n    } outdated.`,\n  );\n  if (notFoundModules.length > 0) {\n    console.log('Could not find following modules:');\n    console.log(\n      '  ' + notFoundModules.map(([module]) => module.name).join(', '),\n    );\n  }\n  if (notFixedModules.length > 0) {\n    console.log('Version not fixed at following modules:');\n    console.log(\n      '  ' + notFixedModules.map(([module]) => module.name).join(', '),\n    );\n  }\n\n  if (outdatedModules.length > 0) {\n    let logTable: string[][] = [\n      ['', 'package', 'current', 'latest'],\n    ];\n    const outdatedTextMap = {\n      'major': '\\x1b[31mMajor\\x1b[0m',\n      'minor': '\\x1b[33mMinor\\x1b[0m',\n      'patch': '\\x1b[34mPatch\\x1b[0m',\n      'pre_release': '\\x1b[36mPre\\x1b[0m',\n      'none': 'Latest',\n      'not_found': 'Not Found',\n    };\n    for (const [module, result] of outdatedModules) {\n      logTable.push([\n        `${outdatedTextMap[result.outdated]}`,\n        module.name,\n        module.version ?? '(null)',\n        result.latest ?? '(null)',\n      ]);\n    }\n    const colWidths = new Array(logTable[0].length)\n      .fill(0)\n      .map((_, i) =>\n        logTable.reduce(\n          (max, arr) => arr[i].length > max ? arr[i].length : max,\n          0,\n        )\n      );\n\n    logTable = logTable.map((arr) =>\n      arr.map((v, i) =>\n        `${v}${' '.repeat(colWidths[i])}`.slice(0, colWidths[i])\n      )\n    );\n    // adjust for ANSI escape sequence\n    colWidths[0] = 5;\n    logTable[0][0] = '     ';\n\n    console.log(logTable[0].join(' '));\n    console.log(colWidths.map((len) => '-'.repeat(len)).join(' '));\n    console.log(logTable.slice(1).map((arr) => arr.join(' ')).join('\\n'));\n  }\n};\n\nmain();\n", "import * as semver from 'semver';\nimport { SemVer } from 'semver';\nimport { Module } from './moduleTypes.ts';\nimport pkgResolverMap from './pkgResolver.ts';\n\ninterface ModuleVersionCheckOptions {\n  level: 'major' | 'minor' | 'patch';\n  usePrerelease: boolean;\n  gitHubToken?: string;\n}\n\ntype ModuleVersionCheckResult = {\n  fixed: boolean;\n  outdated: 'major' | 'minor' | 'patch' | 'pre_release' | 'none' | 'not_found';\n  latest: string | null;\n};\n\nconst versionsCache = new Map<string, SemVer[] | null>();\nconst getVersions = async function (\n  type: keyof typeof pkgResolverMap,\n  name: string,\n  ...args: string[]\n) {\n  const cacheName = type + ':' + name;\n  const cachedVersions = versionsCache.get(cacheName);\n  if (typeof cachedVersions !== 'undefined') {\n    return cachedVersions;\n  }\n\n  const versions = await pkgResolverMap[type](name, ...args);\n  versionsCache.set(cacheName, versions);\n\n  return versions;\n};\n\nconst getLargestVersion = (versions: SemVer[]) =>\n  versions.reduce((max, ver) => semver.gt(ver, max) ? ver : max);\n\nconst checkModuleVersion = async function (\n  module: Module,\n  options: ModuleVersionCheckOptions,\n): Promise<ModuleVersionCheckResult | null> {\n  const pkgVersion = module.version ?? '';\n  const versionFixed = semver.parse(pkgVersion) !== null;\n\n  if (!(module.type in pkgResolverMap)) {\n    return null;\n  }\n  const type = module.type as keyof typeof pkgResolverMap;\n\n  const additionalArgs = [];\n  if (type === 'raw_github' && typeof options?.gitHubToken === 'string') {\n    additionalArgs.push(options.gitHubToken);\n  }\n\n  let versionList = await getVersions(type, module.name, ...additionalArgs);\n  if (versionList === null) {\n    return {\n      fixed: versionFixed,\n      outdated: 'not_found',\n      latest: null,\n    };\n  }\n  if (!options.usePrerelease) {\n    versionList = versionList.filter((version) =>\n      version.prerelease.length === 0\n    );\n  }\n\n  // extract versions in the specified range;\n  // fixed versions are interpreted as a range of `=x.y.z`\n  const versionsInRange = versionList.filter((v) =>\n    semver.satisfies(\n      v,\n      pkgVersion,\n      { includePrerelease: options.usePrerelease },\n    )\n  );\n  if (versionsInRange.length < 1) {\n    return {\n      fixed: versionFixed,\n      outdated: 'not_found',\n      latest: null,\n    };\n  }\n  const latestVerInRange = getLargestVersion(versionsInRange);\n\n  const versionsGreater = versionList.filter((v) =>\n    semver.gtr(\n      v,\n      pkgVersion,\n      { includePrerelease: options.usePrerelease },\n    )\n  ).filter((v) => {\n    switch (options.level) {\n      case 'major':\n        return true;\n      case 'minor':\n        return semver.major(latestVerInRange) === v.major;\n      case 'patch':\n        return semver.major(latestVerInRange) === v.major &&\n          semver.minor(latestVerInRange) === v.minor;\n    }\n  });\n\n  let outdated: ModuleVersionCheckResult['outdated'] = 'none';\n  let latestVer: SemVer | null = null;\n  if (versionsGreater.length > 0) {\n    latestVer = getLargestVersion(versionsGreater);\n\n    if (latestVer.major > latestVerInRange.major) {\n      outdated = 'major';\n    } else if (latestVer.minor > latestVerInRange.minor) {\n      outdated = 'minor';\n    } else if (latestVer.patch > latestVerInRange.patch) {\n      outdated = 'patch';\n    } else if (\n      options.usePrerelease &&\n      semver.gt(latestVer, latestVerInRange, { includePrerelease: true })\n    ) {\n      outdated = 'pre_release';\n    }\n  }\n\n  // console.log(\n  //   name,\n  //   versionsInRange.map((v) => v.version),\n  //   versionsGreater.map((v) => v.version),\n  //   outdated,\n  // );\n\n  return {\n    fixed: versionFixed,\n    outdated,\n    latest: latestVer?.version ?? null,\n  };\n};\n\nexport type { ModuleVersionCheckOptions, ModuleVersionCheckResult };\n\nexport default checkModuleVersion;\n", "import * as semver from 'semver';\nimport { SemVer } from 'semver';\nimport moduleTypes from './moduleTypes.ts';\n\nconst resolveNpmPackage = async function (pkgName: string) {\n  const url = `https://registry.npmjs.org/${pkgName}`;\n  const res = await fetch(url);\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text());\n  const versions = Object.keys(data['versions'])\n    .map((v) => semver.parse(v))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst resolveDenoLandPackage = async function (pkgName: string) {\n  const url = `https://apiland.deno.dev/v2/modules/${pkgName}`;\n  const res = await fetch(url);\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text());\n  const versions = (data['versions'] as string[])\n    .map((v) => semver.parse(v))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst resolveRawGitHubContent = async function (\n  repoName: string,\n  token?: string,\n) {\n  const headers = {\n    'Accept': 'application/vnd.github+json',\n    'X-GitHub-Api-Version': '2022-11-28',\n  };\n  if (typeof token === 'string') {\n    Object.defineProperty(headers, 'Authorization', {\n      value: `Bearer ${token}`,\n    });\n  }\n\n  const res = await fetch(\n    `https://api.github.com/repos/${repoName}/releases`,\n    { headers },\n  );\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text()) as Required<{ tag_name: string }>[];\n  const versions = (data)\n    .map((v) => semver.parse(v.tag_name))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst pkgResolverMap = {\n  [moduleTypes.npmPackage]: resolveNpmPackage,\n  [moduleTypes.denoLand]: resolveDenoLandPackage,\n  [moduleTypes.rawGitHub]: resolveRawGitHubContent,\n};\n\nexport { resolveDenoLandPackage, resolveNpmPackage, resolveRawGitHubContent };\n\nexport default pkgResolverMap;\n", "const moduleTypes = {\n  denoLand: 'deno_land',\n  npmPackage: 'npm_package',\n  rawGitHub: 'raw_github',\n  unknown: 'unknown',\n} as const;\n\nexport interface Module {\n  type: ModuleType;\n  name: string;\n  version: string | null;\n}\n\nexport type ModuleType = typeof moduleTypes[keyof typeof moduleTypes];\n\nexport default moduleTypes;\n", "import * as fs from 'fs';\nimport * as posix from 'posix';\nimport { Module } from './moduleTypes.ts';\nimport * as moduleNameParser from './moduleNameParser.ts';\nimport * as fileResolver from './fileResolver.ts';\n\ninterface FileConfig {\n  file: string;\n  enabled?: (cwd: string) => boolean;\n  resolver: (content: string) => Module[];\n  // replacer\n}\n\nconst isDenoProjectCache = new Map<string, boolean>();\nconst isDenoProject = (cwd: string) => {\n  const cachedResult = isDenoProjectCache.get(cwd);\n  if (typeof cachedResult === 'boolean') {\n    return cachedResult;\n  }\n\n  if (fs.existsSync(posix.join(cwd, 'deno.json'), { isFile: true })) {\n    isDenoProjectCache.set(cwd, true);\n    return true;\n  }\n  if (fs.existsSync(posix.join(cwd, 'deno.jsonc'), { isFile: true })) {\n    isDenoProjectCache.set(cwd, true);\n    return true;\n  }\n\n  isDenoProjectCache.set(cwd, false);\n  return false;\n};\n\nconst npmPackageJson: FileConfig = {\n  file: 'package.json',\n  resolver: (content) => {\n    return fileResolver.resolvePackageJson(content);\n  },\n};\n\nconst denoImportMap: FileConfig = {\n  file: 'import_map.json',\n  enabled: isDenoProject,\n  resolver: (content) => {\n    return fileResolver.resolveImportMap(content, [\n      moduleNameParser.denoLandUrlParser,\n      moduleNameParser.rawGitHubUrlParser,\n      moduleNameParser.denoNpmModuleParser,\n    ]);\n  },\n};\n\nconst denoDepsTs: FileConfig = {\n  file: 'deps.ts',\n  enabled: isDenoProject,\n  resolver: (content) => {\n    return fileResolver.resolveDenoModuleNameStrings(content, [\n      moduleNameParser.denoLandUrlParser,\n      moduleNameParser.rawGitHubUrlParser,\n      moduleNameParser.denoNpmModuleParser,\n    ]);\n  },\n};\n\nconst denoDepsJs: FileConfig = {\n  file: '**/deps.js',\n  enabled: isDenoProject,\n  resolver: (content) => {\n    return fileResolver.resolveDenoModuleNameStrings(content, [\n      moduleNameParser.denoLandUrlParser,\n      moduleNameParser.rawGitHubUrlParser,\n      moduleNameParser.denoNpmModuleParser,\n    ]);\n  },\n};\n\nconst configurations = [\n  npmPackageJson,\n  denoImportMap,\n  denoDepsTs,\n  denoDepsJs,\n];\n\nexport { configurations };\n", "/**\n * @example \"package@version\" -> [\"package\", \"version\"]\n * @example \"package\" -> [\"package\", \"\"]\n * @example \"@author/package@version\" -> [\"@author/package\", \"version\"]\n * @example \"@author/package\" -> [\"@author/package\"]\n */\nconst decomposePackageNameVersion = function (\n  pkgStr: string,\n): [string, string] {\n  const index = pkgStr.lastIndexOf('@');\n  if (index <= 0) {\n    return [pkgStr, ''];\n  } else {\n    return [pkgStr.slice(0, index), pkgStr.slice(index + 1)];\n  }\n};\n\nconst matchStringOrRegExp = (test: string | RegExp, target: string) =>\n  (typeof test === 'string') ? test === target : test.test(target);\n\nexport { decomposePackageNameVersion, matchStringOrRegExp };\n", "import { decomposePackageNameVersion } from './util.ts';\nimport { default as moduleTypes, Module } from './moduleTypes.ts';\n\ninterface ModuleNameParser {\n  test: RegExp;\n  parse: (moduleName: string) => Module;\n}\n\nconst denoLandUrlParser: ModuleNameParser = {\n  test: /^https?:\\/\\/deno.land/,\n  parse: (moduleName) => {\n    const path = new URL(moduleName).pathname.split('/').slice(1);\n    const pkgStr = path[0] === 'x' ? path[1] : path[0];\n    const [name, version] = decomposePackageNameVersion(pkgStr);\n\n    return {\n      type: moduleTypes.denoLand,\n      name,\n      version,\n    };\n  },\n};\n\nconst rawGitHubUrlParser: ModuleNameParser = {\n  test: /^https?:\\/\\/raw.githubusercontent.com/,\n  parse: (moduleName) => {\n    const path = new URL(moduleName).pathname.split('/').slice(1);\n    const name = `${path[0]}/${path[1]}`;\n    const version = path[2];\n\n    return {\n      type: moduleTypes.rawGitHub,\n      name,\n      version,\n    };\n  },\n};\n\nconst denoNpmModuleParser: ModuleNameParser = {\n  test: /^npm:/,\n  parse: (moduleName) => {\n    const [name, version] = decomposePackageNameVersion(moduleName.slice(4));\n    return {\n      type: moduleTypes.npmPackage,\n      name,\n      version,\n    };\n  },\n};\n\nconst parseModuleName = function (\n  url: string,\n  parsers: ModuleNameParser[],\n): ReturnType<ModuleNameParser['parse']> | null {\n  for (const parser of parsers) {\n    if (parser.test.test(url)) {\n      return parser.parse(url);\n    }\n  }\n\n  return null;\n};\n\nexport type { ModuleNameParser };\n\nexport {\n  denoLandUrlParser,\n  denoNpmModuleParser,\n  parseModuleName,\n  rawGitHubUrlParser,\n};\n", "import { ModuleNameParser, parseModuleName } from './moduleNameParser.ts';\nimport { default as moduleTypes, Module } from './moduleTypes.ts';\n\ninterface Importmap {\n  imports?: { [key: string]: string };\n  scope?: {\n    [key: string]: { [key: string]: string };\n  };\n}\n\ntype PackageJson = Required<{\n  dependencies: { [key: string]: string };\n  devDependencies: { [key: string]: string };\n}>;\n\nconst resolvePackageJson = function (content: string): Module[] {\n  const packageJson = JSON.parse(content) as PackageJson;\n\n  // TODO: support imports other than npm\n  const results: Module[] = [];\n  for (const name in packageJson.dependencies) {\n    results.push({\n      type: moduleTypes.npmPackage,\n      name,\n      version: packageJson.dependencies[name],\n    });\n  }\n  for (const name in packageJson.devDependencies) {\n    results.push({\n      type: moduleTypes.npmPackage,\n      name,\n      version: packageJson.devDependencies[name],\n    });\n  }\n\n  return results;\n};\n\nconst parseModuleNameWrapper = function (\n  moduleName: string,\n  parsers: ModuleNameParser[],\n): Module {\n  return parseModuleName(moduleName, parsers) ?? {\n    type: moduleTypes.unknown,\n    name: moduleName,\n    version: null,\n  };\n};\n\nconst resolveImportMap = function (\n  content: string,\n  parsers: ModuleNameParser[],\n): Module[] {\n  const importmap = JSON.parse(content) as Importmap;\n\n  const moduleNames = [\n    ...Object.values(importmap?.imports ?? {}),\n    ...Object.values(importmap?.scope ?? {})\n      .flatMap((map) => Object.values(map)),\n  ];\n\n  return moduleNames.map((moduleName) =>\n    parseModuleNameWrapper(moduleName, parsers)\n  );\n};\n\nconst resolveDenoModuleNameStrings = function (\n  content: string,\n  parsers: ModuleNameParser[],\n): Module[] {\n  const regExps = [\n    /\"https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+\"/g,\n    /'https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+'/g,\n    /`https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+`/g,\n    /\"npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+\"/g,\n    /'npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+'/g,\n    /`npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+`/g,\n  ];\n\n  const moduleNames = regExps.flatMap((regExp) => [...content.matchAll(regExp)])\n    .map((match) => match[0].slice(1, -1));\n\n  return moduleNames.map((moduleName) =>\n    parseModuleNameWrapper(moduleName, parsers)\n  );\n};\n\nexport { resolveDenoModuleNameStrings, resolveImportMap, resolvePackageJson };\n", "{\n  \"name\": \"Delichon\",\n  \"repository\": \"Tsukina-7mochi/delichon\",\n  \"version\": \"0.1.0\"\n}"],
  "mappings": "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",
  "names": ["fs", "posix", "cliffy", "semver", "semver", "moduleTypes", "moduleTypes_default", "resolveNpmPackage", "pkgName", "url", "res", "data", "v", "resolveDenoLandPackage", "resolveRawGitHubContent", "repoName", "token", "headers", "pkgResolverMap", "moduleTypes_default", "pkgResolver_default", "pkgResolverMap", "versionsCache", "getVersions", "type", "name", "args", "cacheName", "cachedVersions", "versions", "pkgResolver_default", "getLargestVersion", "max", "ver", "checkModuleVersion", "module", "options", "pkgVersion", "versionFixed", "additionalArgs", "versionList", "version", "versionsInRange", "v", "latestVerInRange", "versionsGreater", "outdated", "latestVer", "moduleVersionChecker_default", "fs", "posix", "decomposePackageNameVersion", "pkgStr", "index", "denoLandUrlParser", "moduleName", "path", "pkgStr", "name", "version", "decomposePackageNameVersion", "moduleTypes_default", "rawGitHubUrlParser", "denoNpmModuleParser", "parseModuleName", "url", "parsers", "parser", "resolvePackageJson", "content", "packageJson", "results", "name", "moduleTypes_default", "parseModuleNameWrapper", "moduleName", "parsers", "parseModuleName", "resolveImportMap", "importmap", "map", "resolveDenoModuleNameStrings", "regExp", "match", "isDenoProjectCache", "isDenoProject", "cwd", "cachedResult", "npmPackageJson", "content", "resolvePackageJson", "denoImportMap", "resolveImportMap", "denoLandUrlParser", "rawGitHubUrlParser", "denoNpmModuleParser", "denoDepsTs", "resolveDenoModuleNameStrings", "denoDepsJs", "configurations", "app_default", "enumerateFiles", "basePath", "files", "filename", "file", "main", "appVersionCheckResult", "moduleVersionChecker_default", "app_default", "command", "options", "level_", "level", "usePrerelease", "cwd", "fileGlobs", "config", "configurations", "moduleMap", "path", "globName", "content", "module", "modules", "results", "result", "outdatedModules", "notFoundModules", "_", "notFixedModules", "logTable", "outdatedTextMap", "colWidths", "i", "max", "arr", "v", "len"]
}
