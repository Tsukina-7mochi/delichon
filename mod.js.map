{
  "version": 3,
  "sources": ["../src/mod.ts", "../src/moduleVersionChecker.ts", "../src/moduleVersionResolver.ts", "../src/moduleTypes.ts", "../src/util.ts", "../src/files.ts", "../src/moduleNameParser.ts", "../src/fileResolver.ts", "../app.json"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as posix from 'posix';\nimport * as cliffy from 'cliffy';\nimport { Module } from './moduleTypes.ts';\nimport checkModuleVersion, {\n  ModuleVersionCheckResult,\n} from './moduleVersionChecker.ts';\nimport { configurations as fileConfigs } from './files.ts';\nimport appInfo from '../app.json' assert { type: 'json' };\n\nconst enumerateFiles = async function* (basePath: string, files: string[]) {\n  for (const filename of files) {\n    for await (const file of fs.expandGlob(posix.resolve(basePath, filename))) {\n      if (file.isFile) {\n        yield [file.path, filename];\n      }\n    }\n  }\n};\n\nconst main = async function () {\n  const appVersionCheckResult = await checkModuleVersion({\n    type: 'raw_github',\n    name: appInfo.repository,\n    version: appInfo.version,\n  }, {\n    usePrerelease: false,\n    level: 'major',\n  });\n  if (\n    appVersionCheckResult &&\n    appVersionCheckResult.outdated !== 'none'\n  ) {\n    if (appVersionCheckResult.outdated !== 'not_found') {\n      console.log(`Update ${appVersionCheckResult.latest} found`);\n      console.log('You can update with $\\x1b[33mdeno cache --reload\\x1b[0m');\n    }\n  }\n\n  const command = new cliffy.Command()\n    .name(appInfo.name)\n    .version(appInfo.version)\n    .description('Dependency scanner for Node.js and Deno project')\n    .option('-l, --level [level:string]', 'version update limit', {\n      default: 'major',\n    })\n    .option('--prerelease', 'use prerelease')\n    .arguments('[path]');\n\n  const { options, args } = await command.parse(Deno.args);\n  const level_ = (typeof options.level === 'string')\n    ? options.level.toLowerCase()\n    : options.level;\n  if (level_ !== 'major' && level_ !== 'minor' && level_ !== 'patch') {\n    console.error(`${level_} is not a valid level.`);\n    Deno.exit(1);\n  }\n  const level = level_ as 'major' | 'minor' | 'patch';\n  const usePrerelease = options.prerelease === true;\n\n  const cwd = args.filter((v) => typeof v === 'string')[0] ?? Deno.cwd();\n  const fileGlobs: string[] = [];\n  for (const config of fileConfigs) {\n    if (config.enabled === undefined || config.enabled(cwd)) {\n      fileGlobs.push(config.file);\n    }\n  }\n\n  // gather modules from files\n  const moduleMap = new Map<string, Module>();\n  for await (const [path, globName] of enumerateFiles(cwd, fileGlobs)) {\n    console.log(`Scanning ${path}...`);\n\n    const content = await Deno.readTextFile(path);\n\n    for (const config of fileConfigs) {\n      if (config.file === globName) {\n        config.resolver(content).forEach((module) => {\n          moduleMap.set(`${module.type}-${module.name}`, module);\n        });\n      }\n    }\n  }\n  const modules = [...moduleMap.values()];\n\n  // check updates\n  const results: [Module, ModuleVersionCheckResult][] = [];\n  for (const module of modules) {\n    const result = await checkModuleVersion(module, {\n      level,\n      usePrerelease,\n    });\n\n    if (result === null) {\n      console.log(`\u2754${module.name} cannot be resolved (${module.type})`);\n    } else if (result.outdated === 'not_found') {\n      console.log(`\u2754 ${module.name} not found on remote (${module.type})`);\n    } else if (result.outdated === 'none') {\n      if (result.fixed) {\n        console.log(`\u2705 ${module.name} is up to date`);\n      } else {\n        console.log(`\u26A0\uFE0F ${module.name} may up to date (version not fixed)`);\n      }\n    } else {\n      if (result.fixed) {\n        console.log(`\u274C ${module.name} is outdated (${result.outdated})`);\n      } else {\n        console.log(\n          `\u274C ${module.name} is outdated (${result.outdated}) and version is not fixed`,\n        );\n      }\n    }\n\n    if (result !== null) {\n      results.push([\n        module,\n        result,\n      ]);\n    }\n  }\n\n  // show result\n  const outdatedModules = results.filter(([, result]) => {\n    return result.outdated !== 'none' && result.outdated !== 'not_found';\n  });\n  const notFoundModules = results.filter(([_, result]) =>\n    result.outdated === 'not_found'\n  );\n  const notFixedModules = results.filter(([_, result]) => !result.fixed);\n\n  console.log();\n  console.log(\n    `\\x1b[1m${outdatedModules.length}\\x1b[0m module${\n      outdatedModules.length > 1 ? 's are' : ' is'\n    } outdated.`,\n  );\n  if (notFoundModules.length > 0) {\n    console.log('Could not find following modules:');\n    console.log(\n      '  ' + notFoundModules.map(([module]) => module.name).join(', '),\n    );\n  }\n  if (notFixedModules.length > 0) {\n    console.log('Version not fixed at following modules:');\n    console.log(\n      '  ' + notFixedModules.map(([module]) => module.name).join(', '),\n    );\n  }\n\n  if (outdatedModules.length > 0) {\n    let logTable: string[][] = [\n      ['', 'package', 'current', 'latest'],\n    ];\n    const outdatedTextMap = {\n      'major': '\\x1b[31mMajor\\x1b[0m',\n      'minor': '\\x1b[33mMinor\\x1b[0m',\n      'patch': '\\x1b[34mPatch\\x1b[0m',\n      'pre_release': '\\x1b[36mPre\\x1b[0m',\n      'none': 'Latest',\n      'not_found': 'Not Found',\n    };\n    for (const [module, result] of outdatedModules) {\n      logTable.push([\n        `${outdatedTextMap[result.outdated]}`,\n        module.name,\n        module.version ?? '(null)',\n        result.latest ?? '(null)',\n      ]);\n    }\n    const colWidths = new Array(logTable[0].length)\n      .fill(0)\n      .map((_, i) =>\n        logTable.reduce(\n          (max, arr) => arr[i].length > max ? arr[i].length : max,\n          0,\n        )\n      );\n\n    logTable = logTable.map((arr) =>\n      arr.map((v, i) =>\n        `${v}${' '.repeat(colWidths[i])}`.slice(0, colWidths[i])\n      )\n    );\n    // adjust for ANSI escape sequence\n    colWidths[0] = 5;\n    logTable[0][0] = '     ';\n\n    console.log(logTable[0].join(' '));\n    console.log(colWidths.map((len) => '-'.repeat(len)).join(' '));\n    console.log(logTable.slice(1).map((arr) => arr.join(' ')).join('\\n'));\n  }\n};\n\nmain();\n", "import * as semver from 'semver';\nimport { Module } from './moduleTypes.ts';\nimport { getLatestVersions } from './moduleVersionResolver.ts';\n\ninterface ModuleVersionCheckOptions {\n  level: 'major' | 'minor' | 'patch';\n  usePrerelease: boolean;\n  gitHubToken?: string;\n}\n\ntype ModuleVersionCheckResult = {\n  fixed: boolean;\n  outdated: 'major' | 'minor' | 'patch' | 'pre_release' | 'none' | 'not_found';\n  latest: string | null;\n};\n\nconst checkModuleVersion = async function (\n  module: Module,\n  options: ModuleVersionCheckOptions,\n): Promise<ModuleVersionCheckResult | null> {\n  const versionFixed = semver.parse(module.version ?? '') !== null;\n\n  const latestVersions = await getLatestVersions(\n    module.type,\n    module.name,\n    module.version ?? '',\n    options,\n  );\n  if (latestVersions === null) {\n    return {\n      fixed: versionFixed,\n      outdated: 'not_found',\n      latest: null,\n    };\n  }\n\n  const latestVer = latestVersions.latest;\n  const latestVerInRange = latestVersions.latestInRange;\n\n  let outdated: ModuleVersionCheckResult['outdated'] = 'none';\n  if (latestVer.major > latestVerInRange.major) {\n    outdated = 'major';\n  } else if (latestVer.minor > latestVerInRange.minor) {\n    outdated = 'minor';\n  } else if (latestVer.patch > latestVerInRange.patch) {\n    outdated = 'patch';\n  } else if (\n    options.usePrerelease &&\n    semver.gt(latestVer, latestVerInRange, { includePrerelease: true })\n  ) {\n    outdated = 'pre_release';\n  }\n\n  // console.log(\n  //   name,\n  //   versionsInRange.map((v) => v.version),\n  //   versionsGreater.map((v) => v.version),\n  //   outdated,\n  // );\n\n  return {\n    fixed: versionFixed,\n    outdated,\n    latest: latestVer?.version ?? null,\n  };\n};\n\nexport type { ModuleVersionCheckOptions, ModuleVersionCheckResult };\n\nexport default checkModuleVersion;\n", "import * as semver from 'semver';\nimport { SemVer } from 'semver';\nimport moduleTypes from './moduleTypes.ts';\nimport { decomposePackageNameVersion } from './util.ts';\n\nconst getLargestVersion = (versions: SemVer[]) =>\n  versions.reduce((max, ver) => semver.gt(ver, max) ? ver : max);\n\nconst calcLatestVersionRange = function (\n  refVer: SemVer,\n  level: 'major' | 'minor' | 'patch',\n) {\n  let range = `>=${refVer}`;\n\n  if (level === 'major') {\n    // do nothing\n  } else if (level === 'minor') {\n    range += ` <=${refVer.major}`;\n  } else if (level === 'patch') {\n    range += ` <=${refVer.major}.${refVer.minor}`;\n  }\n\n  return range;\n};\n\nconst resolveNpmPackage = async function (pkgName: string) {\n  const url = `https://registry.npmjs.org/${pkgName}`;\n  const res = await fetch(url);\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text());\n  const versions = Object.keys(data['versions'])\n    .map((v) => semver.parse(v))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst resolveDenoLandPackage = async function (pkgName: string) {\n  const url = `https://apiland.deno.dev/v2/modules/${pkgName}`;\n  const res = await fetch(url);\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text());\n  const versions = (data['versions'] as string[])\n    .map((v) => semver.parse(v))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst resolveRawGitHubContent = async function (\n  repoName: string,\n  token?: string,\n) {\n  const headers = {\n    'Accept': 'application/vnd.github+json',\n    'X-GitHub-Api-Version': '2022-11-28',\n  };\n  if (typeof token === 'string') {\n    Object.defineProperty(headers, 'Authorization', {\n      value: `Bearer ${token}`,\n    });\n  }\n\n  const res = await fetch(\n    `https://api.github.com/repos/${repoName}/releases`,\n    { headers },\n  );\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text()) as Required<{ tag_name: string }>[];\n  const versions = (data)\n    .map((v) => semver.parse(v.tag_name))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst getEsmShVersion = async function (url: string) {\n  const moduleNameRegExp = /^\\/\\* esm.sh - (\\S+) \\*\\//;\n  const res = await fetch(url);\n  if (!res.ok) {\n    return null;\n  }\n\n  const content = await res.text();\n  const moduleNameMatch = content.match(moduleNameRegExp);\n  if (moduleNameMatch === null) {\n    return null;\n  }\n  const [_, version] = decomposePackageNameVersion(moduleNameMatch[1]);\n  return version;\n};\nconst resolveEsmSh = async function (pkgName: string, versionRange: string) {\n  const latestUrl = `https://esm.sh/${pkgName}`;\n  const latestInRangeUrl = `${latestUrl}@${versionRange}`;\n\n  const latest = semver.parse(await getEsmShVersion(latestUrl));\n  const latestInRange = semver.parse(await getEsmShVersion(latestInRangeUrl));\n  if (latest === null || latestInRange === null) {\n    return null;\n  }\n  return { latest, latestInRange };\n};\n\ninterface GetVersionsOptions {\n  level: 'major' | 'minor' | 'patch';\n  usePrerelease: boolean;\n  gitHubToken?: string;\n}\nconst versionListCache = new Map<string, SemVer[] | null>();\nconst getLatestVersions = async function (\n  type: typeof moduleTypes[keyof typeof moduleTypes],\n  name: string,\n  version: string,\n  options: GetVersionsOptions,\n) {\n  const semverOption = { includePrerelease: options.usePrerelease };\n  if (\n    type === moduleTypes.denoLand || type === moduleTypes.npmPackage ||\n    type === moduleTypes.rawGitHub\n  ) {\n    const cacheName = type + ':' + name;\n    const cachedVersionList = versionListCache.get(cacheName);\n\n    let versionList: SemVer[] | null = null;\n    if (typeof cachedVersionList !== 'undefined') {\n      versionList = cachedVersionList;\n    } else {\n      if (type === moduleTypes.denoLand) {\n        versionList = await resolveDenoLandPackage(name);\n      } else if (type === moduleTypes.npmPackage) {\n        versionList = await resolveNpmPackage(name);\n      } else if (type === moduleTypes.rawGitHub) {\n        versionList = await resolveRawGitHubContent(name, options.gitHubToken);\n      }\n\n      versionListCache.set(cacheName, versionList);\n    }\n\n    if (versionList === null || versionList.length < 1) {\n      return null;\n    }\n\n    const versionListInRange = versionList\n      .filter((ver) => semver.satisfies(ver, version, semverOption));\n    if (versionListInRange.length < 1) {\n      return null;\n    }\n    const latestInRange = getLargestVersion(versionListInRange);\n\n    const versionGreaterRange = calcLatestVersionRange(\n      latestInRange,\n      options.level,\n    );\n    const versionListGreater = versionList\n      .filter((ver) =>\n        semver.satisfies(ver, versionGreaterRange, semverOption)\n      );\n\n    return {\n      latest: getLargestVersion(versionListGreater),\n      latestInRange: latestInRange,\n    };\n  } else if (type === moduleTypes.esmSh) {\n    return resolveEsmSh(name, version);\n  }\n\n  return null;\n};\n\nexport { getLatestVersions };\n", "const moduleTypes = {\n  denoLand: 'deno_land',\n  npmPackage: 'npm_package',\n  rawGitHub: 'raw_github',\n  esmSh: 'esm_sh',\n  unknown: 'unknown',\n} as const;\n\nexport interface Module {\n  type: ModuleType;\n  name: string;\n  version: string | null;\n}\n\nexport type ModuleType = typeof moduleTypes[keyof typeof moduleTypes];\n\nexport default moduleTypes;\n", "/**\n * @example \"package@version\" -> [\"package\", \"version\"]\n * @example \"package\" -> [\"package\", \"\"]\n * @example \"@author/package@version\" -> [\"@author/package\", \"version\"]\n * @example \"@author/package\" -> [\"@author/package\"]\n */\nconst decomposePackageNameVersion = function (\n  pkgStr: string,\n): [string, string] {\n  const index = pkgStr.lastIndexOf('@');\n  if (index <= 0) {\n    return [pkgStr, ''];\n  } else {\n    return [pkgStr.slice(0, index), pkgStr.slice(index + 1)];\n  }\n};\n\nconst matchStringOrRegExp = (test: string | RegExp, target: string) =>\n  (typeof test === 'string') ? test === target : test.test(target);\n\nexport { decomposePackageNameVersion, matchStringOrRegExp };\n", "import * as fs from 'fs';\nimport * as posix from 'posix';\nimport { Module } from './moduleTypes.ts';\nimport * as moduleNameParser from './moduleNameParser.ts';\nimport * as fileResolver from './fileResolver.ts';\n\ninterface FileConfig {\n  file: string;\n  enabled?: (cwd: string) => boolean;\n  resolver: (content: string) => Module[];\n  // replacer\n}\n\nconst isDenoProjectCache = new Map<string, boolean>();\nconst isDenoProject = (cwd: string) => {\n  const cachedResult = isDenoProjectCache.get(cwd);\n  if (typeof cachedResult === 'boolean') {\n    return cachedResult;\n  }\n\n  if (fs.existsSync(posix.join(cwd, 'deno.json'), { isFile: true })) {\n    isDenoProjectCache.set(cwd, true);\n    return true;\n  }\n  if (fs.existsSync(posix.join(cwd, 'deno.jsonc'), { isFile: true })) {\n    isDenoProjectCache.set(cwd, true);\n    return true;\n  }\n\n  isDenoProjectCache.set(cwd, false);\n  return false;\n};\n\nconst denoFileResolver = (content: string) =>\n  fileResolver.resolveImportMap(content, [\n    moduleNameParser.denoLandUrlParser,\n    moduleNameParser.rawGitHubUrlParser,\n    moduleNameParser.denoNpmModuleParser,\n    moduleNameParser.esmShModuleParser,\n  ]);\n\nconst npmPackageJson: FileConfig = {\n  file: 'package.json',\n  resolver: (content) => {\n    return fileResolver.resolvePackageJson(content);\n  },\n};\n\nconst denoImportMap: FileConfig = {\n  file: 'import_map.json',\n  enabled: isDenoProject,\n  resolver: denoFileResolver,\n};\n\nconst denoDepsTs: FileConfig = {\n  file: 'deps.ts',\n  enabled: isDenoProject,\n  resolver: denoFileResolver,\n};\n\nconst denoDepsJs: FileConfig = {\n  file: '**/deps.js',\n  enabled: isDenoProject,\n  resolver: denoFileResolver,\n};\n\nconst configurations = [\n  npmPackageJson,\n  denoImportMap,\n  denoDepsTs,\n  denoDepsJs,\n];\n\nexport { configurations };\n", "import { decomposePackageNameVersion } from './util.ts';\nimport { default as moduleTypes, Module } from './moduleTypes.ts';\n\ninterface ModuleNameParser {\n  test: RegExp;\n  parse: (moduleName: string) => Module;\n}\n\nconst denoLandUrlParser: ModuleNameParser = {\n  test: /^https?:\\/\\/deno.land/,\n  parse: (moduleName) => {\n    const path = new URL(moduleName).pathname.split('/').slice(1);\n    const pkgStr = path[0] === 'x' ? path[1] : path[0];\n    const [name, version] = decomposePackageNameVersion(pkgStr);\n\n    return {\n      type: moduleTypes.denoLand,\n      name,\n      version,\n    };\n  },\n};\n\nconst rawGitHubUrlParser: ModuleNameParser = {\n  test: /^https?:\\/\\/raw.githubusercontent.com/,\n  parse: (moduleName) => {\n    const path = new URL(moduleName).pathname.split('/').slice(1);\n    const name = `${path[0]}/${path[1]}`;\n    const version = path[2];\n\n    return {\n      type: moduleTypes.rawGitHub,\n      name,\n      version,\n    };\n  },\n};\n\nconst denoNpmModuleParser: ModuleNameParser = {\n  test: /^npm:/,\n  parse: (moduleName) => {\n    const [name, version] = decomposePackageNameVersion(moduleName.slice(4));\n    return {\n      type: moduleTypes.npmPackage,\n      name,\n      version,\n    };\n  },\n};\n\nconst esmShModuleParser: ModuleNameParser = {\n  test: /^https?:\\/\\/esm.sh/,\n  parse: (moduleName) => {\n    const path = new URL(moduleName).pathname.split('/').slice(1);\n    const [name, version] = decomposePackageNameVersion(path[0]);\n\n    return {\n      type: moduleTypes.esmSh,\n      name,\n      version,\n    };\n  },\n};\n\nconst parseModuleName = function (\n  url: string,\n  parsers: ModuleNameParser[],\n): ReturnType<ModuleNameParser['parse']> | null {\n  for (const parser of parsers) {\n    if (parser.test.test(url)) {\n      return parser.parse(url);\n    }\n  }\n\n  return null;\n};\n\nexport type { ModuleNameParser };\n\nexport {\n  denoLandUrlParser,\n  denoNpmModuleParser,\n  esmShModuleParser,\n  parseModuleName,\n  rawGitHubUrlParser,\n};\n", "import { ModuleNameParser, parseModuleName } from './moduleNameParser.ts';\nimport { default as moduleTypes, Module } from './moduleTypes.ts';\n\ninterface Importmap {\n  imports?: { [key: string]: string };\n  scope?: {\n    [key: string]: { [key: string]: string };\n  };\n}\n\ntype PackageJson = Required<{\n  dependencies: { [key: string]: string };\n  devDependencies: { [key: string]: string };\n}>;\n\nconst resolvePackageJson = function (content: string): Module[] {\n  const packageJson = JSON.parse(content) as PackageJson;\n\n  // TODO: support imports other than npm\n  const results: Module[] = [];\n  for (const name in packageJson.dependencies) {\n    results.push({\n      type: moduleTypes.npmPackage,\n      name,\n      version: packageJson.dependencies[name],\n    });\n  }\n  for (const name in packageJson.devDependencies) {\n    results.push({\n      type: moduleTypes.npmPackage,\n      name,\n      version: packageJson.devDependencies[name],\n    });\n  }\n\n  return results;\n};\n\nconst parseModuleNameWrapper = function (\n  moduleName: string,\n  parsers: ModuleNameParser[],\n): Module {\n  return parseModuleName(moduleName, parsers) ?? {\n    type: moduleTypes.unknown,\n    name: moduleName,\n    version: null,\n  };\n};\n\nconst resolveImportMap = function (\n  content: string,\n  parsers: ModuleNameParser[],\n): Module[] {\n  const importmap = JSON.parse(content) as Importmap;\n\n  const moduleNames = [\n    ...Object.values(importmap?.imports ?? {}),\n    ...Object.values(importmap?.scope ?? {})\n      .flatMap((map) => Object.values(map)),\n  ];\n\n  return moduleNames.map((moduleName) =>\n    parseModuleNameWrapper(moduleName, parsers)\n  );\n};\n\nconst resolveDenoModuleNameStrings = function (\n  content: string,\n  parsers: ModuleNameParser[],\n): Module[] {\n  const regExps = [\n    /\"https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+\"/g,\n    /'https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+'/g,\n    /`https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+`/g,\n    /\"npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+\"/g,\n    /'npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+'/g,\n    /`npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+`/g,\n  ];\n\n  const moduleNames = regExps.flatMap((regExp) => [...content.matchAll(regExp)])\n    .map((match) => match[0].slice(1, -1));\n\n  return moduleNames.map((moduleName) =>\n    parseModuleNameWrapper(moduleName, parsers)\n  );\n};\n\nexport { resolveDenoModuleNameStrings, resolveImportMap, resolvePackageJson };\n", "{\n  \"name\": \"Delichon\",\n  \"repository\": \"Tsukina-7mochi/delichon\",\n  \"version\": \"0.3.0\"\n}"],
  "mappings": "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",
  "names": ["fs", "posix", "cliffy", "semver", "semver", "moduleTypes", "moduleTypes_default", "decomposePackageNameVersion", "pkgStr", "index", "getLargestVersion", "versions", "max", "ver", "calcLatestVersionRange", "refVer", "level", "range", "resolveNpmPackage", "pkgName", "url", "res", "data", "v", "resolveDenoLandPackage", "resolveRawGitHubContent", "repoName", "token", "headers", "getEsmShVersion", "moduleNameRegExp", "moduleNameMatch", "_", "version", "decomposePackageNameVersion", "resolveEsmSh", "versionRange", "latestUrl", "latestInRangeUrl", "latest", "latestInRange", "versionListCache", "getLatestVersions", "type", "name", "options", "semverOption", "moduleTypes_default", "cacheName", "cachedVersionList", "versionList", "versionListInRange", "versionGreaterRange", "versionListGreater", "checkModuleVersion", "module", "options", "versionFixed", "latestVersions", "getLatestVersions", "latestVer", "latestVerInRange", "outdated", "moduleVersionChecker_default", "fs", "posix", "denoLandUrlParser", "moduleName", "path", "pkgStr", "name", "version", "decomposePackageNameVersion", "moduleTypes_default", "rawGitHubUrlParser", "denoNpmModuleParser", "esmShModuleParser", "parseModuleName", "url", "parsers", "parser", "resolvePackageJson", "content", "packageJson", "results", "name", "moduleTypes_default", "parseModuleNameWrapper", "moduleName", "parsers", "parseModuleName", "resolveImportMap", "importmap", "map", "isDenoProjectCache", "isDenoProject", "cwd", "cachedResult", "denoFileResolver", "content", "resolveImportMap", "denoLandUrlParser", "rawGitHubUrlParser", "denoNpmModuleParser", "esmShModuleParser", "npmPackageJson", "resolvePackageJson", "denoImportMap", "denoDepsTs", "denoDepsJs", "configurations", "app_default", "enumerateFiles", "basePath", "files", "filename", "file", "main", "appVersionCheckResult", "moduleVersionChecker_default", "app_default", "command", "options", "args", "level_", "level", "usePrerelease", "cwd", "v", "fileGlobs", "config", "configurations", "moduleMap", "path", "globName", "content", "module", "modules", "results", "result", "outdatedModules", "notFoundModules", "_", "notFixedModules", "logTable", "outdatedTextMap", "colWidths", "i", "max", "arr", "len"]
}
