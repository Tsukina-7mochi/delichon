import*as ae from"https://deno.land/std@0.189.0/fs/mod.ts";import*as ie from"https://deno.land/std@0.189.0/path/mod.ts";import*as le from"https://deno.land/x/cliffy@v0.25.7/mod.ts";import*as x from"https://deno.land/std@0.189.0/semver/mod.ts";import*as g from"https://deno.land/std@0.189.0/semver/mod.ts";var ue={denoLand:"deno_land",npmPackage:"npm_package",rawGitHub:"raw_github",esmSh:"esm_sh",unknown:"unknown"},p=ue;var v=function(e){let o=e.lastIndexOf("@");return o<=0?[e,""]:[e.slice(0,o),e.slice(o+1)]},D=function(e,o=!1){let n=/\x1b\[\d+(;\d+)*m/g,t=e.reduce((i,c)=>i>=c.length?i:c.length,0),s=new Array(t).fill(0).map(()=>new Array(e.length).fill(0)),a=new Array(e.length).fill(0).map(()=>new Array(t).fill(0));e.forEach((i,c)=>i.forEach((m,d)=>{let h=m.replace(n,"").length;s[d][c]=h,a[c][d]=m.length-h}));let r=s.map(i=>i.reduce((c,m)=>c>=m?c:m)),l=e.map((i,c)=>i.map((m,d)=>(m+" ".repeat(r[d])).slice(0,r[d]+a[c][d])));return o&&l.splice(1,0,r.map(i=>"-".repeat(i))),l.map(i=>i.join(" ")).join(`
`)};var J=e=>e.reduce((o,n)=>g.gt(n,o)?n:o),pe=function(e,o){let n=`>=${e}`;return o==="major"||(o==="minor"?n+=` <=${e.major}`:o==="patch"&&(n+=` <=${e.major}.${e.minor}`)),n},me=async function(e){let o=`https://registry.npmjs.org/${e}`,n=await fetch(o);if(!n.ok)return null;let t=JSON.parse(await n.text());return Object.keys(t.versions).map(a=>g.parse(a)).filter(a=>a!==null)},de=async function(e){let o=`https://apiland.deno.dev/v2/modules/${e}`,n=await fetch(o);return n.ok?JSON.parse(await n.text()).versions.map(a=>g.parse(a)).filter(a=>a!==null):null},fe=async function(e,o){let n={Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"};typeof o=="string"&&Object.defineProperty(n,"Authorization",{value:`Barer ${o}`});let t=await fetch(`https://api.github.com/repos/${e}/releases`,{headers:n});return t.ok?JSON.parse(await t.text()).map(r=>g.parse(r.tag_name)).filter(r=>r!==null):null},U=async function(e){let o=/^\/\* esm.sh - (\S+) \*\//,n=await fetch(e);if(!n.ok)return null;let s=(await n.text()).match(o);if(s===null)return null;let[a,r]=v(s[1]);return r},ge=async function(e,o){let n=`https://esm.sh/${e}`,t=`${n}@${o}`,s=g.parse(await U(n)),a=g.parse(await U(t));return s===null||a===null?null:{latest:s,latestInRange:a}},G=new Map,E=async function(e,o,n,t){let s={includePrerelease:t.usePrerelease};if(e===p.denoLand||e===p.npmPackage||e===p.rawGitHub){let a=e+":"+o,r=G.get(a),l=null;if(typeof r!="undefined"?l=r:(e===p.denoLand?l=await de(o):e===p.npmPackage?l=await me(o):e===p.rawGitHub&&(l=await fe(o,t.gitHubToken)),G.set(a,l)),l===null||l.length<1)return null;let i=l.filter(h=>g.satisfies(h,n,s));if(i.length<1)return null;let c=J(i),m=pe(c,t.level),d=l.filter(h=>g.satisfies(h,m,s));return{latest:J(d),latestInRange:c}}else if(e===p.esmSh)return ge(o,n);return null};var he=async function(e,o){let n=x.parse(e.version??"")!==null,t=await E(e.type,e.name,e.version??"",o);if(t===null)return{module:e,fixed:n,found:!1};let s=t.latest,a=t.latestInRange,r="none";return x.gt(s,a,{includePrerelease:!0})&&(s.major>a.major?r="major":s.minor>a.minor?r="minor":s.patch>a.patch?r="patch":r="pre_release"),{module:e,fixed:n,found:!0,outdated:r!=="none",outdatedLevel:r,latestVersion:s.version,latestVersionInRange:a.version}},k=he;import*as j from"https://deno.land/std@0.189.0/fs/mod.ts";import*as C from"https://deno.land/std@0.189.0/path/mod.ts";var H={test:/^https?:\/\/deno.land/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=o[0]==="x"?o[1]:o[0],[t,s]=v(n);return{type:p.denoLand,name:t,version:s}}},_={test:/^https?:\/\/raw.githubusercontent.com/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=`${o[0]}/${o[1]}`,t=o[2];return{type:p.rawGitHub,name:n,version:t}}},A={test:/^npm:/,parse:e=>{let[o,n]=v(e.slice(4));return{type:p.npmPackage,name:o,version:n}}},X={test:/^https?:\/\/esm.sh/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),[n,t]=v(o[0]);return{type:p.esmSh,name:n,version:t}}},W=function(e,o){for(let n of o)if(n.test.test(e))return n.parse(e);return null};var q=function(e){let o=JSON.parse(e),n=[];for(let t in o.dependencies)n.push({type:p.npmPackage,name:t,version:o.dependencies[t]});for(let t in o.devDependencies)n.push({type:p.npmPackage,name:t,version:o.devDependencies[t]});return n},z=function(e,o){return W(e,o)??{type:p.unknown,name:e,version:null}},B=function(e,o){let n=JSON.parse(e);return[...Object.values((n==null?void 0:n.imports)??{}),...Object.values((n==null?void 0:n.scopes)??{}).flatMap(s=>Object.values(s))].map(s=>z(s,o))},N=function(e,o){return[/"https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+"/g,/'https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+'/g,/`https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+`/g,/"npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+"/g,/'npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+'/g,/`npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+`/g].flatMap(s=>[...e.matchAll(s)]).map(s=>s[0].slice(1,-1)).map(s=>z(s,o))};var P=e=>typeof e=="string"&&isFinite(parseInt(e)),K=function(e,o){let n=/^([v=\^~])?(\d+|[xX*])(?:\.(\d+|[xX*])(?:\.(\d+|[xX*])(.+)?)?)?$/,t=e.match(n);if(t===null)return null;let s=t[1],a=t[2],r=t[3],l=t[4],i=t[5];P(a)&&(a=`${o.major}`),P(r)&&(r=`${o.minor}`),P(l)&&(l=`${o.patch}`),o.prerelease.length===0?i="":i=(i??"-")[0]+o.prerelease.join(".");let c=`${s??""}${a}`;return r&&(c+=`.${r}`),l&&(c+=`.${l}`),i&&(c+=i),c},Y={test:/^https?:\/\/deno.land/,replace:(e,o,n)=>{let t=new URL(e),s=t.pathname.split("/").slice(1),a=s[0]==="x"?s[1]:s[0],[r,l]=v(a);return r!==o?null:(s[s[0]==="x"?1:0]=`${r}@${n}`,`https://deno.land/${s.join("/")}${t.search}`)}},Q={test:/^https?:\/\/raw.githubusercontent.com/,replace:(e,o,n)=>{let t=new URL(e),s=t.pathname.split("/").slice(1);return`${s[0]}/${s[1]}`!==o?null:(s[2]=n,`https://raw.githubusercontent.com/${s.join("/")}${t.search}`)}},Z={test:/^npm:/,replace:(e,o,n)=>{let[t,s]=v(e.slice(4));return t!==o?null:`npm:${t}@${n}`}},ee={test:/^https?:\/\/esm.sh/,replace:(e,o,n)=>{let t=new URL(e),s=t.pathname.split("/").slice(1),[a,r]=v(s[0]);return a!==o?null:`https://esm.sh/${a}@${n}${t.search}`}},y=function(e,o,n,t){for(let s of n)if(s.test.test(e)){let a=s.replace(e,o,t);if(a!==null)return a}return null};import{JSONParser as oe,replaceJSONValue as b}from"https://raw.githubusercontent.com/Tsukina-7mochi/json-edit-formatted/v1.2.0/mod.ts";var ne=function(e,o){let n=oe.parse(e);for(let[t,s]of o){try{b(n,["dependencies",t],JSON.stringify(s));continue}catch{}try{b(n,["devDependencies",t],JSON.stringify(s));continue}catch{}console.error(`Failed to update ${t}`)}return n.stringify()},te=function(e,o,n){let t=JSON.parse(e),s=oe.parse(e);for(let a in t.imports)for(let[r,l]of o){let i=y(t.imports[a],r,n,l);if(typeof i=="string")try{b(s,["imports",a],JSON.stringify(i));break}catch{console.error(`Failed to update ${r}`)}}for(let a in t.scopes)for(let r in t.scopes[a])for(let[l,i]of o){let c=y(t.scopes[a][r],l,n,i);if(typeof c=="string"){try{b(s,["scopes",a,r],JSON.stringify(c));break}catch{console.error(`Failed to update ${l}`)}break}}return s.stringify()},S=function(e,o,n){let t=[/("https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+")/g,/('https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+')/g,/(`https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+`)/g,/("npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+")/g,/('npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+')/g,/(`npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+`)/g],s=e;for(let a of t)s=s.replaceAll(a,r=>{let l=r.slice(1,-1),i=r[0];for(let[c,m]of o){let d=y(l,c,n,m);if(typeof d=="string")return i+d+i}return r});return s};var $=new Map,L=e=>{let o=$.get(e);return typeof o=="boolean"?o:j.existsSync(C.join(e,"deno.json"),{isFile:!0})||j.existsSync(C.join(e,"deno.jsonc"),{isFile:!0})?($.set(e,!0),!0):($.set(e,!1),!1)},F=[H,_,A,X],T=[Y,Q,Z,ee],xe={file:"package.json",resolver:e=>q(e),replacer:(e,o)=>ne(e,o)},ye={file:"import_map.json",enabled:L,resolver:e=>B(e,F),replacer:(e,o)=>te(e,o,T)},be={file:"deps.ts",enabled:L,resolver:e=>N(e,F),replacer:(e,o)=>S(e,o,T)},$e={file:"**/deps.js",enabled:L,resolver:e=>N(e,F),replacer:(e,o)=>S(e,o,T)},I=[xe,ye,be,$e];var M={name:"Delichon",repository:"Tsukina-7mochi/delichon",version:"0.6.2"};import*as se from"https://deno.land/std@0.189.0/semver/mod.ts";var ke=async function(e,o,n,t){let s=[];for(let a of e){if(!a.found)continue;let r=a.module;if(o&&a.outdated){if(typeof r.version!="string")continue;let l=se.parse(a.latestVersion);if(l===null)continue;let i=n?a.latestVersion:K(r.version,l);if(i===null)continue;console.log(`\x1B[32mUpdate\x1B[0m ${r.name}: ${r.version} -> ${i}`),s.push([r.name,i])}else n&&!a.fixed&&(console.log(`\x1B[32mFix\x1B[0m ${r.name}: ${r.version} -> ${a.latestVersionInRange}`),s.push([r.name,a.latestVersionInRange]))}for(let[a,r]of t.entries()){console.log(`Updating ${a}`);let l=await Deno.readTextFile(a);l=r.replacer(l,s),await Deno.writeTextFileSync(a,l)}},re=ke;var Ne=async function*(e,o){for(let n of o)for await(let t of ae.expandGlob(ie.resolve(e,n)))t.isFile&&(yield[t.path,n])},Pe=function(e){let o=r=>r.found,n=r=>!r.found,t=e.filter(o).filter(r=>r.outdated),s=e.filter(n),a=e.filter(r=>!r.fixed);if(console.log(`\x1B[1m${t.length}\x1B[0m module${t.length>1?"s are":" is"} outdated.`),s.length>0&&(console.log("Could not find following modules:"),console.log("  "+s.map(r=>r.module.name).join(", "))),a.length>0&&(console.log("Version not fixed at following modules:"),console.log("  "+a.map(r=>r.module.name).join(", "))),t.length>0){let r=[["","package","current","latest"]],l={major:"\x1B[31mMajor\x1B[0m",minor:"\x1B[33mMinor\x1B[0m",patch:"\x1B[34mPatch\x1B[0m",pre_release:"\x1B[36mPre\x1B[0m",none:"Latest",not_found:"Not Found"};for(let c of t)r.push([`${l[c.outdatedLevel]}`,c.module.name,c.module.version??"(null)",c.latestVersion]);let i=D(r,!0);console.log(i)}},Se=async function(){let e=await k({type:"raw_github",name:M.repository,version:M.version},{usePrerelease:!1,level:"major"});e.found&&e.outdated&&(console.log(`Update ${e.latestVersion} found`),console.log("You can update with $\x1B[33mdeno cache --reload\x1B[0m"));let o=new le.Command().name(M.name).version(M.version).description("Dependency scanner for Node.js and Deno project").option("-u --update [update:boolean]","update versions").option("--fix","fix version").option("-l, --level [level:string]","version update limit",{default:"major"}).option("--gh-token [token:string]","GitHub token to use GitHub API").option("--prerelease","use prerelease").arguments("[path]"),{options:n,args:t}=await o.parse(Deno.args),s=typeof n.level=="string"?n.level.toLowerCase():n.level;s!=="major"&&s!=="minor"&&s!=="patch"&&(console.error(`${s} is not a valid level.`),Deno.exit(1));let a=s,r=n.prerelease===!0,l=n.update===!0,i=n.fix===!0,c=typeof n.ghToken=="string"?n.ghToken:void 0,m=t.filter(u=>typeof u=="string")[0]??Deno.cwd(),d=[];for(let u of I)(u.enabled===void 0||u.enabled(m))&&d.push(u.file);let h=new Map,O=new Map;for await(let[u,f]of Ne(m,d)){console.log(`Scanning ${u}...`);for(let V of I)V.file===f&&h.set(u,V)}for(let[u,f]of h.entries()){let V=await Deno.readTextFile(u);f.resolver(V).forEach(R=>{O.set(`${R.type}-${R.name}-${R.version}`,R)})}let ce=[...O.values()],w=[];for(let u of ce){let f=await k(u,{level:a,usePrerelease:r,gitHubToken:c});f.found?f.outdatedLevel==="none"?f.fixed?console.log(`\u2705 ${u.name} is up to date`):console.log(`\u26A0\uFE0F ${u.name} may up to date (version not fixed)`):f.fixed?console.log(`\u274C ${u.name} is outdated (${f.outdatedLevel})`):console.log(`\u274C ${u.name} is outdated (${f.outdatedLevel}) and version is not fixed`):console.log(`\u2754${u.name} cannot be resolved (${u.type})`),w.push(f)}console.log(),Pe(w),(l||i)&&(console.log(),await re(w,l,i,h))};Se();
