import*as A from"https://deno.land/std@0.183.0/fs/mod.ts";import*as E from"https://deno.land/std@0.183.0/path/mod.ts";import*as q from"https://deno.land/x/cliffy@v0.25.7/mod.ts";import*as i from"https://deno.land/std@0.183.0/semver/mod.ts";import*as b from"https://deno.land/std@0.183.0/semver/mod.ts";var W={denoLand:"deno_land",npmPackage:"npm_package",rawGitHub:"raw_github",unknown:"unknown"},p=W;var z=async function(e){let o=`https://registry.npmjs.org/${e}`,n=await fetch(o);if(!n.ok)return null;let r=JSON.parse(await n.text());return Object.keys(r.versions).map(l=>b.parse(l)).filter(l=>l!==null)},B=async function(e){let o=`https://apiland.deno.dev/v2/modules/${e}`,n=await fetch(o);return n.ok?JSON.parse(await n.text()).versions.map(l=>b.parse(l)).filter(l=>l!==null):null},X=async function(e,o){let n={Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"};typeof o=="string"&&Object.defineProperty(n,"Authorization",{value:`Bearer ${o}`});let r=await fetch(`https://api.github.com/repos/${e}/releases`,{headers:n});return r.ok?JSON.parse(await r.text()).map(c=>b.parse(c.tag_name)).filter(c=>c!==null):null},Y={[p.npmPackage]:z,[p.denoLand]:B,[p.rawGitHub]:X};var $=Y;var L=new Map,K=async function(e,o,...n){let r=e+":"+o,t=L.get(r);if(typeof t!="undefined")return t;let l=await $[e](o,...n);return L.set(r,l),l},G=e=>e.reduce((o,n)=>i.gt(n,o)?n:o),Q=async function(e,o){let n=e.version??"",r=i.parse(n)!==null;if(!(e.type in $))return null;let t=e.type,l=[];t==="raw_github"&&typeof(o==null?void 0:o.gitHubToken)=="string"&&l.push(o.gitHubToken);let c=await K(t,e.name,...l);if(c===null)return{fixed:r,outdated:"not_found",latest:null};o.usePrerelease||(c=c.filter(d=>d.prerelease.length===0));let M=c.filter(d=>i.satisfies(d,n,{includePrerelease:o.usePrerelease}));if(M.length<1)return{fixed:r,outdated:"not_found",latest:null};let g=G(M),x=c.filter(d=>i.gtr(d,n,{includePrerelease:o.usePrerelease})).filter(d=>{switch(o.level){case"major":return!0;case"minor":return i.major(g)===d.major;case"patch":return i.major(g)===d.major&&i.minor(g)===d.minor}}),v="none",u=null;return x.length>0&&(u=G(x),u.major>g.major?v="major":u.minor>g.minor?v="minor":u.patch>g.patch?v="patch":o.usePrerelease&&i.gt(u,g,{includePrerelease:!0})&&(v="pre_release")),{fixed:r,outdated:v,latest:(u==null?void 0:u.version)??null}},R=Q;import*as C from"https://deno.land/std@0.183.0/fs/mod.ts";import*as D from"https://deno.land/std@0.183.0/path/mod.ts";var V=function(e){let o=e.lastIndexOf("@");return o<=0?[e,""]:[e.slice(0,o),e.slice(o+1)]};var k={test:/^https?:\/\/deno.land/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=o[0]==="x"?o[1]:o[0],[r,t]=V(n);return{type:p.denoLand,name:r,version:t}}},N={test:/^https?:\/\/raw.githubusercontent.com/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=`${o[0]}/${o[1]}`,r=o[2];return{type:p.rawGitHub,name:n,version:r}}},w={test:/^npm:/,parse:e=>{let[o,n]=V(e.slice(4));return{type:p.npmPackage,name:o,version:n}}},H=function(e,o){for(let n of o)if(n.test.test(e))return n.parse(e);return null};var J=function(e){let o=JSON.parse(e),n=[];for(let r in o.dependencies)n.push({type:p.npmPackage,name:r,version:o.dependencies[r]});for(let r in o.devDependencies)n.push({type:p.npmPackage,name:r,version:o.devDependencies[r]});return n},U=function(e,o){return H(e,o)??{type:p.unknown,name:e,version:null}},I=function(e,o){let n=JSON.parse(e);return[...Object.values((n==null?void 0:n.imports)??{}),...Object.values((n==null?void 0:n.scope)??{}).flatMap(t=>Object.values(t))].map(t=>U(t,o))},_=function(e,o){return[/"https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+"/g,/'https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+'/g,/`https?:\/\/[\w/:%#\$&\?\(\)~\.=\+\-@]+`/g,/"npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+"/g,/'npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+'/g,/`npm:[\w/:%#\$&\?\(\)~\.=\+\-@]+`/g].flatMap(t=>[...e.matchAll(t)]).map(t=>t[0].slice(1,-1)).map(t=>U(t,o))};var j=new Map,S=e=>{let o=j.get(e);return typeof o=="boolean"?o:C.existsSync(D.join(e,"deno.json"),{isFile:!0})||C.existsSync(D.join(e,"deno.jsonc"),{isFile:!0})?(j.set(e,!0),!0):(j.set(e,!1),!1)},oe={file:"package.json",resolver:e=>J(e)},ne={file:"import_map.json",enabled:S,resolver:e=>I(e,[k,N,w])},se={file:"deps.ts",enabled:S,resolver:e=>_(e,[k,N,w])},re={file:"**/deps.js",enabled:S,resolver:e=>_(e,[k,N,w])},T=[oe,ne,se,re];var P={name:"Delichon",repository:"Tsukina-7mochi/delichon",version:"0.2.0"};var ae=async function*(e,o){for(let n of o)for await(let r of A.expandGlob(E.resolve(e,n)))r.isFile&&(yield[r.path,n])},le=async function(){let e=await R({type:"raw_github",name:P.repository,version:P.version},{usePrerelease:!1,level:"major"});e&&e.outdated!=="none"&&e.outdated!=="not_found"&&(console.log(`Update ${e.latest} found`),console.log("You can update with $\x1B[33mdeno cache --reload\x1B[0m"));let o=new q.Command().name(P.name).version(P.version).description("Dependency scanner for Node.js and Deno project").option("-l, --level [level:string]","version update limit",{default:"major"}).option("--prerelease","use prerelease").arguments("[path]"),{options:n}=await o.parse(Deno.args),r=typeof n.level=="string"?n.level.toLowerCase():n.level;r!=="major"&&r!=="minor"&&r!=="patch"&&(console.error(`${r} is not a valid level.`),Deno.exit(1));let t=r,l=n.prerelease===!0,c=Deno.cwd(),M=[];for(let s of T)(s.enabled===void 0||s.enabled(c))&&M.push(s.file);let g=new Map;for await(let[s,a]of ae(c,M)){console.log(`Scanning ${s}...`);let h=await Deno.readTextFile(s);for(let m of T)m.file===a&&m.resolver(h).forEach(f=>{g.set(`${f.type}-${f.name}`,f)})}let x=[...g.values()],v=[];for(let s of x){let a=await R(s,{level:t,usePrerelease:l});a===null?console.log(`\u2754${s.name} cannot be resolved (${s.type})`):a.outdated==="not_found"?console.log(`\u2754 ${s.name} not found on remote (${s.type})`):a.outdated==="none"?a.fixed?console.log(`\u2705 ${s.name} is up to date`):console.log(`\u26A0\uFE0F ${s.name} may up to date (version not fixed)`):a.fixed?console.log(`\u274C ${s.name} is outdated (${a.outdated})`):console.log(`\u274C ${s.name} is outdated (${a.outdated}) and version is not fixed`),a!==null&&v.push([s,a])}let u=v.filter(([,s])=>s.outdated!=="none"&&s.outdated!=="not_found"),d=v.filter(([s,a])=>a.outdated==="not_found"),O=v.filter(([s,a])=>!a.fixed);if(console.log(),console.log(`\x1B[1m${u.length}\x1B[0m module${u.length>1?"s are":" is"} outdated.`),d.length>0&&(console.log("Could not find following modules:"),console.log("  "+d.map(([s])=>s.name).join(", "))),O.length>0&&(console.log("Version not fixed at following modules:"),console.log("  "+O.map(([s])=>s.name).join(", "))),u.length>0){let s=[["","package","current","latest"]],a={major:"\x1B[31mMajor\x1B[0m",minor:"\x1B[33mMinor\x1B[0m",patch:"\x1B[34mPatch\x1B[0m",pre_release:"\x1B[36mPre\x1B[0m",none:"Latest",not_found:"Not Found"};for(let[m,f]of u)s.push([`${a[f.outdated]}`,m.name,m.version??"(null)",f.latest??"(null)"]);let h=new Array(s[0].length).fill(0).map((m,f)=>s.reduce((y,F)=>F[f].length>y?F[f].length:y,0));s=s.map(m=>m.map((f,y)=>`${f}${" ".repeat(h[y])}`.slice(0,h[y]))),h[0]=5,s[0][0]="     ",console.log(s[0].join(" ")),console.log(h.map(m=>"-".repeat(m)).join(" ")),console.log(s.slice(1).map(m=>m.join(" ")).join(`
`))}};le();
