import*as W from"https://deno.land/std@0.183.0/fs/mod.ts";import*as q from"https://deno.land/std@0.183.0/path/mod.ts";import*as z from"https://deno.land/x/cliffy@v0.25.7/mod.ts";import*as k from"https://deno.land/std@0.183.0/semver/mod.ts";import*as g from"https://deno.land/std@0.183.0/semver/mod.ts";var X={denoLand:"deno_land",npmPackage:"npm_package",rawGitHub:"raw_github",esmSh:"esm_sh",unknown:"unknown"},c=X;var M=function(e){let o=e.lastIndexOf("@");return o<=0?[e,""]:[e.slice(0,o),e.slice(o+1)]},T=function(e,o=!1){let n=/\x1b\[\d+(;\d+)*m/g,s=e.reduce((l,u)=>l>=u.length?l:u.length,0),t=new Array(s).fill(0).map(()=>new Array(e.length).fill(0)),a=new Array(e.length).fill(0).map(()=>new Array(s).fill(0));e.forEach((l,u)=>l.forEach((p,m)=>{let h=p.replace(n,"").length;t[m][u]=h,a[u][m]=p.length-h}));let i=t.map(l=>l.reduce((u,p)=>u>=p?u:p)),d=e.map((l,u)=>l.map((p,m)=>(p+" ".repeat(i[m])).slice(0,i[m]+a[u][m])));return o&&d.splice(1,0,i.map(l=>"-".repeat(l))),d.map(l=>l.join(" ")).join(`
`)};var F=e=>e.reduce((o,n)=>g.gt(n,o)?n:o),Y=function(e,o){let n=`>=${e}`;return o==="major"||(o==="minor"?n+=` <=${e.major}`:o==="patch"&&(n+=` <=${e.major}.${e.minor}`)),n},K=async function(e){let o=`https://registry.npmjs.org/${e}`,n=await fetch(o);if(!n.ok)return null;let s=JSON.parse(await n.text());return Object.keys(s.versions).map(a=>g.parse(a)).filter(a=>a!==null)},Q=async function(e){let o=`https://apiland.deno.dev/v2/modules/${e}`,n=await fetch(o);return n.ok?JSON.parse(await n.text()).versions.map(a=>g.parse(a)).filter(a=>a!==null):null},Z=async function(e,o){let n={Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"};typeof o=="string"&&Object.defineProperty(n,"Authorization",{value:`Bearer ${o}`});let s=await fetch(`https://api.github.com/repos/${e}/releases`,{headers:n});return s.ok?JSON.parse(await s.text()).map(i=>g.parse(i.tag_name)).filter(i=>i!==null):null},O=async function(e){let o=/^\/\* esm.sh - (\S+) \*\//,n=await fetch(e);if(!n.ok)return null;let t=(await n.text()).match(o);if(t===null)return null;let[a,i]=M(t[1]);return i},ee=async function(e,o){let n=`https://esm.sh/${e}`,s=`${n}@${o}`,t=g.parse(await O(n)),a=g.parse(await O(s));return t===null||a===null?null:{latest:t,latestInRange:a}},D=new Map,I=async function(e,o,n,s){let t={includePrerelease:s.usePrerelease};if(e===c.denoLand||e===c.npmPackage||e===c.rawGitHub){let a=e+":"+o,i=D.get(a),d=null;if(typeof i!="undefined"?d=i:(e===c.denoLand?d=await Q(o):e===c.npmPackage?d=await K(o):e===c.rawGitHub&&(d=await Z(o,s.gitHubToken)),D.set(a,d)),d===null||d.length<1)return null;let l=d.filter(h=>g.satisfies(h,n,t));if(l.length<1)return null;let u=F(l),p=Y(u,s.level),m=d.filter(h=>g.satisfies(h,p,t));return{latest:F(m),latestInRange:u}}else if(e===c.esmSh)return ee(o,n);return null};var oe=async function(e,o){let n=k.parse(e.version??"")!==null,s=await I(e.type,e.name,e.version??"",o);if(s===null)return{module:e,fixed:n,found:!1};let t=s.latest,a=s.latestInRange,i="none";return k.gt(t,a,{includePrerelease:!0})&&(t.major>a.major?i="major":t.minor>a.minor?i="minor":t.patch>a.patch?i="patch":i="pre_release"),{module:e,fixed:n,found:!0,outdated:i!=="none",outdatedLevel:i,latestVersion:t.version,latestVersionInRange:a.version}},V=oe;import*as N from"https://deno.land/std@0.183.0/fs/mod.ts";import*as R from"https://deno.land/std@0.183.0/path/mod.ts";var G={test:/^https?:\/\/deno.land/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=o[0]==="x"?o[1]:o[0],[s,t]=M(n);return{type:c.denoLand,name:s,version:t}}},_={test:/^https?:\/\/raw.githubusercontent.com/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=`${o[0]}/${o[1]}`,s=o[2];return{type:c.rawGitHub,name:n,version:s}}},E={test:/^npm:/,parse:e=>{let[o,n]=M(e.slice(4));return{type:c.npmPackage,name:o,version:n}}},J={test:/^https?:\/\/esm.sh/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),[n,s]=M(o[0]);return{type:c.esmSh,name:n,version:s}}},H=function(e,o){for(let n of o)if(n.test.test(e))return n.parse(e);return null};var U=function(e){let o=JSON.parse(e),n=[];for(let s in o.dependencies)n.push({type:c.npmPackage,name:s,version:o.dependencies[s]});for(let s in o.devDependencies)n.push({type:c.npmPackage,name:s,version:o.devDependencies[s]});return n},se=function(e,o){return H(e,o)??{type:c.unknown,name:e,version:null}},A=function(e,o){let n=JSON.parse(e);return[...Object.values((n==null?void 0:n.imports)??{}),...Object.values((n==null?void 0:n.scope)??{}).flatMap(t=>Object.values(t))].map(t=>se(t,o))};var x=new Map,j=e=>{let o=x.get(e);return typeof o=="boolean"?o:N.existsSync(R.join(e,"deno.json"),{isFile:!0})||N.existsSync(R.join(e,"deno.jsonc"),{isFile:!0})?(x.set(e,!0),!0):(x.set(e,!1),!1)},$=e=>A(e,[G,_,E,J]),re={file:"package.json",resolver:e=>U(e)},ae={file:"import_map.json",enabled:j,resolver:$},ie={file:"deps.ts",enabled:j,resolver:$},le={file:"**/deps.js",enabled:j,resolver:$},C=[re,ae,ie,le];var y={name:"Delichon",repository:"Tsukina-7mochi/delichon",version:"0.3.1"};var ue=async function*(e,o){for(let n of o)for await(let s of W.expandGlob(q.resolve(e,n)))s.isFile&&(yield[s.path,n])},de=async function(){let e=await V({type:"raw_github",name:y.repository,version:y.version},{usePrerelease:!1,level:"major"});e.found&&e.outdated&&(console.log(`Update ${e.latestVersion} found`),console.log("You can update with $\x1B[33mdeno cache --reload\x1B[0m"));let o=new z.Command().name(y.name).version(y.version).description("Dependency scanner for Node.js and Deno project").option("-l, --level [level:string]","version update limit",{default:"major"}).option("--prerelease","use prerelease").arguments("[path]"),{options:n,args:s}=await o.parse(Deno.args),t=typeof n.level=="string"?n.level.toLowerCase():n.level;t!=="major"&&t!=="minor"&&t!=="patch"&&(console.error(`${t} is not a valid level.`),Deno.exit(1));let a=t,i=n.prerelease===!0,d=s.filter(r=>typeof r=="string")[0]??Deno.cwd(),l=[];for(let r of C)(r.enabled===void 0||r.enabled(d))&&l.push(r.file);let u=new Map;for await(let[r,f]of ue(d,l)){console.log(`Scanning ${r}...`);let P=await Deno.readTextFile(r);for(let v of C)v.file===f&&v.resolver(P).forEach(w=>{u.set(`${w.type}-${w.name}`,w)})}let p=[...u.values()],m=[];for(let r of p){let f=await V(r,{level:a,usePrerelease:i});f.found?f.outdatedLevel==="none"?f.fixed?console.log(`\u2705 ${r.name} is up to date`):console.log(`\u26A0\uFE0F ${r.name} may up to date (version not fixed)`):f.fixed?console.log(`\u274C ${r.name} is outdated (${f.outdatedLevel})`):console.log(`\u274C ${r.name} is outdated (${f.outdatedLevel}) and version is not fixed`):console.log(`\u2754${r.name} cannot be resolved (${r.type})`),m.push(f)}console.log();let h=r=>r.found,B=r=>!r.found,b=m.filter(h).filter(r=>r.outdated),L=m.filter(B),S=m.filter(r=>!r.fixed);if(console.log(`\x1B[1m${b.length}\x1B[0m module${b.length>1?"s are":" is"} outdated.`),L.length>0&&(console.log("Could not find following modules:"),console.log("  "+L.map(r=>r.module.name).join(", "))),S.length>0&&(console.log("Version not fixed at following modules:"),console.log("  "+S.map(r=>r.module.name).join(", "))),b.length>0){let r=[["","package","current","latest"]],f={major:"\x1B[31mMajor\x1B[0m",minor:"\x1B[33mMinor\x1B[0m",patch:"\x1B[34mPatch\x1B[0m",pre_release:"\x1B[36mPre\x1B[0m",none:"Latest",not_found:"Not Found"};for(let v of b)r.push([`${f[v.outdatedLevel]}`,v.module.name,v.module.version??"(null)",v.latestVersion]);let P=T(r,!0);console.log(P)}};de();
