import*as q from"https://deno.land/std@0.183.0/fs/mod.ts";import*as W from"https://deno.land/std@0.183.0/path/mod.ts";import*as z from"https://deno.land/x/cliffy@v0.25.7/mod.ts";import*as b from"https://deno.land/std@0.183.0/semver/mod.ts";import*as d from"https://deno.land/std@0.183.0/semver/mod.ts";var B={denoLand:"deno_land",npmPackage:"npm_package",rawGitHub:"raw_github",esmSh:"esm_sh",unknown:"unknown"},l=B;var v=function(e){let o=e.lastIndexOf("@");return o<=0?[e,""]:[e.slice(0,o),e.slice(o+1)]};var T=e=>e.reduce((o,n)=>d.gt(n,o)?n:o),X=function(e,o){let n=`>=${e}`;return o==="major"||(o==="minor"?n+=` <=${e.major}`:o==="patch"&&(n+=` <=${e.major}.${e.minor}`)),n},Y=async function(e){let o=`https://registry.npmjs.org/${e}`,n=await fetch(o);if(!n.ok)return null;let s=JSON.parse(await n.text());return Object.keys(s.versions).map(a=>d.parse(a)).filter(a=>a!==null)},K=async function(e){let o=`https://apiland.deno.dev/v2/modules/${e}`,n=await fetch(o);return n.ok?JSON.parse(await n.text()).versions.map(a=>d.parse(a)).filter(a=>a!==null):null},Q=async function(e,o){let n={Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28"};typeof o=="string"&&Object.defineProperty(n,"Authorization",{value:`Bearer ${o}`});let s=await fetch(`https://api.github.com/repos/${e}/releases`,{headers:n});return s.ok?JSON.parse(await s.text()).map(c=>d.parse(c.tag_name)).filter(c=>c!==null):null},O=async function(e){let o=/^\/\* esm.sh - (\S+) \*\//,n=await fetch(e);if(!n.ok)return null;let r=(await n.text()).match(o);if(r===null)return null;let[a,c]=v(r[1]);return c},Z=async function(e,o){let n=`https://esm.sh/${e}`,s=`${n}@${o}`,r=d.parse(await O(n)),a=d.parse(await O(s));return r===null||a===null?null:{latest:r,latestInRange:a}},D=new Map,F=async function(e,o,n,s){let r={includePrerelease:s.usePrerelease};if(e===l.denoLand||e===l.npmPackage||e===l.rawGitHub){let a=e+":"+o,c=D.get(a),u=null;if(typeof c!="undefined"?u=c:(e===l.denoLand?u=await K(o):e===l.npmPackage?u=await Y(o):e===l.rawGitHub&&(u=await Q(o,s.gitHubToken)),D.set(a,u)),u===null||u.length<1)return null;let M=u.filter(f=>d.satisfies(f,n,r));if(M.length<1)return null;let y=T(M),k=X(y,s.level),g=u.filter(f=>d.satisfies(f,k,r));return{latest:T(g),latestInRange:y}}else if(e===l.esmSh)return Z(o,n);return null};var ee=async function(e,o){let n=b.parse(e.version??"")!==null,s=await F(e.type,e.name,e.version??"",o);if(s===null)return{fixed:n,outdated:"not_found",latest:null};let r=s.latest,a=s.latestInRange,c="none";return r.major>a.major?c="major":r.minor>a.minor?c="minor":r.patch>a.patch?c="patch":o.usePrerelease&&b.gt(r,a,{includePrerelease:!0})&&(c="pre_release"),{fixed:n,outdated:c,latest:(r==null?void 0:r.version)??null}},N=ee;import*as j from"https://deno.land/std@0.183.0/fs/mod.ts";import*as $ from"https://deno.land/std@0.183.0/path/mod.ts";var G={test:/^https?:\/\/deno.land/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=o[0]==="x"?o[1]:o[0],[s,r]=v(n);return{type:l.denoLand,name:s,version:r}}},I={test:/^https?:\/\/raw.githubusercontent.com/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),n=`${o[0]}/${o[1]}`,s=o[2];return{type:l.rawGitHub,name:n,version:s}}},J={test:/^npm:/,parse:e=>{let[o,n]=v(e.slice(4));return{type:l.npmPackage,name:o,version:n}}},H={test:/^https?:\/\/esm.sh/,parse:e=>{let o=new URL(e).pathname.split("/").slice(1),[n,s]=v(o[0]);return{type:l.esmSh,name:n,version:s}}},U=function(e,o){for(let n of o)if(n.test.test(e))return n.parse(e);return null};var E=function(e){let o=JSON.parse(e),n=[];for(let s in o.dependencies)n.push({type:l.npmPackage,name:s,version:o.dependencies[s]});for(let s in o.devDependencies)n.push({type:l.npmPackage,name:s,version:o.devDependencies[s]});return n},ne=function(e,o){return U(e,o)??{type:l.unknown,name:e,version:null}},A=function(e,o){let n=JSON.parse(e);return[...Object.values((n==null?void 0:n.imports)??{}),...Object.values((n==null?void 0:n.scope)??{}).flatMap(r=>Object.values(r))].map(r=>ne(r,o))};var w=new Map,R=e=>{let o=w.get(e);return typeof o=="boolean"?o:j.existsSync($.join(e,"deno.json"),{isFile:!0})||j.existsSync($.join(e,"deno.jsonc"),{isFile:!0})?(w.set(e,!0),!0):(w.set(e,!1),!1)},V=e=>A(e,[G,I,J,H]),se={file:"package.json",resolver:e=>E(e)},re={file:"import_map.json",enabled:R,resolver:V},ae={file:"deps.ts",enabled:R,resolver:V},ie={file:"**/deps.js",enabled:R,resolver:V},S=[se,re,ae,ie];var P={name:"Delichon",repository:"Tsukina-7mochi/delichon",version:"0.2.2"};var ce=async function*(e,o){for(let n of o)for await(let s of q.expandGlob(W.resolve(e,n)))s.isFile&&(yield[s.path,n])},ue=async function(){let e=await N({type:"raw_github",name:P.repository,version:P.version},{usePrerelease:!1,level:"major"});e&&e.outdated!=="none"&&e.outdated!=="not_found"&&(console.log(`Update ${e.latest} found`),console.log("You can update with $\x1B[33mdeno cache --reload\x1B[0m"));let o=new z.Command().name(P.name).version(P.version).description("Dependency scanner for Node.js and Deno project").option("-l, --level [level:string]","version update limit",{default:"major"}).option("--prerelease","use prerelease").arguments("[path]"),{options:n,args:s}=await o.parse(Deno.args),r=typeof n.level=="string"?n.level.toLowerCase():n.level;r!=="major"&&r!=="minor"&&r!=="patch"&&(console.error(`${r} is not a valid level.`),Deno.exit(1));let a=r,c=n.prerelease===!0,u=s.filter(t=>typeof t=="string")[0]??Deno.cwd(),M=[];for(let t of S)(t.enabled===void 0||t.enabled(u))&&M.push(t.file);let y=new Map;for await(let[t,i]of ce(u,M)){console.log(`Scanning ${t}...`);let h=await Deno.readTextFile(t);for(let m of S)m.file===i&&m.resolver(h).forEach(p=>{y.set(`${p.type}-${p.name}`,p)})}let k=[...y.values()],g=[];for(let t of k){let i=await N(t,{level:a,usePrerelease:c});i===null?console.log(`\u2754${t.name} cannot be resolved (${t.type})`):i.outdated==="not_found"?console.log(`\u2754 ${t.name} not found on remote (${t.type})`):i.outdated==="none"?i.fixed?console.log(`\u2705 ${t.name} is up to date`):console.log(`\u26A0\uFE0F ${t.name} may up to date (version not fixed)`):i.fixed?console.log(`\u274C ${t.name} is outdated (${i.outdated})`):console.log(`\u274C ${t.name} is outdated (${i.outdated}) and version is not fixed`),i!==null&&g.push([t,i])}let f=g.filter(([,t])=>t.outdated!=="none"&&t.outdated!=="not_found"),_=g.filter(([t,i])=>i.outdated==="not_found"),C=g.filter(([t,i])=>!i.fixed);if(console.log(),console.log(`\x1B[1m${f.length}\x1B[0m module${f.length>1?"s are":" is"} outdated.`),_.length>0&&(console.log("Could not find following modules:"),console.log("  "+_.map(([t])=>t.name).join(", "))),C.length>0&&(console.log("Version not fixed at following modules:"),console.log("  "+C.map(([t])=>t.name).join(", "))),f.length>0){let t=[["","package","current","latest"]],i={major:"\x1B[31mMajor\x1B[0m",minor:"\x1B[33mMinor\x1B[0m",patch:"\x1B[34mPatch\x1B[0m",pre_release:"\x1B[36mPre\x1B[0m",none:"Latest",not_found:"Not Found"};for(let[m,p]of f)t.push([`${i[p.outdated]}`,m.name,m.version??"(null)",p.latest??"(null)"]);let h=new Array(t[0].length).fill(0).map((m,p)=>t.reduce((x,L)=>L[p].length>x?L[p].length:x,0));t=t.map(m=>m.map((p,x)=>`${p}${" ".repeat(h[x])}`.slice(0,h[x]))),h[0]=5,t[0][0]="     ",console.log(t[0].join(" ")),console.log(h.map(m=>"-".repeat(m)).join(" ")),console.log(t.slice(1).map(m=>m.join(" ")).join(`
`))}};ue();
