{
  "version": 3,
  "sources": ["esbuild-cache-plugin:https://deno.land/std@0.183.0/_util/os.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/path/win32.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/path/_util.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/_util/asserts.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/path/posix.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/path/separator.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/path/glob.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/path/mod.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/fs/_util.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/fs/exists.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/fs/walk.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/fs/expand_glob.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/fs/move.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/ansi/ansi_escapes.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/encoding/base64.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/ansi/ansi.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/fmt/colors.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/ansi/colors.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/ansi/cursor_position.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/ansi/tty.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/_utils/distance.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/_utils.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/_errors.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/_utils.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/_errors.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/types/boolean.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/types/number.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/types/string.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/_validate_flags.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/types/integer.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/flags/flags.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/type.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/types/boolean.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/types/string.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/types/file.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/types/number.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/table/border.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/table/cell.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/table/row.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/table/utils.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/table/layout.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/table/table.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/help/_help_generator.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/types/integer.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/command/command.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/keycode/key_codes.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/keycode/key_code.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/prompt/figures.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/_util/os.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/path/win32.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/path/_util.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/_util/asserts.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/path/posix.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/path/glob.ts", "esbuild-cache-plugin:https://deno.land/std@0.170.0/path/mod.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/prompt/_generic_prompt.ts", "esbuild-cache-plugin:https://deno.land/x/cliffy@v0.25.7/prompt/_generic_suggestions.ts", "esbuild-cache-plugin:https://deno.land/std@0.183.0/semver/mod.ts", "../src/moduleTypes.ts", "../src/pkgResolver.ts", "../src/moduleVersionChecker.ts", "../src/util.ts", "../src/moduleNameParser.ts", "../src/fileResolver.ts", "../src/files.ts", "../src/mod.ts"],
  "sourcesContent": ["// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nexport type OSType = \"windows\" | \"linux\" | \"darwin\" | \"freebsd\";\n\nexport const osType: OSType = (() => {\n  // deno-lint-ignore no-explicit-any\n  const { Deno } = globalThis as any;\n  if (typeof Deno?.build?.os === \"string\") {\n    return Deno.build.os;\n  }\n\n  // deno-lint-ignore no-explicit-any\n  const { navigator } = globalThis as any;\n  if (navigator?.appVersion?.includes?.(\"Win\")) {\n    return \"windows\";\n  }\n\n  return \"linux\";\n})();\n\nexport const isWindows = osType === \"windows\";\nexport const isLinux = osType === \"linux\";\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject, ParsedPath } from \"./_interface.ts\";\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_DOT,\n  CHAR_QUESTION_MARK,\n} from \"./_constants.ts\";\n\nimport {\n  _format,\n  assertPath,\n  encodeWhitespace,\n  isPathSeparator,\n  isPosixPathSeparator,\n  isWindowsDeviceRoot,\n  lastPathSegment,\n  normalizeString,\n  stripSuffix,\n  stripTrailingSeparators,\n} from \"./_util.ts\";\nimport { assert } from \"../_util/asserts.ts\";\n\nexport const sep = \"\\\\\";\nexport const delimiter = \";\";\n\n/**\n * Resolves path segments into a `path`\n * @param pathSegments to process to path\n */\nexport function resolve(...pathSegments: string[]): string {\n  let resolvedDevice = \"\";\n  let resolvedTail = \"\";\n  let resolvedAbsolute = false;\n\n  for (let i = pathSegments.length - 1; i >= -1; i--) {\n    let path: string;\n    // deno-lint-ignore no-explicit-any\n    const { Deno } = globalThis as any;\n    if (i >= 0) {\n      path = pathSegments[i];\n    } else if (!resolvedDevice) {\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a drive-letter-less path without a CWD.\");\n      }\n      path = Deno.cwd();\n    } else {\n      if (\n        typeof Deno?.env?.get !== \"function\" || typeof Deno?.cwd !== \"function\"\n      ) {\n        throw new TypeError(\"Resolved a relative path without a CWD.\");\n      }\n      path = Deno.cwd();\n\n      // Verify that a cwd was found and that it actually points\n      // to our drive. If not, default to the drive's root.\n      if (\n        path === undefined ||\n        path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\\\`\n      ) {\n        path = `${resolvedDevice}\\\\`;\n      }\n    }\n\n    assertPath(path);\n\n    const len = path.length;\n\n    // Skip empty entries\n    if (len === 0) continue;\n\n    let rootEnd = 0;\n    let device = \"\";\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n\n    // Try to match a root\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last)}`;\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator\n      rootEnd = 1;\n      isAbsolute = true;\n    }\n\n    if (\n      device.length > 0 &&\n      resolvedDevice.length > 0 &&\n      device.toLowerCase() !== resolvedDevice.toLowerCase()\n    ) {\n      // This path points to another device so it is not applicable\n      continue;\n    }\n\n    if (resolvedDevice.length === 0 && device.length > 0) {\n      resolvedDevice = device;\n    }\n    if (!resolvedAbsolute) {\n      resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n      resolvedAbsolute = isAbsolute;\n    }\n\n    if (resolvedAbsolute && resolvedDevice.length > 0) break;\n  }\n\n  // At this point the path should be resolved to a full absolute path,\n  // but handle relative paths to be safe (might happen when process.cwd()\n  // fails)\n\n  // Normalize the tail path\n  resolvedTail = normalizeString(\n    resolvedTail,\n    !resolvedAbsolute,\n    \"\\\\\",\n    isPathSeparator,\n  );\n\n  return resolvedDevice + (resolvedAbsolute ? \"\\\\\" : \"\") + resolvedTail || \".\";\n}\n\n/**\n * Normalizes a `path`\n * @param path to normalize\n */\nexport function normalize(path: string): string {\n  assertPath(path);\n  const len = path.length;\n  if (len === 0) return \".\";\n  let rootEnd = 0;\n  let device: string | undefined;\n  let isAbsolute = false;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            // Treat separator following drive name as an absolute path\n            // indicator\n            isAbsolute = true;\n            rootEnd = 3;\n          }\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid unnecessary\n    // work\n    return \"\\\\\";\n  }\n\n  let tail: string;\n  if (rootEnd < len) {\n    tail = normalizeString(\n      path.slice(rootEnd),\n      !isAbsolute,\n      \"\\\\\",\n      isPathSeparator,\n    );\n  } else {\n    tail = \"\";\n  }\n  if (tail.length === 0 && !isAbsolute) tail = \".\";\n  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n    tail += \"\\\\\";\n  }\n  if (device === undefined) {\n    if (isAbsolute) {\n      if (tail.length > 0) return `\\\\${tail}`;\n      else return \"\\\\\";\n    } else if (tail.length > 0) {\n      return tail;\n    } else {\n      return \"\";\n    }\n  } else if (isAbsolute) {\n    if (tail.length > 0) return `${device}\\\\${tail}`;\n    else return `${device}\\\\`;\n  } else if (tail.length > 0) {\n    return device + tail;\n  } else {\n    return device;\n  }\n}\n\n/**\n * Verifies whether path is absolute\n * @param path to verify\n */\nexport function isAbsolute(path: string): boolean {\n  assertPath(path);\n  const len = path.length;\n  if (len === 0) return false;\n\n  const code = path.charCodeAt(0);\n  if (isPathSeparator(code)) {\n    return true;\n  } else if (isWindowsDeviceRoot(code)) {\n    // Possible device root\n\n    if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n      if (isPathSeparator(path.charCodeAt(2))) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n * @param paths to be joined and normalized\n */\nexport function join(...paths: string[]): string {\n  const pathsCount = paths.length;\n  if (pathsCount === 0) return \".\";\n\n  let joined: string | undefined;\n  let firstPart: string | null = null;\n  for (let i = 0; i < pathsCount; ++i) {\n    const path = paths[i];\n    assertPath(path);\n    if (path.length > 0) {\n      if (joined === undefined) joined = firstPart = path;\n      else joined += `\\\\${path}`;\n    }\n  }\n\n  if (joined === undefined) return \".\";\n\n  // Make sure that the joined path doesn't start with two slashes, because\n  // normalize() will mistake it for an UNC path then.\n  //\n  // This step is skipped when it is very clear that the user actually\n  // intended to point at an UNC path. This is assumed when the first\n  // non-empty string arguments starts with exactly two slashes followed by\n  // at least one more non-slash character.\n  //\n  // Note that for normalize() to treat a path as an UNC path it needs to\n  // have at least 2 components, so we don't filter for that here.\n  // This means that the user can use join to construct UNC paths from\n  // a server name and a share name; for example:\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n  let needsReplace = true;\n  let slashCount = 0;\n  assert(firstPart != null);\n  if (isPathSeparator(firstPart.charCodeAt(0))) {\n    ++slashCount;\n    const firstLen = firstPart.length;\n    if (firstLen > 1) {\n      if (isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n  }\n  if (needsReplace) {\n    // Find any more consecutive slashes we need to replace\n    for (; slashCount < joined.length; ++slashCount) {\n      if (!isPathSeparator(joined.charCodeAt(slashCount))) break;\n    }\n\n    // Replace the slashes if needed\n    if (slashCount >= 2) joined = `\\\\${joined.slice(slashCount)}`;\n  }\n\n  return normalize(joined);\n}\n\n/**\n * It will solve the relative path from `from` to `to`, for instance:\n *  from = 'C:\\\\orandea\\\\test\\\\aaa'\n *  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n * @param from relative path\n * @param to relative path\n */\nexport function relative(from: string, to: string): string {\n  assertPath(from);\n  assertPath(to);\n\n  if (from === to) return \"\";\n\n  const fromOrig = resolve(from);\n  const toOrig = resolve(to);\n\n  if (fromOrig === toOrig) return \"\";\n\n  from = fromOrig.toLowerCase();\n  to = toOrig.toLowerCase();\n\n  if (from === to) return \"\";\n\n  // Trim any leading backslashes\n  let fromStart = 0;\n  let fromEnd = from.length;\n  for (; fromStart < fromEnd; ++fromStart) {\n    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for (; fromEnd - 1 > fromStart; --fromEnd) {\n    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  let toStart = 0;\n  let toEnd = to.length;\n  for (; toStart < toEnd; ++toStart) {\n    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for (; toEnd - 1 > toStart; --toEnd) {\n    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return toOrig.slice(toStart + i + 1);\n        } else if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i;\n  }\n\n  // We found a mismatch before the first common path separator was seen, so\n  // return the original `to`.\n  if (i !== length && lastCommonSep === -1) {\n    return toOrig;\n  }\n\n  let out = \"\";\n  if (lastCommonSep === -1) lastCommonSep = 0;\n  // Generate the relative path based on the path difference between `to` and\n  // `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n      if (out.length === 0) out += \"..\";\n      else out += \"\\\\..\";\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) {\n    return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n  } else {\n    toStart += lastCommonSep;\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;\n    return toOrig.slice(toStart, toEnd);\n  }\n}\n\n/**\n * Resolves path to a namespace path\n * @param path to resolve to namespace\n */\nexport function toNamespacedPath(path: string): string {\n  // Note: this will *probably* throw somewhere.\n  if (typeof path !== \"string\") return path;\n  if (path.length === 0) return \"\";\n\n  const resolvedPath = resolve(path);\n\n  if (resolvedPath.length >= 3) {\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n      // Possible device root\n\n      if (\n        resolvedPath.charCodeAt(1) === CHAR_COLON &&\n        resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH\n      ) {\n        // Matched device root, convert the path to a long UNC path\n        return `\\\\\\\\?\\\\${resolvedPath}`;\n      }\n    }\n  }\n\n  return path;\n}\n\n/**\n * Return the directory path of a `path`.\n * @param path - path to extract the directory from.\n */\nexport function dirname(path: string): string {\n  assertPath(path);\n  const len = path.length;\n  if (len === 0) return \".\";\n  let rootEnd = -1;\n  let end = -1;\n  let matchedSlash = true;\n  let offset = 0;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = offset = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    return path;\n  }\n\n  for (let i = len - 1; i >= offset; --i) {\n    if (isPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) {\n    if (rootEnd === -1) return \".\";\n    else end = rootEnd;\n  }\n  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\n}\n\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @param path - path to extract name from.\n * @param [suffix] - suffix to remove from extracted name.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  assertPath(path);\n\n  if (path.length === 0) return path;\n\n  if (typeof suffix !== \"string\") {\n    throw new TypeError(\n      `Suffix must be a string. Received ${JSON.stringify(suffix)}`,\n    );\n  }\n\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n  let start = 0;\n  if (path.length >= 2) {\n    const drive = path.charCodeAt(0);\n    if (isWindowsDeviceRoot(drive)) {\n      if (path.charCodeAt(1) === CHAR_COLON) start = 2;\n    }\n  }\n\n  const lastSegment = lastPathSegment(path, isPathSeparator, start);\n  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n\n/**\n * Return the extension of the `path` with leading period.\n * @param path with extension\n * @returns extension (ex. for `file.ts` returns `.ts`)\n */\nexport function extname(path: string): string {\n  assertPath(path);\n  let start = 0;\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n\n  if (\n    path.length >= 2 &&\n    path.charCodeAt(1) === CHAR_COLON &&\n    isWindowsDeviceRoot(path.charCodeAt(0))\n  ) {\n    start = startPart = 2;\n  }\n\n  for (let i = path.length - 1; i >= start; --i) {\n    const code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n\n/**\n * Generate a path from `FormatInputPathObject` object.\n * @param pathObject with path\n */\nexport function format(pathObject: FormatInputPathObject): string {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(\n      `The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`,\n    );\n  }\n  return _format(\"\\\\\", pathObject);\n}\n\n/**\n * Return a `ParsedPath` object of the `path`.\n * @param path to process\n */\nexport function parse(path: string): ParsedPath {\n  assertPath(path);\n\n  const ret: ParsedPath = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n\n  const len = path.length;\n  if (len === 0) return ret;\n\n  let rootEnd = 0;\n  let code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            if (len === 3) {\n              // `path` contains just a drive root, exit early to avoid\n              // unnecessary work\n              ret.root = ret.dir = path;\n              ret.base = \"\\\\\";\n              return ret;\n            }\n            rootEnd = 3;\n          }\n        } else {\n          // `path` contains just a relative drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    ret.root = ret.dir = path;\n    ret.base = \"\\\\\";\n    return ret;\n  }\n\n  if (rootEnd > 0) ret.root = path.slice(0, rootEnd);\n\n  let startDot = -1;\n  let startPart = rootEnd;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= rootEnd; --i) {\n    code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    if (end !== -1) {\n      ret.base = ret.name = path.slice(startPart, end);\n    }\n  } else {\n    ret.name = path.slice(startPart, startDot);\n    ret.base = path.slice(startPart, end);\n    ret.ext = path.slice(startDot, end);\n  }\n\n  // Fallback to '\\' in case there is no basename\n  ret.base = ret.base || \"\\\\\";\n\n  // If the directory is the root, use the entire root as the `dir` including\n  // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n  // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n  if (startPart > 0 && startPart !== rootEnd) {\n    ret.dir = path.slice(0, startPart - 1);\n  } else ret.dir = ret.root;\n\n  return ret;\n}\n\n/**\n * Converts a file URL to a path string.\n *\n * ```ts\n *      import { fromFileUrl } from \"https://deno.land/std@$STD_VERSION/path/win32.ts\";\n *      fromFileUrl(\"file:///home/foo\"); // \"\\\\home\\\\foo\"\n *      fromFileUrl(\"file:///C:/Users/foo\"); // \"C:\\\\Users\\\\foo\"\n *      fromFileUrl(\"file://localhost/home/foo\"); // \"\\\\\\\\localhost\\\\home\\\\foo\"\n * ```\n * @param url of a file URL\n */\nexport function fromFileUrl(url: string | URL): string {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol != \"file:\") {\n    throw new TypeError(\"Must be a file URL.\");\n  }\n  let path = decodeURIComponent(\n    url.pathname.replace(/\\//g, \"\\\\\").replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"),\n  ).replace(/^\\\\*([A-Za-z]:)(\\\\|$)/, \"$1\\\\\");\n  if (url.hostname != \"\") {\n    // Note: The `URL` implementation guarantees that the drive letter and\n    // hostname are mutually exclusive. Otherwise it would not have been valid\n    // to append the hostname and path like this.\n    path = `\\\\\\\\${url.hostname}${path}`;\n  }\n  return path;\n}\n\n/**\n * Converts a path string to a file URL.\n *\n * ```ts\n *      import { toFileUrl } from \"https://deno.land/std@$STD_VERSION/path/win32.ts\";\n *      toFileUrl(\"\\\\home\\\\foo\"); // new URL(\"file:///home/foo\")\n *      toFileUrl(\"C:\\\\Users\\\\foo\"); // new URL(\"file:///C:/Users/foo\")\n *      toFileUrl(\"\\\\\\\\127.0.0.1\\\\home\\\\foo\"); // new URL(\"file://127.0.0.1/home/foo\")\n * ```\n * @param path to convert to file URL\n */\nexport function toFileUrl(path: string): URL {\n  if (!isAbsolute(path)) {\n    throw new TypeError(\"Must be an absolute path.\");\n  }\n  const [, hostname, pathname] = path.match(\n    /^(?:[/\\\\]{2}([^/\\\\]+)(?=[/\\\\](?:[^/\\\\]|$)))?(.*)/,\n  )!;\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(pathname.replace(/%/g, \"%25\"));\n  if (hostname != null && hostname != \"localhost\") {\n    url.hostname = hostname;\n    if (!url.hostname) {\n      throw new TypeError(\"Invalid hostname.\");\n    }\n  }\n  return url;\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject } from \"./_interface.ts\";\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_UPPERCASE_A,\n  CHAR_UPPERCASE_Z,\n} from \"./_constants.ts\";\n\nexport function assertPath(path: string) {\n  if (typeof path !== \"string\") {\n    throw new TypeError(\n      `Path must be a string. Received ${JSON.stringify(path)}`,\n    );\n  }\n}\n\nexport function isPosixPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nexport function isPathSeparator(code: number): boolean {\n  return isPosixPathSeparator(code) || code === CHAR_BACKWARD_SLASH;\n}\n\nexport function isWindowsDeviceRoot(code: number): boolean {\n  return (\n    (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z)\n  );\n}\n\n// Resolves . and .. elements in a path with directory names\nexport function normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code: number) => boolean,\n): string {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code: number | undefined;\n  for (let i = 0, len = path.length; i <= len; ++i) {\n    if (i < len) code = path.charCodeAt(i);\n    else if (isPathSeparator(code!)) break;\n    else code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code!)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += `${separator}..`;\n          else res = \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nexport function _format(\n  sep: string,\n  pathObject: FormatInputPathObject,\n): string {\n  const dir: string | undefined = pathObject.dir || pathObject.root;\n  const base: string = pathObject.base ||\n    (pathObject.name || \"\") + (pathObject.ext || \"\");\n  if (!dir) return base;\n  if (base === sep) return dir;\n  if (dir === pathObject.root) return dir + base;\n  return dir + sep + base;\n}\n\nconst WHITESPACE_ENCODINGS: Record<string, string> = {\n  \"\\u0009\": \"%09\",\n  \"\\u000A\": \"%0A\",\n  \"\\u000B\": \"%0B\",\n  \"\\u000C\": \"%0C\",\n  \"\\u000D\": \"%0D\",\n  \"\\u0020\": \"%20\",\n};\n\nexport function encodeWhitespace(string: string): string {\n  return string.replaceAll(/[\\s]/g, (c) => {\n    return WHITESPACE_ENCODINGS[c] ?? c;\n  });\n}\n\nexport function lastPathSegment(\n  path: string,\n  isSep: (char: number) => boolean,\n  start = 0,\n): string {\n  let matchedNonSeparator = false;\n  let end = path.length;\n\n  for (let i = path.length - 1; i >= start; --i) {\n    if (isSep(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        start = i + 1;\n        break;\n      }\n    } else if (!matchedNonSeparator) {\n      matchedNonSeparator = true;\n      end = i + 1;\n    }\n  }\n\n  return path.slice(start, end);\n}\n\nexport function stripTrailingSeparators(\n  segment: string,\n  isSep: (char: number) => boolean,\n): string {\n  if (segment.length <= 1) {\n    return segment;\n  }\n\n  let end = segment.length;\n\n  for (let i = segment.length - 1; i > 0; i--) {\n    if (isSep(segment.charCodeAt(i))) {\n      end = i;\n    } else {\n      break;\n    }\n  }\n\n  return segment.slice(0, end);\n}\n\nexport function stripSuffix(name: string, suffix: string): string {\n  if (suffix.length >= name.length) {\n    return name;\n  }\n\n  const lenDiff = name.length - suffix.length;\n\n  for (let i = suffix.length - 1; i >= 0; --i) {\n    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {\n      return name;\n    }\n  }\n\n  return name.slice(0, -suffix.length);\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * All internal non-test code, that is files that do not have `test` or `bench` in the name, must use the assertion functions within `_utils/asserts.ts` and not `testing/asserts.ts`. This is to create a separation of concerns between internal and testing assertions.\n */\n\nexport class DenoStdInternalError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"DenoStdInternalError\";\n  }\n}\n\n/** Make an assertion, if not `true`, then throw. */\nexport function assert(expr: unknown, msg = \"\"): asserts expr {\n  if (!expr) {\n    throw new DenoStdInternalError(msg);\n  }\n}\n\n/** Use this to assert unreachable code. */\nexport function unreachable(): never {\n  throw new DenoStdInternalError(\"unreachable\");\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject, ParsedPath } from \"./_interface.ts\";\nimport { CHAR_DOT } from \"./_constants.ts\";\n\nimport {\n  _format,\n  assertPath,\n  encodeWhitespace,\n  isPosixPathSeparator,\n  lastPathSegment,\n  normalizeString,\n  stripSuffix,\n  stripTrailingSeparators,\n} from \"./_util.ts\";\n\nexport const sep = \"/\";\nexport const delimiter = \":\";\n\n// path.resolve([from ...], to)\n/**\n * Resolves `pathSegments` into an absolute path.\n * @param pathSegments an array of path segments\n */\nexport function resolve(...pathSegments: string[]): string {\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n\n  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    let path: string;\n\n    if (i >= 0) path = pathSegments[i];\n    else {\n      // deno-lint-ignore no-explicit-any\n      const { Deno } = globalThis as any;\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a relative path without a CWD.\");\n      }\n      path = Deno.cwd();\n    }\n\n    assertPath(path);\n\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeString(\n    resolvedPath,\n    !resolvedAbsolute,\n    \"/\",\n    isPosixPathSeparator,\n  );\n\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0) return `/${resolvedPath}`;\n    else return \"/\";\n  } else if (resolvedPath.length > 0) return resolvedPath;\n  else return \".\";\n}\n\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n * @param path to be normalized\n */\nexport function normalize(path: string): string {\n  assertPath(path);\n\n  if (path.length === 0) return \".\";\n\n  const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  const trailingSeparator = isPosixPathSeparator(\n    path.charCodeAt(path.length - 1),\n  );\n\n  // Normalize the path\n  path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n\n  if (path.length === 0 && !isAbsolute) path = \".\";\n  if (path.length > 0 && trailingSeparator) path += \"/\";\n\n  if (isAbsolute) return `/${path}`;\n  return path;\n}\n\n/**\n * Verifies whether provided path is absolute\n * @param path to be verified as absolute\n */\nexport function isAbsolute(path: string): boolean {\n  assertPath(path);\n  return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));\n}\n\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n * @param paths to be joined and normalized\n */\nexport function join(...paths: string[]): string {\n  if (paths.length === 0) return \".\";\n  let joined: string | undefined;\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n    assertPath(path);\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `/${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalize(joined);\n}\n\n/**\n * Return the relative path from `from` to `to` based on current working directory.\n * @param from path in current working directory\n * @param to path in current working directory\n */\nexport function relative(from: string, to: string): string {\n  assertPath(from);\n  assertPath(to);\n\n  if (from === to) return \"\";\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return \"\";\n\n  // Trim any leading backslashes\n  let fromStart = 1;\n  const fromEnd = from.length;\n  for (; fromStart < fromEnd; ++fromStart) {\n    if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;\n  }\n  const fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  let toStart = 1;\n  const toEnd = to.length;\n  for (; toStart < toEnd; ++toStart) {\n    if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;\n  }\n  const toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        } else if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;\n  }\n\n  let out = \"\";\n  // Generate the relative path based on the path difference between `to`\n  // and `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {\n      if (out.length === 0) out += \"..\";\n      else out += \"/..\";\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\n  else {\n    toStart += lastCommonSep;\n    if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;\n    return to.slice(toStart);\n  }\n}\n\n/**\n * Resolves path to a namespace path\n * @param path to resolve to namespace\n */\nexport function toNamespacedPath(path: string): string {\n  // Non-op on posix systems\n  return path;\n}\n\n/**\n * Return the directory path of a `path`.\n * @param path - path to extract the directory from.\n */\nexport function dirname(path: string): string {\n  if (path.length === 0) return \".\";\n\n  let end = -1;\n  let matchedNonSeparator = false;\n\n  for (let i = path.length - 1; i >= 1; --i) {\n    if (isPosixPathSeparator(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        end = i;\n        break;\n      }\n    } else {\n      matchedNonSeparator = true;\n    }\n  }\n\n  // No matches. Fallback based on provided path:\n  //\n  // - leading slashes paths\n  //     \"/foo\" => \"/\"\n  //     \"///foo\" => \"/\"\n  // - no slash path\n  //     \"foo\" => \".\"\n  if (end === -1) {\n    return isPosixPathSeparator(path.charCodeAt(0)) ? \"/\" : \".\";\n  }\n\n  return stripTrailingSeparators(\n    path.slice(0, end),\n    isPosixPathSeparator,\n  );\n}\n\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @param path - path to extract the name from.\n * @param [suffix] - suffix to remove from extracted name.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  assertPath(path);\n\n  if (path.length === 0) return path;\n\n  if (typeof suffix !== \"string\") {\n    throw new TypeError(\n      `Suffix must be a string. Received ${JSON.stringify(suffix)}`,\n    );\n  }\n\n  const lastSegment = lastPathSegment(path, isPosixPathSeparator);\n  const strippedSegment = stripTrailingSeparators(\n    lastSegment,\n    isPosixPathSeparator,\n  );\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n\n/**\n * Return the extension of the `path` with leading period.\n * @param path with extension\n * @returns extension (ex. for `file.ts` returns `.ts`)\n */\nexport function extname(path: string): string {\n  assertPath(path);\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  for (let i = path.length - 1; i >= 0; --i) {\n    const code = path.charCodeAt(i);\n    if (isPosixPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n\n/**\n * Generate a path from `FormatInputPathObject` object.\n * @param pathObject with path\n */\nexport function format(pathObject: FormatInputPathObject): string {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(\n      `The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`,\n    );\n  }\n  return _format(\"/\", pathObject);\n}\n\n/**\n * Return a `ParsedPath` object of the `path`.\n * @param path to process\n */\nexport function parse(path: string): ParsedPath {\n  assertPath(path);\n\n  const ret: ParsedPath = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n  if (path.length === 0) return ret;\n  const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  let start: number;\n  if (isAbsolute) {\n    ret.root = \"/\";\n    start = 1;\n  } else {\n    start = 0;\n  }\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= start; --i) {\n    const code = path.charCodeAt(i);\n    if (isPosixPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    if (end !== -1) {\n      if (startPart === 0 && isAbsolute) {\n        ret.base = ret.name = path.slice(1, end);\n      } else {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    }\n    // Fallback to '/' in case there is no basename\n    ret.base = ret.base || \"/\";\n  } else {\n    if (startPart === 0 && isAbsolute) {\n      ret.name = path.slice(1, startDot);\n      ret.base = path.slice(1, end);\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n    }\n    ret.ext = path.slice(startDot, end);\n  }\n\n  if (startPart > 0) {\n    ret.dir = stripTrailingSeparators(\n      path.slice(0, startPart - 1),\n      isPosixPathSeparator,\n    );\n  } else if (isAbsolute) ret.dir = \"/\";\n\n  return ret;\n}\n\n/**\n * Converts a file URL to a path string.\n *\n * ```ts\n *      import { fromFileUrl } from \"https://deno.land/std@$STD_VERSION/path/posix.ts\";\n *      fromFileUrl(\"file:///home/foo\"); // \"/home/foo\"\n * ```\n * @param url of a file URL\n */\nexport function fromFileUrl(url: string | URL): string {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol != \"file:\") {\n    throw new TypeError(\"Must be a file URL.\");\n  }\n  return decodeURIComponent(\n    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"),\n  );\n}\n\n/**\n * Converts a path string to a file URL.\n *\n * ```ts\n *      import { toFileUrl } from \"https://deno.land/std@$STD_VERSION/path/posix.ts\";\n *      toFileUrl(\"/home/foo\"); // new URL(\"file:///home/foo\")\n * ```\n * @param path to convert to file URL\n */\nexport function toFileUrl(path: string): URL {\n  if (!isAbsolute(path)) {\n    throw new TypeError(\"Must be an absolute path.\");\n  }\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(\n    path.replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"),\n  );\n  return url;\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"../_util/os.ts\";\n\nexport const SEP = isWindows ? \"\\\\\" : \"/\";\nexport const SEP_PATTERN = isWindows ? /[\\\\/]+/ : /\\/+/;\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows, osType } from \"../_util/os.ts\";\nimport { SEP, SEP_PATTERN } from \"./separator.ts\";\nimport * as _win32 from \"./win32.ts\";\nimport * as _posix from \"./posix.ts\";\nimport type { OSType } from \"../_util/os.ts\";\n\nconst path = isWindows ? _win32 : _posix;\nconst { join, normalize } = path;\n\nexport interface GlobOptions {\n  /** Extended glob syntax.\n   * See https://www.linuxjournal.com/content/bash-extended-globbing.\n   *\n   * @default {true}\n   */\n  extended?: boolean;\n  /** Globstar syntax.\n   * See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n   * If false, `**` is treated like `*`.\n   *\n   * @default {true}\n   */\n  globstar?: boolean;\n  /** Whether globstar should be case-insensitive. */\n  caseInsensitive?: boolean;\n  /** Operating system. Defaults to the native OS. */\n  os?: OSType;\n}\n\nexport type GlobToRegExpOptions = GlobOptions;\n\nconst regExpEscapeChars = [\n  \"!\",\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"=\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"^\",\n  \"{\",\n  \"|\",\n];\nconst rangeEscapeChars = [\"-\", \"\\\\\", \"]\"];\n\n/** Convert a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment. */\nexport function globToRegExp(\n  glob: string,\n  {\n    extended = true,\n    globstar: globstarOption = true,\n    os = osType,\n    caseInsensitive = false,\n  }: GlobToRegExpOptions = {},\n): RegExp {\n  if (glob == \"\") {\n    return /(?!)/;\n  }\n\n  const sep = os == \"windows\" ? \"(?:\\\\\\\\|/)+\" : \"/+\";\n  const sepMaybe = os == \"windows\" ? \"(?:\\\\\\\\|/)*\" : \"/*\";\n  const seps = os == \"windows\" ? [\"\\\\\", \"/\"] : [\"/\"];\n  const globstar = os == \"windows\"\n    ? \"(?:[^\\\\\\\\/]*(?:\\\\\\\\|/|$)+)*\"\n    : \"(?:[^/]*(?:/|$)+)*\";\n  const wildcard = os == \"windows\" ? \"[^\\\\\\\\/]*\" : \"[^/]*\";\n  const escapePrefix = os == \"windows\" ? \"`\" : \"\\\\\";\n\n  // Remove trailing separators.\n  let newLength = glob.length;\n  for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);\n  glob = glob.slice(0, newLength);\n\n  let regExpString = \"\";\n\n  // Terminates correctly. Trust that `j` is incremented every iteration.\n  for (let j = 0; j < glob.length;) {\n    let segment = \"\";\n    const groupStack: string[] = [];\n    let inRange = false;\n    let inEscape = false;\n    let endsWithSep = false;\n    let i = j;\n\n    // Terminates with `i` at the non-inclusive end of the current segment.\n    for (; i < glob.length && !seps.includes(glob[i]); i++) {\n      if (inEscape) {\n        inEscape = false;\n        const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;\n        segment += escapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n        continue;\n      }\n\n      if (glob[i] == escapePrefix) {\n        inEscape = true;\n        continue;\n      }\n\n      if (glob[i] == \"[\") {\n        if (!inRange) {\n          inRange = true;\n          segment += \"[\";\n          if (glob[i + 1] == \"!\") {\n            i++;\n            segment += \"^\";\n          } else if (glob[i + 1] == \"^\") {\n            i++;\n            segment += \"\\\\^\";\n          }\n          continue;\n        } else if (glob[i + 1] == \":\") {\n          let k = i + 1;\n          let value = \"\";\n          while (glob[k + 1] != null && glob[k + 1] != \":\") {\n            value += glob[k + 1];\n            k++;\n          }\n          if (glob[k + 1] == \":\" && glob[k + 2] == \"]\") {\n            i = k + 2;\n            if (value == \"alnum\") segment += \"\\\\dA-Za-z\";\n            else if (value == \"alpha\") segment += \"A-Za-z\";\n            else if (value == \"ascii\") segment += \"\\x00-\\x7F\";\n            else if (value == \"blank\") segment += \"\\t \";\n            else if (value == \"cntrl\") segment += \"\\x00-\\x1F\\x7F\";\n            else if (value == \"digit\") segment += \"\\\\d\";\n            else if (value == \"graph\") segment += \"\\x21-\\x7E\";\n            else if (value == \"lower\") segment += \"a-z\";\n            else if (value == \"print\") segment += \"\\x20-\\x7E\";\n            else if (value == \"punct\") {\n              segment += \"!\\\"#$%&'()*+,\\\\-./:;<=>?@[\\\\\\\\\\\\]^_\u2018{|}~\";\n            } else if (value == \"space\") segment += \"\\\\s\\v\";\n            else if (value == \"upper\") segment += \"A-Z\";\n            else if (value == \"word\") segment += \"\\\\w\";\n            else if (value == \"xdigit\") segment += \"\\\\dA-Fa-f\";\n            continue;\n          }\n        }\n      }\n\n      if (glob[i] == \"]\" && inRange) {\n        inRange = false;\n        segment += \"]\";\n        continue;\n      }\n\n      if (inRange) {\n        if (glob[i] == \"\\\\\") {\n          segment += `\\\\\\\\`;\n        } else {\n          segment += glob[i];\n        }\n        continue;\n      }\n\n      if (\n        glob[i] == \")\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] != \"BRACE\"\n      ) {\n        segment += \")\";\n        const type = groupStack.pop()!;\n        if (type == \"!\") {\n          segment += wildcard;\n        } else if (type != \"@\") {\n          segment += type;\n        }\n        continue;\n      }\n\n      if (\n        glob[i] == \"|\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] != \"BRACE\"\n      ) {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] == \"+\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"+\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"@\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"@\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"?\") {\n        if (extended && glob[i + 1] == \"(\") {\n          i++;\n          groupStack.push(\"?\");\n          segment += \"(?:\";\n        } else {\n          segment += \".\";\n        }\n        continue;\n      }\n\n      if (glob[i] == \"!\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"!\");\n        segment += \"(?!\";\n        continue;\n      }\n\n      if (glob[i] == \"{\") {\n        groupStack.push(\"BRACE\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"}\" && groupStack[groupStack.length - 1] == \"BRACE\") {\n        groupStack.pop();\n        segment += \")\";\n        continue;\n      }\n\n      if (glob[i] == \",\" && groupStack[groupStack.length - 1] == \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] == \"*\") {\n        if (extended && glob[i + 1] == \"(\") {\n          i++;\n          groupStack.push(\"*\");\n          segment += \"(?:\";\n        } else {\n          const prevChar = glob[i - 1];\n          let numStars = 1;\n          while (glob[i + 1] == \"*\") {\n            i++;\n            numStars++;\n          }\n          const nextChar = glob[i + 1];\n          if (\n            globstarOption && numStars == 2 &&\n            [...seps, undefined].includes(prevChar) &&\n            [...seps, undefined].includes(nextChar)\n          ) {\n            segment += globstar;\n            endsWithSep = true;\n          } else {\n            segment += wildcard;\n          }\n        }\n        continue;\n      }\n\n      segment += regExpEscapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n    }\n\n    // Check for unclosed groups or a dangling backslash.\n    if (groupStack.length > 0 || inRange || inEscape) {\n      // Parse failure. Take all characters from this segment literally.\n      segment = \"\";\n      for (const c of glob.slice(j, i)) {\n        segment += regExpEscapeChars.includes(c) ? `\\\\${c}` : c;\n        endsWithSep = false;\n      }\n    }\n\n    regExpString += segment;\n    if (!endsWithSep) {\n      regExpString += i < glob.length ? sep : sepMaybe;\n      endsWithSep = true;\n    }\n\n    // Terminates with `i` at the start of the next segment.\n    while (seps.includes(glob[i])) i++;\n\n    // Check that the next value of `j` is indeed higher than the current value.\n    if (!(i > j)) {\n      throw new Error(\"Assertion failure: i > j (potential infinite loop)\");\n    }\n    j = i;\n  }\n\n  regExpString = `^${regExpString}$`;\n  return new RegExp(regExpString, caseInsensitive ? \"i\" : \"\");\n}\n\n/** Test whether the given string is a glob */\nexport function isGlob(str: string): boolean {\n  const chars: Record<string, string> = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\" };\n  const regex =\n    /\\\\(.)|(^!|\\*|\\?|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\n\n  if (str === \"\") {\n    return false;\n  }\n\n  let match: RegExpExecArray | null;\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    let idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    const open = match[1];\n    const close = open ? chars[open] : null;\n    if (open && close) {\n      const n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n\n  return false;\n}\n\n/** Like normalize(), but doesn't collapse \"**\\/..\" when `globstar` is true. */\nexport function normalizeGlob(\n  glob: string,\n  { globstar = false }: GlobOptions = {},\n): string {\n  if (glob.match(/\\0/g)) {\n    throw new Error(`Glob contains invalid characters: \"${glob}\"`);\n  }\n  if (!globstar) {\n    return normalize(glob);\n  }\n  const s = SEP_PATTERN.source;\n  const badParentPattern = new RegExp(\n    `(?<=(${s}|^)\\\\*\\\\*${s})\\\\.\\\\.(?=${s}|$)`,\n    \"g\",\n  );\n  return normalize(glob.replace(badParentPattern, \"\\0\")).replace(/\\0/g, \"..\");\n}\n\n/** Like join(), but doesn't collapse \"**\\/..\" when `globstar` is true. */\nexport function joinGlobs(\n  globs: string[],\n  { extended = true, globstar = false }: GlobOptions = {},\n): string {\n  if (!globstar || globs.length == 0) {\n    return join(...globs);\n  }\n  if (globs.length === 0) return \".\";\n  let joined: string | undefined;\n  for (const glob of globs) {\n    const path = glob;\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `${SEP}${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalizeGlob(joined, { extended, globstar });\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported mostly from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\n/**\n * Utilities for working with OS-specific file paths.\n *\n * Codes in the examples uses POSIX path but it automatically use Windows path\n * on Windows. Use methods under `posix` or `win32` object instead to handle non\n * platform specific path like:\n * ```ts\n * import { posix, win32 } from \"https://deno.land/std@$STD_VERSION/path/mod.ts\";\n * const p1 = posix.fromFileUrl(\"file:///home/foo\");\n * const p2 = win32.fromFileUrl(\"file:///home/foo\");\n * console.log(p1); // \"/home/foo\"\n * console.log(p2); // \"\\\\home\\\\foo\"\n * ```\n *\n * This module is browser compatible.\n *\n * @module\n */\n\nimport { isWindows } from \"../_util/os.ts\";\nimport * as _win32 from \"./win32.ts\";\nimport * as _posix from \"./posix.ts\";\n\nconst path = isWindows ? _win32 : _posix;\n\nexport const win32 = _win32;\nexport const posix = _posix;\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  fromFileUrl,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  relative,\n  resolve,\n  sep,\n  toFileUrl,\n  toNamespacedPath,\n} = path;\n\nexport * from \"./common.ts\";\nexport { SEP, SEP_PATTERN } from \"./separator.ts\";\nexport * from \"./_interface.ts\";\nexport * from \"./glob.ts\";\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\nimport * as path from \"../path/mod.ts\";\nimport { basename, normalize } from \"../path/mod.ts\";\n\n/**\n * Test whether `src` and `dest` resolve to the same location\n * @param src src file path\n * @param dest dest file path\n */\nexport function isSamePath(\n  src: string | URL,\n  dest: string | URL,\n): boolean | void {\n  src = toPathString(src);\n  dest = toPathString(dest);\n\n  return path.resolve(src) === path.resolve(dest);\n}\n\n/**\n * Test whether or not `dest` is a sub-directory of `src`\n * @param src src file path\n * @param dest dest file path\n * @param sep path separator\n */\nexport function isSubdir(\n  src: string | URL,\n  dest: string | URL,\n  sep: string = path.sep,\n): boolean {\n  if (src === dest) {\n    return false;\n  }\n  src = toPathString(src);\n  const srcArray = src.split(sep);\n  dest = toPathString(dest);\n  const destArray = dest.split(sep);\n  return srcArray.every((current, i) => destArray[i] === current);\n}\n\nexport type PathType = \"file\" | \"dir\" | \"symlink\";\n\n/**\n * Get a human readable file type string.\n *\n * @param fileInfo A FileInfo describes a file and is returned by `stat`,\n *                 `lstat`\n */\nexport function getFileInfoType(fileInfo: Deno.FileInfo): PathType | undefined {\n  return fileInfo.isFile\n    ? \"file\"\n    : fileInfo.isDirectory\n    ? \"dir\"\n    : fileInfo.isSymlink\n    ? \"symlink\"\n    : undefined;\n}\n\nexport interface WalkEntry extends Deno.DirEntry {\n  path: string;\n}\n\n/** Create WalkEntry for the `path` synchronously */\nexport function createWalkEntrySync(path: string | URL): WalkEntry {\n  path = toPathString(path);\n  path = normalize(path);\n  const name = basename(path);\n  const info = Deno.statSync(path);\n  return {\n    path,\n    name,\n    isFile: info.isFile,\n    isDirectory: info.isDirectory,\n    isSymlink: info.isSymlink,\n  };\n}\n\n/** Create WalkEntry for the `path` asynchronously */\nexport async function createWalkEntry(path: string | URL): Promise<WalkEntry> {\n  path = toPathString(path);\n  path = normalize(path);\n  const name = basename(path);\n  const info = await Deno.stat(path);\n  return {\n    path,\n    name,\n    isFile: info.isFile,\n    isDirectory: info.isDirectory,\n    isSymlink: info.isSymlink,\n  };\n}\n\n/**\n * Convert a URL or string to a path\n * @param pathUrl A URL or string to be converted\n */\nexport function toPathString(\n  pathUrl: string | URL,\n): string {\n  return pathUrl instanceof URL ? path.fromFileUrl(pathUrl) : pathUrl;\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n\nexport interface ExistsOptions {\n  /**\n   * When `true`, will check if the path is readable by the user as well.\n   * @default {false}\n   */\n  isReadable?: boolean;\n  /**\n   * When `true`, will check if the path is a directory as well.\n   * Directory symlinks are included.\n   * @default {false}\n   */\n  isDirectory?: boolean;\n  /**\n   * When `true`, will check if the path is a file as well.\n   * File symlinks are included.\n   * @default {false}\n   */\n  isFile?: boolean;\n}\n\n/**\n * Test whether or not the given path exists by checking with the file system. Please consider to check if the path is readable and either a file or a directory by providing additional `options`:\n *\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/mod.ts\";\n * const isReadableDir = await exists(\"./foo\", {\n *   isReadable: true,\n *   isDirectory: true\n * });\n * const isReadableFile = await exists(\"./bar\", {\n *   isReadable: true,\n *   isFile: true\n * });\n * ```\n *\n * Note: Do not use this function if performing a check before another operation on that file. Doing so creates a race condition. Instead, perform the actual file operation directly.\n *\n * Bad:\n * ```ts\n * import { exists } from \"https://deno.land/std@$STD_VERSION/fs/mod.ts\";\n *\n * if (await exists(\"./foo\")) {\n *   await Deno.remove(\"./foo\");\n * }\n * ```\n *\n * Good:\n * ```ts\n * // Notice no use of exists\n * try {\n *   await Deno.remove(\"./foo\", { recursive: true });\n * } catch (error) {\n *   if (!(error instanceof Deno.errors.NotFound)) {\n *     throw error;\n *   }\n *   // Do nothing...\n * }\n * ```\n * @see https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use\n */\nexport async function exists(\n  path: string | URL,\n  options?: ExistsOptions,\n): Promise<boolean> {\n  try {\n    const stat = await Deno.stat(path);\n    if (\n      options &&\n      (options.isReadable || options.isDirectory || options.isFile)\n    ) {\n      if (options.isDirectory && options.isFile) {\n        throw new TypeError(\n          \"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.\",\n        );\n      }\n      if (\n        (options.isDirectory && !stat.isDirectory) ||\n        (options.isFile && !stat.isFile)\n      ) {\n        return false;\n      }\n      if (options.isReadable) {\n        if (stat.mode == null) {\n          return true; // Exclusive on Non-POSIX systems\n        }\n        if (Deno.uid() == stat.uid) {\n          return (stat.mode & 0o400) == 0o400; // User is owner and can read?\n        } else if (Deno.gid() == stat.gid) {\n          return (stat.mode & 0o040) == 0o040; // User group is owner and can read?\n        }\n        return (stat.mode & 0o004) == 0o004; // Others can read?\n      }\n    }\n    return true;\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      return false;\n    }\n    if (error instanceof Deno.errors.PermissionDenied) {\n      if (\n        (await Deno.permissions.query({ name: \"read\", path })).state ===\n          \"granted\"\n      ) {\n        // --allow-read not missing\n        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read\n      }\n    }\n    throw error;\n  }\n}\n\n/**\n * Test whether or not the given path exists by checking with the file system. Please consider to check if the path is readable and either a file or a directory by providing additional `options`:\n *\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/mod.ts\";\n * const isReadableDir = existsSync(\"./foo\", {\n *   isReadable: true,\n *   isDirectory: true\n * });\n * const isReadableFile = existsSync(\"./bar\", {\n *   isReadable: true,\n *   isFile: true\n * });\n * ```\n *\n * Note: do not use this function if performing a check before another operation on that file. Doing so creates a race condition. Instead, perform the actual file operation directly.\n *\n * Bad:\n * ```ts\n * import { existsSync } from \"https://deno.land/std@$STD_VERSION/fs/mod.ts\";\n *\n * if (existsSync(\"./foo\")) {\n *   Deno.removeSync(\"./foo\");\n * }\n * ```\n *\n * Good:\n * ```ts\n * // Notice no use of existsSync\n * try {\n *   Deno.removeSync(\"./foo\", { recursive: true });\n * } catch (error) {\n *   if (!(error instanceof Deno.errors.NotFound)) {\n *     throw error;\n *   }\n *   // Do nothing...\n * }\n * ```\n * @see https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use\n */\nexport function existsSync(\n  path: string | URL,\n  options?: ExistsOptions,\n): boolean {\n  try {\n    const stat = Deno.statSync(path);\n    if (\n      options &&\n      (options.isReadable || options.isDirectory || options.isFile)\n    ) {\n      if (options.isDirectory && options.isFile) {\n        throw new TypeError(\n          \"ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.\",\n        );\n      }\n      if (\n        (options.isDirectory && !stat.isDirectory) ||\n        (options.isFile && !stat.isFile)\n      ) {\n        return false;\n      }\n      if (options.isReadable) {\n        if (stat.mode == null) {\n          return true; // Exclusive on Non-POSIX systems\n        }\n        if (Deno.uid() == stat.uid) {\n          return (stat.mode & 0o400) == 0o400; // User is owner and can read?\n        } else if (Deno.gid() == stat.gid) {\n          return (stat.mode & 0o040) == 0o040; // User group is owner and can read?\n        }\n        return (stat.mode & 0o004) == 0o004; // Others can read?\n      }\n    }\n    return true;\n  } catch (error) {\n    if (error instanceof Deno.errors.NotFound) {\n      return false;\n    }\n    if (error instanceof Deno.errors.PermissionDenied) {\n      if (\n        Deno.permissions.querySync({ name: \"read\", path }).state === \"granted\"\n      ) {\n        // --allow-read not missing\n        return !options?.isReadable; // PermissionDenied was raised by file system, so the item exists, but can't be read\n      }\n    }\n    throw error;\n  }\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// Documentation and interface for walk were adapted from Go\n// https://golang.org/pkg/path/filepath/#Walk\n// Copyright 2009 The Go Authors. All rights reserved. BSD license.\nimport { assert } from \"../_util/asserts.ts\";\nimport { join, normalize } from \"../path/mod.ts\";\nimport {\n  createWalkEntry,\n  createWalkEntrySync,\n  toPathString,\n  WalkEntry,\n} from \"./_util.ts\";\n\nexport class WalkError extends Error {\n  override cause: unknown;\n  override name = \"WalkError\";\n  path: string;\n\n  constructor(cause: unknown, path: string) {\n    super(\n      `${cause instanceof Error ? cause.message : cause} for path \"${path}\"`,\n    );\n    this.path = path;\n    this.cause = cause;\n  }\n}\n\nfunction include(\n  path: string,\n  exts?: string[],\n  match?: RegExp[],\n  skip?: RegExp[],\n): boolean {\n  if (exts && !exts.some((ext): boolean => path.endsWith(ext))) {\n    return false;\n  }\n  if (match && !match.some((pattern): boolean => !!path.match(pattern))) {\n    return false;\n  }\n  if (skip && skip.some((pattern): boolean => !!path.match(pattern))) {\n    return false;\n  }\n  return true;\n}\n\nfunction wrapErrorWithPath(err: unknown, root: string) {\n  if (err instanceof WalkError) return err;\n  return new WalkError(err, root);\n}\n\nexport interface WalkOptions {\n  /** @default {Infinity} */\n  maxDepth?: number;\n  /** @default {true} */\n  includeFiles?: boolean;\n  /** @default {true} */\n  includeDirs?: boolean;\n  /** @default {false} */\n  followSymlinks?: boolean;\n  exts?: string[];\n  match?: RegExp[];\n  skip?: RegExp[];\n}\nexport type { WalkEntry };\n\n/**\n * Walks the file tree rooted at root, yielding each file or directory in the\n * tree filtered according to the given options.\n *\n * @example\n * ```ts\n * import { walk } from \"https://deno.land/std@$STD_VERSION/fs/walk.ts\";\n * import { assert } from \"https://deno.land/std@$STD_VERSION/testing/asserts.ts\";\n *\n * for await (const entry of walk(\".\")) {\n *   console.log(entry.path);\n *   assert(entry.isFile);\n * }\n * ```\n */\nexport async function* walk(\n  root: string | URL,\n  {\n    maxDepth = Infinity,\n    includeFiles = true,\n    includeDirs = true,\n    followSymlinks = false,\n    exts = undefined,\n    match = undefined,\n    skip = undefined,\n  }: WalkOptions = {},\n): AsyncIterableIterator<WalkEntry> {\n  if (maxDepth < 0) {\n    return;\n  }\n  root = toPathString(root);\n  if (includeDirs && include(root, exts, match, skip)) {\n    yield await createWalkEntry(root);\n  }\n  if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {\n    return;\n  }\n  try {\n    for await (const entry of Deno.readDir(root)) {\n      assert(entry.name != null);\n      let path = join(root, entry.name);\n\n      let { isSymlink, isDirectory } = entry;\n\n      if (isSymlink) {\n        if (!followSymlinks) continue;\n        path = await Deno.realPath(path);\n        // Caveat emptor: don't assume |path| is not a symlink. realpath()\n        // resolves symlinks but another process can replace the file system\n        // entity with a different type of entity before we call lstat().\n        ({ isSymlink, isDirectory } = await Deno.lstat(path));\n      }\n\n      if (isSymlink || isDirectory) {\n        yield* walk(path, {\n          maxDepth: maxDepth - 1,\n          includeFiles,\n          includeDirs,\n          followSymlinks,\n          exts,\n          match,\n          skip,\n        });\n      } else if (includeFiles && include(path, exts, match, skip)) {\n        yield { path, ...entry };\n      }\n    }\n  } catch (err) {\n    throw wrapErrorWithPath(err, normalize(root));\n  }\n}\n\n/** Same as walk() but uses synchronous ops */\nexport function* walkSync(\n  root: string | URL,\n  {\n    maxDepth = Infinity,\n    includeFiles = true,\n    includeDirs = true,\n    followSymlinks = false,\n    exts = undefined,\n    match = undefined,\n    skip = undefined,\n  }: WalkOptions = {},\n): IterableIterator<WalkEntry> {\n  root = toPathString(root);\n  if (maxDepth < 0) {\n    return;\n  }\n  if (includeDirs && include(root, exts, match, skip)) {\n    yield createWalkEntrySync(root);\n  }\n  if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {\n    return;\n  }\n  let entries;\n  try {\n    entries = Deno.readDirSync(root);\n  } catch (err) {\n    throw wrapErrorWithPath(err, normalize(root));\n  }\n  for (const entry of entries) {\n    assert(entry.name != null);\n    let path = join(root, entry.name);\n\n    let { isSymlink, isDirectory } = entry;\n\n    if (isSymlink) {\n      if (!followSymlinks) continue;\n      path = Deno.realPathSync(path);\n      // Caveat emptor: don't assume |path| is not a symlink. realpath()\n      // resolves symlinks but another process can replace the file system\n      // entity with a different type of entity before we call lstat().\n      ({ isSymlink, isDirectory } = Deno.lstatSync(path));\n    }\n\n    if (isSymlink || isDirectory) {\n      yield* walkSync(path, {\n        maxDepth: maxDepth - 1,\n        includeFiles,\n        includeDirs,\n        followSymlinks,\n        exts,\n        match,\n        skip,\n      });\n    } else if (includeFiles && include(path, exts, match, skip)) {\n      yield { path, ...entry };\n    }\n  }\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\nimport {\n  GlobOptions,\n  globToRegExp,\n  isAbsolute,\n  isGlob,\n  joinGlobs,\n  resolve,\n  SEP_PATTERN,\n} from \"../path/mod.ts\";\nimport { walk, walkSync } from \"./walk.ts\";\nimport { assert } from \"../_util/asserts.ts\";\nimport { isWindows } from \"../_util/os.ts\";\nimport {\n  createWalkEntry,\n  createWalkEntrySync,\n  toPathString,\n  WalkEntry,\n} from \"./_util.ts\";\n\nexport interface ExpandGlobOptions extends Omit<GlobOptions, \"os\"> {\n  root?: string;\n  exclude?: string[];\n  includeDirs?: boolean;\n  followSymlinks?: boolean;\n}\n\ninterface SplitPath {\n  segments: string[];\n  isAbsolute: boolean;\n  hasTrailingSep: boolean;\n  // Defined for any absolute Windows path.\n  winRoot?: string;\n}\n\nfunction split(path: string): SplitPath {\n  const s = SEP_PATTERN.source;\n  const segments = path\n    .replace(new RegExp(`^${s}|${s}$`, \"g\"), \"\")\n    .split(SEP_PATTERN);\n  const isAbsolute_ = isAbsolute(path);\n  return {\n    segments,\n    isAbsolute: isAbsolute_,\n    hasTrailingSep: !!path.match(new RegExp(`${s}$`)),\n    winRoot: isWindows && isAbsolute_ ? segments.shift() : undefined,\n  };\n}\n\nfunction throwUnlessNotFound(error: unknown) {\n  if (!(error instanceof Deno.errors.NotFound)) {\n    throw error;\n  }\n}\n\nfunction comparePath(a: WalkEntry, b: WalkEntry): number {\n  if (a.path < b.path) return -1;\n  if (a.path > b.path) return 1;\n  return 0;\n}\n\n/**\n * Expand the glob string from the specified `root` directory and yield each\n * result as a `WalkEntry` object.\n *\n * See [`globToRegExp()`](../path/glob.ts#globToRegExp) for details on supported\n * syntax.\n *\n * @example\n * ```ts\n * import { expandGlob } from \"https://deno.land/std@$STD_VERSION/fs/expand_glob.ts\";\n * for await (const file of expandGlob(\"**\\/*.ts\")) {\n *   console.log(file);\n * }\n * ```\n */\nexport async function* expandGlob(\n  glob: string | URL,\n  {\n    root = Deno.cwd(),\n    exclude = [],\n    includeDirs = true,\n    extended = true,\n    globstar = true,\n    caseInsensitive,\n    followSymlinks,\n  }: ExpandGlobOptions = {},\n): AsyncIterableIterator<WalkEntry> {\n  const globOptions: GlobOptions = { extended, globstar, caseInsensitive };\n  const absRoot = resolve(root);\n  const resolveFromRoot = (path: string): string => resolve(absRoot, path);\n  const excludePatterns = exclude\n    .map(resolveFromRoot)\n    .map((s: string): RegExp => globToRegExp(s, globOptions));\n  const shouldInclude = (path: string): boolean =>\n    !excludePatterns.some((p: RegExp): boolean => !!path.match(p));\n  const {\n    segments,\n    isAbsolute: isGlobAbsolute,\n    hasTrailingSep,\n    winRoot,\n  } = split(toPathString(glob));\n\n  let fixedRoot = isGlobAbsolute\n    ? winRoot != undefined ? winRoot : \"/\"\n    : absRoot;\n  while (segments.length > 0 && !isGlob(segments[0])) {\n    const seg = segments.shift();\n    assert(seg != null);\n    fixedRoot = joinGlobs([fixedRoot, seg], globOptions);\n  }\n\n  let fixedRootInfo: WalkEntry;\n  try {\n    fixedRootInfo = await createWalkEntry(fixedRoot);\n  } catch (error) {\n    return throwUnlessNotFound(error);\n  }\n\n  async function* advanceMatch(\n    walkInfo: WalkEntry,\n    globSegment: string,\n  ): AsyncIterableIterator<WalkEntry> {\n    if (!walkInfo.isDirectory) {\n      return;\n    } else if (globSegment == \"..\") {\n      const parentPath = joinGlobs([walkInfo.path, \"..\"], globOptions);\n      try {\n        if (shouldInclude(parentPath)) {\n          return yield await createWalkEntry(parentPath);\n        }\n      } catch (error) {\n        throwUnlessNotFound(error);\n      }\n      return;\n    } else if (globSegment == \"**\") {\n      return yield* walk(walkInfo.path, {\n        skip: excludePatterns,\n        maxDepth: globstar ? Infinity : 1,\n        followSymlinks,\n      });\n    }\n    const globPattern = globToRegExp(globSegment, globOptions);\n    for await (\n      const walkEntry of walk(walkInfo.path, {\n        maxDepth: 1,\n        skip: excludePatterns,\n        followSymlinks,\n      })\n    ) {\n      if (\n        walkEntry.path != walkInfo.path &&\n        walkEntry.name.match(globPattern)\n      ) {\n        yield walkEntry;\n      }\n    }\n  }\n\n  let currentMatches: WalkEntry[] = [fixedRootInfo];\n  for (const segment of segments) {\n    // Advancing the list of current matches may introduce duplicates, so we\n    // pass everything through this Map.\n    const nextMatchMap: Map<string, WalkEntry> = new Map();\n    await Promise.all(\n      currentMatches.map(async (currentMatch) => {\n        for await (const nextMatch of advanceMatch(currentMatch, segment)) {\n          nextMatchMap.set(nextMatch.path, nextMatch);\n        }\n      }),\n    );\n    currentMatches = [...nextMatchMap.values()].sort(comparePath);\n  }\n\n  if (hasTrailingSep) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => entry.isDirectory,\n    );\n  }\n  if (!includeDirs) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => !entry.isDirectory,\n    );\n  }\n  yield* currentMatches;\n}\n\n/**\n * Synchronous version of `expandGlob()`.\n *\n * @example\n * ```ts\n * import { expandGlobSync } from \"https://deno.land/std@$STD_VERSION/fs/expand_glob.ts\";\n * for (const file of expandGlobSync(\"**\\/*.ts\")) {\n *   console.log(file);\n * }\n * ```\n */\nexport function* expandGlobSync(\n  glob: string | URL,\n  {\n    root = Deno.cwd(),\n    exclude = [],\n    includeDirs = true,\n    extended = true,\n    globstar = true,\n    caseInsensitive,\n    followSymlinks,\n  }: ExpandGlobOptions = {},\n): IterableIterator<WalkEntry> {\n  const globOptions: GlobOptions = { extended, globstar, caseInsensitive };\n  const absRoot = resolve(root);\n  const resolveFromRoot = (path: string): string => resolve(absRoot, path);\n  const excludePatterns = exclude\n    .map(resolveFromRoot)\n    .map((s: string): RegExp => globToRegExp(s, globOptions));\n  const shouldInclude = (path: string): boolean =>\n    !excludePatterns.some((p: RegExp): boolean => !!path.match(p));\n  const {\n    segments,\n    isAbsolute: isGlobAbsolute,\n    hasTrailingSep,\n    winRoot,\n  } = split(toPathString(glob));\n\n  let fixedRoot = isGlobAbsolute\n    ? winRoot != undefined ? winRoot : \"/\"\n    : absRoot;\n  while (segments.length > 0 && !isGlob(segments[0])) {\n    const seg = segments.shift();\n    assert(seg != null);\n    fixedRoot = joinGlobs([fixedRoot, seg], globOptions);\n  }\n\n  let fixedRootInfo: WalkEntry;\n  try {\n    fixedRootInfo = createWalkEntrySync(fixedRoot);\n  } catch (error) {\n    return throwUnlessNotFound(error);\n  }\n\n  function* advanceMatch(\n    walkInfo: WalkEntry,\n    globSegment: string,\n  ): IterableIterator<WalkEntry> {\n    if (!walkInfo.isDirectory) {\n      return;\n    } else if (globSegment == \"..\") {\n      const parentPath = joinGlobs([walkInfo.path, \"..\"], globOptions);\n      try {\n        if (shouldInclude(parentPath)) {\n          return yield createWalkEntrySync(parentPath);\n        }\n      } catch (error) {\n        throwUnlessNotFound(error);\n      }\n      return;\n    } else if (globSegment == \"**\") {\n      return yield* walkSync(walkInfo.path, {\n        skip: excludePatterns,\n        maxDepth: globstar ? Infinity : 1,\n        followSymlinks,\n      });\n    }\n    const globPattern = globToRegExp(globSegment, globOptions);\n    for (\n      const walkEntry of walkSync(walkInfo.path, {\n        maxDepth: 1,\n        skip: excludePatterns,\n        followSymlinks,\n      })\n    ) {\n      if (\n        walkEntry.path != walkInfo.path &&\n        walkEntry.name.match(globPattern)\n      ) {\n        yield walkEntry;\n      }\n    }\n  }\n\n  let currentMatches: WalkEntry[] = [fixedRootInfo];\n  for (const segment of segments) {\n    // Advancing the list of current matches may introduce duplicates, so we\n    // pass everything through this Map.\n    const nextMatchMap: Map<string, WalkEntry> = new Map();\n    for (const currentMatch of currentMatches) {\n      for (const nextMatch of advanceMatch(currentMatch, segment)) {\n        nextMatchMap.set(nextMatch.path, nextMatch);\n      }\n    }\n    currentMatches = [...nextMatchMap.values()].sort(comparePath);\n  }\n\n  if (hasTrailingSep) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => entry.isDirectory,\n    );\n  }\n  if (!includeDirs) {\n    currentMatches = currentMatches.filter(\n      (entry: WalkEntry): boolean => !entry.isDirectory,\n    );\n  }\n  yield* currentMatches;\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\nimport { isSamePath, isSubdir } from \"./_util.ts\";\n\nconst EXISTS_ERROR = new Deno.errors.AlreadyExists(\"dest already exists.\");\n\nexport class SubdirectoryMoveError extends Error {\n  constructor(src: string | URL, dest: string | URL) {\n    super(\n      `Cannot move '${src}' to a subdirectory of itself, '${dest}'.`,\n    );\n  }\n}\n\ninterface MoveOptions {\n  overwrite?: boolean;\n}\n\n/**\n * Moves a file or directory.\n *\n * @example\n * ```ts\n * import { move } from \"https://deno.land/std@$STD_VERSION/fs/mod.ts\";\n *\n * move(\"./foo\", \"./bar\"); // returns a promise\n * ```\n */\nexport async function move(\n  src: string | URL,\n  dest: string | URL,\n  { overwrite = false }: MoveOptions = {},\n) {\n  const srcStat = await Deno.stat(src);\n\n  if (\n    srcStat.isDirectory &&\n    (isSubdir(src, dest) || isSamePath(src, dest))\n  ) {\n    throw new SubdirectoryMoveError(src, dest);\n  }\n\n  if (overwrite) {\n    if (isSamePath(src, dest)) return;\n    try {\n      await Deno.remove(dest, { recursive: true });\n    } catch (error) {\n      if (!(error instanceof Deno.errors.NotFound)) {\n        throw error;\n      }\n    }\n  } else {\n    try {\n      await Deno.lstat(dest);\n      return Promise.reject(EXISTS_ERROR);\n    } catch {\n      // Do nothing...\n    }\n  }\n\n  await Deno.rename(src, dest);\n}\n\n/**\n * Moves a file or directory synchronously.\n * @example\n * ```ts\n * import { moveSync } from \"https://deno.land/std@$STD_VERSION/fs/mod.ts\";\n *\n * moveSync(\"./foo\", \"./bar\"); // void\n * ```\n */\nexport function moveSync(\n  src: string | URL,\n  dest: string | URL,\n  { overwrite = false }: MoveOptions = {},\n) {\n  const srcStat = Deno.statSync(src);\n\n  if (\n    srcStat.isDirectory &&\n    (isSubdir(src, dest) || isSamePath(src, dest))\n  ) {\n    throw new SubdirectoryMoveError(src, dest);\n  }\n\n  if (overwrite) {\n    if (isSamePath(src, dest)) return;\n    try {\n      Deno.removeSync(dest, { recursive: true });\n    } catch (error) {\n      if (!(error instanceof Deno.errors.NotFound)) {\n        throw error;\n      }\n    }\n  } else {\n    try {\n      Deno.lstatSync(dest);\n      throw EXISTS_ERROR;\n    } catch (error) {\n      if (error === EXISTS_ERROR) {\n        throw error;\n      }\n    }\n  }\n\n  Deno.renameSync(src, dest);\n}\n", "import { encodeBase64 } from \"./deps.ts\";\n\n/** Escape sequence: `\\x1B` */\nconst ESC = \"\\x1B\";\n/** Control sequence intro: `\\x1B[` */\nconst CSI = `${ESC}[`;\n/** Operating system command: `\\x1B]` */\nconst OSC = `${ESC}]`;\n/** Link separator */\nconst SEP = \";\";\n\n/** Ring audio bell: `\\u0007` */\nexport const bel = \"\\u0007\";\n/** Get cursor position. */\nexport const cursorPosition = `${CSI}6n`;\n\n/**\n * Move cursor to x, y, counting from the top left corner.\n * @param x Position left.\n * @param y Position top.\n */\nexport function cursorTo(x: number, y?: number): string {\n  if (typeof y !== \"number\") {\n    return `${CSI}${x}G`;\n  }\n  return `${CSI}${y};${x}H`;\n}\n\n/**\n * Move cursor by offset.\n * @param x Offset left.\n * @param y Offset top.\n */\nexport function cursorMove(x: number, y: number): string {\n  let ret = \"\";\n\n  if (x < 0) {\n    ret += `${CSI}${-x}D`;\n  } else if (x > 0) {\n    ret += `${CSI}${x}C`;\n  }\n\n  if (y < 0) {\n    ret += `${CSI}${-y}A`;\n  } else if (y > 0) {\n    ret += `${CSI}${y}B`;\n  }\n\n  return ret;\n}\n\n/**\n * Move cursor up by n lines.\n * @param count Number of lines.\n */\nexport function cursorUp(count = 1): string {\n  return `${CSI}${count}A`;\n}\n\n/**\n * Move cursor down by n lines.\n * @param count Number of lines.\n */\nexport function cursorDown(count = 1): string {\n  return `${CSI}${count}B`;\n}\n\n/**\n * Move cursor forward by n lines.\n * @param count Number of lines.\n */\nexport function cursorForward(count = 1): string {\n  return `${CSI}${count}C`;\n}\n\n/**\n * Move cursor backward by n lines.\n * @param count Number of lines.\n */\nexport function cursorBackward(count = 1): string {\n  return `${CSI}${count}D`;\n}\n\n/**\n * Move cursor to the beginning of the line n lines down.\n * @param count Number of lines.\n */\nexport function cursorNextLine(count = 1): string {\n  return `${CSI}E`.repeat(count);\n}\n\n/**\n * Move cursor to the beginning of the line n lines up.\n * @param count Number of lines.\n */\nexport function cursorPrevLine(count = 1): string {\n  return `${CSI}F`.repeat(count);\n}\n\n/** Move cursor to first column of current row. */\nexport const cursorLeft = `${CSI}G`;\n/** Hide cursor. */\nexport const cursorHide = `${CSI}?25l`;\n/** Show cursor. */\nexport const cursorShow = `${CSI}?25h`;\n/** Save cursor. */\nexport const cursorSave = `${ESC}7`;\n/** Restore cursor. */\nexport const cursorRestore = `${ESC}8`;\n\n/**\n * Scroll window up by n lines.\n * @param count Number of lines.\n */\nexport function scrollUp(count = 1): string {\n  return `${CSI}S`.repeat(count);\n}\n\n/**\n * Scroll window down by n lines.\n * @param count Number of lines.\n */\nexport function scrollDown(count = 1): string {\n  return `${CSI}T`.repeat(count);\n}\n\n/** Clear screen. */\nexport const eraseScreen = `${CSI}2J`;\n\n/**\n * Clear screen up by n lines.\n * @param count Number of lines.\n */\nexport function eraseUp(count = 1): string {\n  return `${CSI}1J`.repeat(count);\n}\n\n/**\n * Clear screen down by n lines.\n * @param count Number of lines.\n */\nexport function eraseDown(count = 1): string {\n  return `${CSI}0J`.repeat(count);\n}\n\n/** Clear current line. */\nexport const eraseLine = `${CSI}2K`;\n/** Clear to line end. */\nexport const eraseLineEnd = `${CSI}0K`;\n/** Clear to line start. */\nexport const eraseLineStart = `${CSI}1K`;\n\n/**\n * Clear screen and move cursor by n lines up and move cursor to first column.\n * @param count Number of lines.\n */\nexport function eraseLines(count: number): string {\n  let clear = \"\";\n  for (let i = 0; i < count; i++) {\n    clear += eraseLine + (i < count - 1 ? cursorUp() : \"\");\n  }\n  clear += cursorLeft;\n  return clear;\n}\n\n/** Clear the terminal screen. (Viewport) */\nexport const clearScreen = \"\\u001Bc\";\n\n/**\n * Clear the whole terminal, including scrollback buffer.\n * (Not just the visible part of it).\n */\nexport const clearTerminal = Deno.build.os === \"windows\"\n  ? `${eraseScreen}${CSI}0f`\n  // 1. Erases the screen (Only done in case `2` is not supported)\n  // 2. Erases the whole screen including scrollback buffer\n  // 3. Moves cursor to the top-left position\n  // More info: https://www.real-world-systems.com/docs/ANSIcode.html\n  : `${eraseScreen}${CSI}3J${CSI}H`;\n\n/**\n * Create link.\n * @param text Link text.\n * @param url Link url.\n * ```\n * console.log(\n *   ansi.link(\"Click me.\", \"https://deno.land\"),\n * );\n * ```\n */\nexport function link(text: string, url: string): string {\n  return [\n    OSC,\n    \"8\",\n    SEP,\n    SEP,\n    url,\n    bel,\n    text,\n    OSC,\n    \"8\",\n    SEP,\n    SEP,\n    bel,\n  ].join(\"\");\n}\n\n/** Image options. */\nexport interface ImageOptions {\n  width?: number;\n  height?: number;\n  preserveAspectRatio?: boolean;\n}\n\n/**\n * Create image.\n * @param buffer  Image buffer.\n * @param options Image options.\n * ```\n * const response = await fetch(\"https://deno.land/images/hashrock_simple.png\");\n * const imageBuffer: ArrayBuffer = await response.arrayBuffer();\n * console.log(\n *   ansi.image(imageBuffer),\n * );\n * ```\n */\nexport function image(\n  buffer: string | ArrayBuffer,\n  options?: ImageOptions,\n): string {\n  let ret = `${OSC}1337;File=inline=1`;\n\n  if (options?.width) {\n    ret += `;width=${options.width}`;\n  }\n\n  if (options?.height) {\n    ret += `;height=${options.height}`;\n  }\n\n  if (options?.preserveAspectRatio === false) {\n    ret += \";preserveAspectRatio=0\";\n  }\n\n  return ret + \":\" + encodeBase64(buffer) + bel;\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n\n/**\n * {@linkcode encode} and {@linkcode decode} for\n * [base64](https://en.wikipedia.org/wiki/Base64) encoding.\n *\n * This module is browser compatible.\n *\n * @example\n * ```ts\n * import {\n *   decode,\n *   encode,\n * } from \"https://deno.land/std@$STD_VERSION/encoding/base64.ts\";\n *\n * const b64Repr = \"Zm9vYg==\";\n *\n * const binaryData = decode(b64Repr);\n * console.log(binaryData);\n * // => Uint8Array [ 102, 111, 111, 98 ]\n *\n * console.log(encode(binaryData));\n * // => Zm9vYg==\n * ```\n *\n * @module\n */\n\nconst base64abc = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"+\",\n  \"/\",\n];\n\n/**\n * CREDIT: https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727\n * Encodes a given Uint8Array, ArrayBuffer or string into RFC4648 base64 representation\n * @param data\n */\nexport function encode(data: ArrayBuffer | string): string {\n  const uint8 = typeof data === \"string\"\n    ? new TextEncoder().encode(data)\n    : data instanceof Uint8Array\n    ? data\n    : new Uint8Array(data);\n  let result = \"\",\n    i;\n  const l = uint8.length;\n  for (i = 2; i < l; i += 3) {\n    result += base64abc[uint8[i - 2] >> 2];\n    result += base64abc[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];\n    result += base64abc[((uint8[i - 1] & 0x0f) << 2) | (uint8[i] >> 6)];\n    result += base64abc[uint8[i] & 0x3f];\n  }\n  if (i === l + 1) {\n    // 1 octet yet to write\n    result += base64abc[uint8[i - 2] >> 2];\n    result += base64abc[(uint8[i - 2] & 0x03) << 4];\n    result += \"==\";\n  }\n  if (i === l) {\n    // 2 octets yet to write\n    result += base64abc[uint8[i - 2] >> 2];\n    result += base64abc[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];\n    result += base64abc[(uint8[i - 1] & 0x0f) << 2];\n    result += \"=\";\n  }\n  return result;\n}\n\n/**\n * Decodes a given RFC4648 base64 encoded string\n * @param b64\n */\nexport function decode(b64: string): Uint8Array {\n  const binString = atob(b64);\n  const size = binString.length;\n  const bytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    bytes[i] = binString.charCodeAt(i);\n  }\n  return bytes;\n}\n", "import * as ansiEscapes from \"./ansi_escapes.ts\";\nimport type { Chain } from \"./chain.ts\";\n\ntype Args = Array<unknown>;\ntype Executor = (this: AnsiChain, ...args: Args) => string;\ntype Property = string | Executor;\ntype PropertyNames = keyof Chain<AnsiChain>;\n\n/** Ansi instance returned by all ansi escape properties. */\nexport interface AnsiChain extends Chain<AnsiChain> {\n  /** Get ansi escape sequence. */\n  (): string;\n  /** Get ansi escape sequence. */\n  toString(): string;\n  /** Get ansi escape sequence as Uint8Array. */\n  toBuffer(): Uint8Array;\n}\n\n/** Create new `Ansi` instance. */\nexport type AnsiFactory = () => Ansi;\n\n/**\n * Chainable ansi escape sequences.\n * If invoked as method, a new Ansi instance will be returned.\n */\nexport type Ansi = AnsiFactory & AnsiChain;\n\n/**\n * Chainable ansi escape sequences.\n * If invoked as method, a new Ansi instance will be returned.\n * ```\n * await Deno.stdout.write(\n *   new TextEncoder().encode(\n *     ansi.cursorTo(0, 0).eraseScreen(),\n *   ),\n * );\n * ```\n * Or shorter:\n * ```\n * await Deno.stdout.write(\n *   ansi.cursorTo(0, 0).eraseScreen.toBuffer(),\n * );\n * ```\n */\nexport const ansi: Ansi = factory();\n\nfunction factory(): Ansi {\n  let result: Array<string> = [];\n  let stack: Array<[Property, Args]> = [];\n\n  const ansi: Ansi = function (\n    this: AnsiChain | undefined,\n    ...args: Args\n  ): string | AnsiChain {\n    if (this) {\n      if (args.length) {\n        update(args);\n        return this;\n      }\n      return this.toString();\n    }\n    return factory();\n  } as Ansi;\n\n  ansi.text = function (text: string): AnsiChain {\n    stack.push([text, []]);\n    return this;\n  };\n\n  ansi.toString = function (): string {\n    update();\n    const str: string = result.join(\"\");\n    result = [];\n    return str;\n  };\n\n  ansi.toBuffer = function (): Uint8Array {\n    return new TextEncoder().encode(this.toString());\n  };\n\n  const methodList: Array<[PropertyNames, Property]> = Object.entries(\n    ansiEscapes,\n  ) as Array<[PropertyNames, Property]>;\n\n  for (const [name, method] of methodList) {\n    Object.defineProperty(ansi, name, {\n      get(this: AnsiChain) {\n        stack.push([method, []]);\n        return this;\n      },\n    });\n  }\n\n  return ansi;\n\n  function update(args?: Args) {\n    if (!stack.length) {\n      return;\n    }\n    if (args) {\n      stack[stack.length - 1][1] = args;\n    }\n    result.push(\n      ...stack.map(([prop, args]: [Property, Args]) =>\n        typeof prop === \"string\" ? prop : prop.call(ansi, ...args)\n      ),\n    );\n    stack = [];\n  }\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors\n// on npm.\n\n/**\n * String formatters and utilities for dealing with ANSI color codes.\n *\n * This module is browser compatible.\n *\n * This module supports `NO_COLOR` environmental variable disabling any coloring\n * if `NO_COLOR` is set.\n *\n * @example\n * ```typescript\n * import {\n *   bgBlue,\n *   bgRgb24,\n *   bgRgb8,\n *   bold,\n *   italic,\n *   red,\n *   rgb24,\n *   rgb8,\n * } from \"https://deno.land/std@$STD_VERSION/fmt/colors.ts\";\n *\n * console.log(bgBlue(italic(red(bold(\"Hello, World!\")))));\n *\n * // also supports 8bit colors\n *\n * console.log(rgb8(\"Hello, World!\", 42));\n *\n * console.log(bgRgb8(\"Hello, World!\", 42));\n *\n * // and 24bit rgb\n *\n * console.log(rgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n *\n * console.log(bgRgb24(\"Hello, World!\", {\n *   r: 41,\n *   g: 42,\n *   b: 43,\n * }));\n * ```\n *\n * @module\n */\n\n// deno-lint-ignore no-explicit-any\nconst { Deno } = globalThis as any;\nconst noColor = typeof Deno?.noColor === \"boolean\"\n  ? Deno.noColor as boolean\n  : true;\n\ninterface Code {\n  open: string;\n  close: string;\n  regexp: RegExp;\n}\n\n/** RGB 8-bits per channel. Each in range `0->255` or `0x00->0xff` */\ninterface Rgb {\n  r: number;\n  g: number;\n  b: number;\n}\n\nlet enabled = !noColor;\n\n/**\n * Set changing text color to enabled or disabled\n * @param value\n */\nexport function setColorEnabled(value: boolean) {\n  if (noColor) {\n    return;\n  }\n\n  enabled = value;\n}\n\n/** Get whether text color change is enabled or disabled. */\nexport function getColorEnabled(): boolean {\n  return enabled;\n}\n\n/**\n * Builds color code\n * @param open\n * @param close\n */\nfunction code(open: number[], close: number): Code {\n  return {\n    open: `\\x1b[${open.join(\";\")}m`,\n    close: `\\x1b[${close}m`,\n    regexp: new RegExp(`\\\\x1b\\\\[${close}m`, \"g\"),\n  };\n}\n\n/**\n * Applies color and background based on color code and its associated text\n * @param str text to apply color settings to\n * @param code color code to apply\n */\nfunction run(str: string, code: Code): string {\n  return enabled\n    ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`\n    : str;\n}\n\n/**\n * Reset the text modified\n * @param str text to reset\n */\nexport function reset(str: string): string {\n  return run(str, code([0], 0));\n}\n\n/**\n * Make the text bold.\n * @param str text to make bold\n */\nexport function bold(str: string): string {\n  return run(str, code([1], 22));\n}\n\n/**\n * The text emits only a small amount of light.\n * @param str text to dim\n */\nexport function dim(str: string): string {\n  return run(str, code([2], 22));\n}\n\n/**\n * Make the text italic.\n * @param str text to make italic\n */\nexport function italic(str: string): string {\n  return run(str, code([3], 23));\n}\n\n/**\n * Make the text underline.\n * @param str text to underline\n */\nexport function underline(str: string): string {\n  return run(str, code([4], 24));\n}\n\n/**\n * Invert background color and text color.\n * @param str text to invert its color\n */\nexport function inverse(str: string): string {\n  return run(str, code([7], 27));\n}\n\n/**\n * Make the text hidden.\n * @param str text to hide\n */\nexport function hidden(str: string): string {\n  return run(str, code([8], 28));\n}\n\n/**\n * Put horizontal line through the center of the text.\n * @param str text to strike through\n */\nexport function strikethrough(str: string): string {\n  return run(str, code([9], 29));\n}\n\n/**\n * Set text color to black.\n * @param str text to make black\n */\nexport function black(str: string): string {\n  return run(str, code([30], 39));\n}\n\n/**\n * Set text color to red.\n * @param str text to make red\n */\nexport function red(str: string): string {\n  return run(str, code([31], 39));\n}\n\n/**\n * Set text color to green.\n * @param str text to make green\n */\nexport function green(str: string): string {\n  return run(str, code([32], 39));\n}\n\n/**\n * Set text color to yellow.\n * @param str text to make yellow\n */\nexport function yellow(str: string): string {\n  return run(str, code([33], 39));\n}\n\n/**\n * Set text color to blue.\n * @param str text to make blue\n */\nexport function blue(str: string): string {\n  return run(str, code([34], 39));\n}\n\n/**\n * Set text color to magenta.\n * @param str text to make magenta\n */\nexport function magenta(str: string): string {\n  return run(str, code([35], 39));\n}\n\n/**\n * Set text color to cyan.\n * @param str text to make cyan\n */\nexport function cyan(str: string): string {\n  return run(str, code([36], 39));\n}\n\n/**\n * Set text color to white.\n * @param str text to make white\n */\nexport function white(str: string): string {\n  return run(str, code([37], 39));\n}\n\n/**\n * Set text color to gray.\n * @param str text to make gray\n */\nexport function gray(str: string): string {\n  return brightBlack(str);\n}\n\n/**\n * Set text color to bright black.\n * @param str text to make bright-black\n */\nexport function brightBlack(str: string): string {\n  return run(str, code([90], 39));\n}\n\n/**\n * Set text color to bright red.\n * @param str text to make bright-red\n */\nexport function brightRed(str: string): string {\n  return run(str, code([91], 39));\n}\n\n/**\n * Set text color to bright green.\n * @param str text to make bright-green\n */\nexport function brightGreen(str: string): string {\n  return run(str, code([92], 39));\n}\n\n/**\n * Set text color to bright yellow.\n * @param str text to make bright-yellow\n */\nexport function brightYellow(str: string): string {\n  return run(str, code([93], 39));\n}\n\n/**\n * Set text color to bright blue.\n * @param str text to make bright-blue\n */\nexport function brightBlue(str: string): string {\n  return run(str, code([94], 39));\n}\n\n/**\n * Set text color to bright magenta.\n * @param str text to make bright-magenta\n */\nexport function brightMagenta(str: string): string {\n  return run(str, code([95], 39));\n}\n\n/**\n * Set text color to bright cyan.\n * @param str text to make bright-cyan\n */\nexport function brightCyan(str: string): string {\n  return run(str, code([96], 39));\n}\n\n/**\n * Set text color to bright white.\n * @param str text to make bright-white\n */\nexport function brightWhite(str: string): string {\n  return run(str, code([97], 39));\n}\n\n/**\n * Set background color to black.\n * @param str text to make its background black\n */\nexport function bgBlack(str: string): string {\n  return run(str, code([40], 49));\n}\n\n/**\n * Set background color to red.\n * @param str text to make its background red\n */\nexport function bgRed(str: string): string {\n  return run(str, code([41], 49));\n}\n\n/**\n * Set background color to green.\n * @param str text to make its background green\n */\nexport function bgGreen(str: string): string {\n  return run(str, code([42], 49));\n}\n\n/**\n * Set background color to yellow.\n * @param str text to make its background yellow\n */\nexport function bgYellow(str: string): string {\n  return run(str, code([43], 49));\n}\n\n/**\n * Set background color to blue.\n * @param str text to make its background blue\n */\nexport function bgBlue(str: string): string {\n  return run(str, code([44], 49));\n}\n\n/**\n *  Set background color to magenta.\n * @param str text to make its background magenta\n */\nexport function bgMagenta(str: string): string {\n  return run(str, code([45], 49));\n}\n\n/**\n * Set background color to cyan.\n * @param str text to make its background cyan\n */\nexport function bgCyan(str: string): string {\n  return run(str, code([46], 49));\n}\n\n/**\n * Set background color to white.\n * @param str text to make its background white\n */\nexport function bgWhite(str: string): string {\n  return run(str, code([47], 49));\n}\n\n/**\n * Set background color to bright black.\n * @param str text to make its background bright-black\n */\nexport function bgBrightBlack(str: string): string {\n  return run(str, code([100], 49));\n}\n\n/**\n * Set background color to bright red.\n * @param str text to make its background bright-red\n */\nexport function bgBrightRed(str: string): string {\n  return run(str, code([101], 49));\n}\n\n/**\n * Set background color to bright green.\n * @param str text to make its background bright-green\n */\nexport function bgBrightGreen(str: string): string {\n  return run(str, code([102], 49));\n}\n\n/**\n * Set background color to bright yellow.\n * @param str text to make its background bright-yellow\n */\nexport function bgBrightYellow(str: string): string {\n  return run(str, code([103], 49));\n}\n\n/**\n * Set background color to bright blue.\n * @param str text to make its background bright-blue\n */\nexport function bgBrightBlue(str: string): string {\n  return run(str, code([104], 49));\n}\n\n/**\n * Set background color to bright magenta.\n * @param str text to make its background bright-magenta\n */\nexport function bgBrightMagenta(str: string): string {\n  return run(str, code([105], 49));\n}\n\n/**\n * Set background color to bright cyan.\n * @param str text to make its background bright-cyan\n */\nexport function bgBrightCyan(str: string): string {\n  return run(str, code([106], 49));\n}\n\n/**\n * Set background color to bright white.\n * @param str text to make its background bright-white\n */\nexport function bgBrightWhite(str: string): string {\n  return run(str, code([107], 49));\n}\n\n/* Special Color Sequences */\n\n/**\n * Clam and truncate color codes\n * @param n\n * @param max number to truncate to\n * @param min number to truncate from\n */\nfunction clampAndTruncate(n: number, max = 255, min = 0): number {\n  return Math.trunc(Math.max(Math.min(n, max), min));\n}\n\n/**\n * Set text color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit colors to\n * @param color code\n */\nexport function rgb8(str: string, color: number): string {\n  return run(str, code([38, 5, clampAndTruncate(color)], 39));\n}\n\n/**\n * Set background color using paletted 8bit colors.\n * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit\n * @param str text color to apply paletted 8bit background colors to\n * @param color code\n */\nexport function bgRgb8(str: string, color: number): string {\n  return run(str, code([48, 5, clampAndTruncate(color)], 49));\n}\n\n/**\n * Set text color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n *      import { rgb24 } from \"https://deno.land/std@$STD_VERSION/fmt/colors.ts\";\n *      rgb24(\"foo\", 0xff00ff);\n *      rgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function rgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        39,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        38,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      39,\n    ),\n  );\n}\n\n/**\n * Set background color using 24bit rgb.\n * `color` can be a number in range `0x000000` to `0xffffff` or\n * an `Rgb`.\n *\n * To produce the color magenta:\n *\n * ```ts\n *      import { bgRgb24 } from \"https://deno.land/std@$STD_VERSION/fmt/colors.ts\";\n *      bgRgb24(\"foo\", 0xff00ff);\n *      bgRgb24(\"foo\", {r: 255, g: 0, b: 255});\n * ```\n * @param str text color to apply 24bit rgb to\n * @param color code\n */\nexport function bgRgb24(str: string, color: number | Rgb): string {\n  if (typeof color === \"number\") {\n    return run(\n      str,\n      code(\n        [48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff],\n        49,\n      ),\n    );\n  }\n  return run(\n    str,\n    code(\n      [\n        48,\n        2,\n        clampAndTruncate(color.r),\n        clampAndTruncate(color.g),\n        clampAndTruncate(color.b),\n      ],\n      49,\n    ),\n  );\n}\n\n// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js\nconst ANSI_PATTERN = new RegExp(\n  [\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))\",\n  ].join(\"|\"),\n  \"g\",\n);\n\n/**\n * Remove ANSI escape codes from the string.\n * @param string to remove ANSI escape codes from\n */\nexport function stripColor(string: string): string {\n  return string.replace(ANSI_PATTERN, \"\");\n}\n", "import * as stdColors from \"https://deno.land/std@0.170.0/fmt/colors.ts\";\n\ntype ExcludedColorMethods = \"setColorEnabled\" | \"getColorEnabled\";\ntype PropertyNames = keyof typeof stdColors;\ntype ColorMethod = (str: string, ...args: Array<unknown>) => string;\ntype ColorMethods = Exclude<PropertyNames, ExcludedColorMethods>;\ntype Chainable<T, E extends keyof T | null = null> = {\n  [P in keyof T]: P extends E ? T[P] : Chainable<T, E> & T[P];\n};\n\n/** Chainable colors instance returned by all ansi escape properties. */\nexport type ColorsChain =\n  & Chainable<typeof stdColors, ExcludedColorMethods>\n  & { _stack: Array<ColorMethods> };\n\n/** Create new `Colors` instance. */\nexport type ColorsFactory = () => Colors;\n\n/**\n * Chainable colors module.\n * If invoked as method, a new `Colors` instance will be returned.\n */\nexport type Colors = ColorsFactory & ColorsChain;\n\nconst proto = Object.create(null);\nconst methodNames = Object.keys(stdColors) as Array<PropertyNames>;\nfor (const name of methodNames) {\n  if (name === \"setColorEnabled\" || name === \"getColorEnabled\") {\n    continue;\n  }\n  Object.defineProperty(proto, name, {\n    get(this: ColorsChain) {\n      return factory([...this._stack, name]);\n    },\n  });\n}\n\nexport const colors: Colors = factory();\n\n/**\n * Chainable colors module.\n * ```\n * console.log(colors.blue.bgRed.bold('Welcome to Deno.Land!'));\n * ```\n * If invoked as method, a new Ansi instance will be returned.\n * ```\n * const myColors: Colors = colors();\n * console.log(myColors.blue.bgRed.bold('Welcome to Deno.Land!'));\n * ```\n */\nfunction factory(stack: Array<ColorMethods> = []): Colors {\n  const colors: Colors = function (\n    this: ColorsChain | undefined,\n    str?: string,\n    ...args: Array<unknown>\n  ): string | ColorsChain {\n    if (str) {\n      const lastIndex = stack.length - 1;\n      return stack.reduce(\n        (str: string, name: PropertyNames, index: number) =>\n          index === lastIndex\n            ? (stdColors[name] as ColorMethod)(str, ...args)\n            : (stdColors[name] as ColorMethod)(str),\n        str,\n      );\n    }\n    const tmp = stack.slice();\n    stack = [];\n    return factory(tmp);\n  } as Colors;\n\n  Object.setPrototypeOf(colors, proto);\n  colors._stack = stack;\n  return colors;\n}\n", "import { cursorPosition } from \"./ansi_escapes.ts\";\n\n/** Cursor position. */\nexport interface Cursor {\n  x: number;\n  y: number;\n}\n\n/** Cursor position options. */\nexport interface CursorPositionOptions {\n  stdout?: Deno.WriterSync;\n  stdin?: Deno.ReaderSync & { rid: number };\n}\n\n/**\n * Get cursor position.\n * @param options  Options.\n * ```\n * const cursor: Cursor = getCursorPosition();\n * console.log(cursor); // { x: 0, y: 14}\n * ```\n */\nexport function getCursorPosition(\n  {\n    stdin = Deno.stdin,\n    stdout = Deno.stdout,\n  }: CursorPositionOptions = {},\n): Cursor {\n  const data = new Uint8Array(8);\n\n  Deno.stdin.setRaw(true);\n  stdout.writeSync(new TextEncoder().encode(cursorPosition));\n  stdin.readSync(data);\n  Deno.stdin.setRaw(false);\n\n  const [y, x] = new TextDecoder()\n    .decode(data)\n    .match(/\\[(\\d+);(\\d+)R/)\n    ?.slice(1, 3)\n    .map(Number) ?? [0, 0];\n\n  return { x, y };\n}\n", "import * as ansiEscapes from \"./ansi_escapes.ts\";\nimport type { Chain } from \"./chain.ts\";\nimport { Cursor, getCursorPosition } from \"./cursor_position.ts\";\n\n/** Create new `Ansi` instance. */\nexport interface TtyOptions {\n  stdout?: Deno.WriterSync;\n  stdin?: Deno.ReaderSync & { rid: number };\n}\n\ntype Executor = (this: TtyChain, ...args: Args) => string;\ntype Args = Array<unknown>;\ntype Property = string | Executor;\ntype PropertyNames = keyof Chain<TtyChain>;\n\n/** Ansi instance returned by all ansi escape properties. */\nexport interface TtyChain extends Exclude<Chain<TtyChain>, \"cursorPosition\"> {\n  /** Write ansi escape sequence. */\n  (): void;\n  /** Get current cursor position. */\n  getCursorPosition(): Cursor;\n}\n\n/** Create new `Tty` instance. */\nexport type TtyFactory = (options?: TtyOptions) => Tty;\n\n/**\n * Chainable ansi escape sequences.\n * If invoked as method, a new Tty instance will be returned.\n */\nexport type Tty = TtyFactory & TtyChain;\n\n/**\n * Chainable ansi escape sequences.\n * If invoked as method, a new Tty instance will be returned.\n * ```\n * tty.cursorTo(0, 0).eraseScreen();\n * ```\n */\nexport const tty: Tty = factory();\n\nfunction factory(options?: TtyOptions): Tty {\n  let result = \"\";\n  let stack: Array<[Property, Args]> = [];\n  const stdout: Deno.WriterSync = options?.stdout ?? Deno.stdout;\n  const stdin: Deno.ReaderSync & { rid: number } = options?.stdin ?? Deno.stdin;\n\n  const tty: Tty = function (\n    this: TtyChain | undefined,\n    ...args: Args | [TtyOptions]\n  ): TtyChain {\n    if (this) {\n      update(args);\n      stdout.writeSync(new TextEncoder().encode(result));\n      return this;\n    }\n    return factory(args[0] as TtyOptions ?? options);\n  } as Tty;\n\n  tty.text = function (text: string): TtyChain {\n    stack.push([text, []]);\n    update();\n    stdout.writeSync(new TextEncoder().encode(result));\n    return this;\n  };\n\n  tty.getCursorPosition = (): Cursor => getCursorPosition({ stdout, stdin });\n\n  const methodList: Array<[PropertyNames, Property]> = Object.entries(\n    ansiEscapes,\n  ) as Array<[PropertyNames, Property]>;\n\n  for (const [name, method] of methodList) {\n    if (name === \"cursorPosition\") {\n      continue;\n    }\n    Object.defineProperty(tty, name, {\n      get(this: TtyChain) {\n        stack.push([method, []]);\n        return this;\n      },\n    });\n  }\n\n  return tty;\n\n  function update(args?: Args) {\n    if (!stack.length) {\n      return;\n    }\n    if (args) {\n      stack[stack.length - 1][1] = args;\n    }\n    result = stack.reduce(\n      (prev: string, [cur, args]: [Property, Args]) =>\n        prev + (typeof cur === \"string\" ? cur : cur.call(tty, ...args)),\n      \"\",\n    );\n    stack = [];\n  }\n}\n", "export function distance(a: string, b: string): number {\n  if (a.length == 0) {\n    return b.length;\n  }\n  if (b.length == 0) {\n    return a.length;\n  }\n  const matrix = [];\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n  for (let j = 0; j <= a.length; j++) {\n    matrix[0][j] = j;\n  }\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) == a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1,\n          Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1),\n        );\n      }\n    }\n  }\n  return matrix[b.length][a.length];\n}\n", "import type { FlagOptions } from \"./types.ts\";\nimport { distance } from \"../_utils/distance.ts\";\n\n/** Convert param case string to camel case. */\nexport function paramCaseToCamelCase(str: string): string {\n  return str.replace(\n    /-([a-z])/g,\n    (g) => g[1].toUpperCase(),\n  );\n}\n\n/** Convert underscore case string to camel case. */\nexport function underscoreToCamelCase(str: string): string {\n  return str\n    .replace(/([a-z])([A-Z])/g, \"$1_$2\")\n    .toLowerCase()\n    .replace(\n      /_([a-z])/g,\n      (g) => g[1].toUpperCase(),\n    );\n}\n\n/**\n * Find option by flag, name or alias.\n *\n * @param flags Source options array.\n * @param name  Name of the option.\n */\nexport function getOption<O extends FlagOptions>(\n  flags: Array<O>,\n  name: string,\n): O | undefined {\n  while (name[0] === \"-\") {\n    name = name.slice(1);\n  }\n\n  for (const flag of flags) {\n    if (isOption(flag, name)) {\n      return flag;\n    }\n  }\n\n  return;\n}\n\nexport function didYouMeanOption(\n  option: string,\n  options: Array<FlagOptions>,\n): string {\n  const optionNames = options\n    .map((option) => [option.name, ...(option.aliases ?? [])])\n    .flat()\n    .map((option) => getFlag(option));\n  return didYouMean(\" Did you mean option\", getFlag(option), optionNames);\n}\n\nexport function didYouMeanType(type: string, types: Array<string>): string {\n  return didYouMean(\" Did you mean type\", type, types);\n}\n\nexport function didYouMean(\n  message: string,\n  type: string,\n  types: Array<string>,\n): string {\n  const match: string | undefined = closest(type, types);\n  return match ? `${message} \"${match}\"?` : \"\";\n}\n\nexport function getFlag(name: string) {\n  if (name.startsWith(\"-\")) {\n    return name;\n  }\n  if (name.length > 1) {\n    return `--${name}`;\n  }\n  return `-${name}`;\n}\n\n/**\n * Check if option has name or alias.\n *\n * @param option    The option to check.\n * @param name      The option name or alias.\n */\nfunction isOption(option: FlagOptions, name: string) {\n  return option.name === name ||\n    (option.aliases && option.aliases.indexOf(name) !== -1);\n}\n\nexport function matchWildCardOptions(\n  name: string,\n  flags: Array<FlagOptions>,\n): FlagOptions | undefined {\n  for (const option of flags) {\n    if (option.name.indexOf(\"*\") === -1) {\n      continue;\n    }\n    let matched = matchWildCardOption(name, option);\n    if (matched) {\n      matched = { ...matched, name };\n      flags.push(matched);\n      return matched;\n    }\n  }\n}\n\nfunction matchWildCardOption(\n  name: string,\n  option: FlagOptions,\n): FlagOptions | false {\n  const parts = option.name.split(\".\");\n  const parts2 = name.split(\".\");\n  if (parts.length !== parts2.length) {\n    return false;\n  }\n  const count = Math.max(parts.length, parts2.length);\n  for (let i = 0; i < count; i++) {\n    if (parts[i] !== parts2[i] && parts[i] !== \"*\") {\n      return false;\n    }\n  }\n  return option;\n}\n\nfunction closest(str: string, arr: string[]): string | undefined {\n  let minDistance = Infinity;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const dist = distance(str, arr[i]);\n    if (dist < minDistance) {\n      minDistance = dist;\n      minIndex = i;\n    }\n  }\n  return arr[minIndex];\n}\n\nexport function getDefaultValue(option: FlagOptions): unknown {\n  return typeof option.default === \"function\"\n    ? option.default()\n    : option.default;\n}\n", "import { didYouMeanOption, didYouMeanType, getFlag } from \"./_utils.ts\";\nimport type { ArgumentValue, FlagOptions } from \"./types.ts\";\n\nexport class FlagsError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, FlagsError.prototype);\n  }\n}\n\nexport class UnknownRequiredOptionError extends FlagsError {\n  constructor(option: string, options: Array<FlagOptions>) {\n    super(\n      `Unknown required option \"${getFlag(option)}\".${\n        didYouMeanOption(option, options)\n      }`,\n    );\n    Object.setPrototypeOf(this, UnknownRequiredOptionError.prototype);\n  }\n}\n\nexport class UnknownConflictingOptionError extends FlagsError {\n  constructor(option: string, options: Array<FlagOptions>) {\n    super(\n      `Unknown conflicting option \"${getFlag(option)}\".${\n        didYouMeanOption(option, options)\n      }`,\n    );\n    Object.setPrototypeOf(this, UnknownConflictingOptionError.prototype);\n  }\n}\n\nexport class UnknownTypeError extends FlagsError {\n  constructor(type: string, types: Array<string>) {\n    super(`Unknown type \"${type}\".${didYouMeanType(type, types)}`);\n    Object.setPrototypeOf(this, UnknownTypeError.prototype);\n  }\n}\n\n/* Validation errors. */\n\n/**\n * A validation error is thrown when the command is wrongly used by the user.\n * For example: If the user passes some invalid options or arguments to the\n * command.\n */\nexport class ValidationError extends FlagsError {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n\nexport class DuplicateOptionError extends ValidationError {\n  constructor(name: string) {\n    super(\n      `Option \"${\n        getFlag(name).replace(/^--no-/, \"--\")\n      }\" can only occur once, but was found several times.`,\n    );\n    Object.setPrototypeOf(this, DuplicateOptionError.prototype);\n  }\n}\n\nexport class InvalidOptionError extends ValidationError {\n  constructor(option: string, options: Array<FlagOptions>) {\n    super(\n      `Invalid option \"${getFlag(option)}\".${\n        didYouMeanOption(option, options)\n      }`,\n    );\n    Object.setPrototypeOf(this, InvalidOptionError.prototype);\n  }\n}\n\nexport class UnknownOptionError extends ValidationError {\n  constructor(option: string, options: Array<FlagOptions>) {\n    super(\n      `Unknown option \"${getFlag(option)}\".${\n        didYouMeanOption(option, options)\n      }`,\n    );\n    Object.setPrototypeOf(this, UnknownOptionError.prototype);\n  }\n}\n\nexport class MissingOptionValueError extends ValidationError {\n  constructor(option: string) {\n    super(`Missing value for option \"${getFlag(option)}\".`);\n    Object.setPrototypeOf(this, MissingOptionValueError.prototype);\n  }\n}\n\nexport class InvalidOptionValueError extends ValidationError {\n  constructor(option: string, expected: string, value: string) {\n    super(\n      `Option \"${\n        getFlag(option)\n      }\" must be of type \"${expected}\", but got \"${value}\".`,\n    );\n    Object.setPrototypeOf(this, InvalidOptionValueError.prototype);\n  }\n}\n\nexport class UnexpectedOptionValueError extends ValidationError {\n  constructor(option: string, value: string) {\n    super(\n      `Option \"${getFlag(option)}\" doesn't take a value, but got \"${value}\".`,\n    );\n    Object.setPrototypeOf(this, InvalidOptionValueError.prototype);\n  }\n}\n\nexport class OptionNotCombinableError extends ValidationError {\n  constructor(option: string) {\n    super(`Option \"${getFlag(option)}\" cannot be combined with other options.`);\n    Object.setPrototypeOf(this, OptionNotCombinableError.prototype);\n  }\n}\n\nexport class ConflictingOptionError extends ValidationError {\n  constructor(option: string, conflictingOption: string) {\n    super(\n      `Option \"${getFlag(option)}\" conflicts with option \"${\n        getFlag(conflictingOption)\n      }\".`,\n    );\n    Object.setPrototypeOf(this, ConflictingOptionError.prototype);\n  }\n}\n\nexport class DependingOptionError extends ValidationError {\n  constructor(option: string, dependingOption: string) {\n    super(\n      `Option \"${getFlag(option)}\" depends on option \"${\n        getFlag(dependingOption)\n      }\".`,\n    );\n    Object.setPrototypeOf(this, DependingOptionError.prototype);\n  }\n}\n\nexport class MissingRequiredOptionError extends ValidationError {\n  constructor(option: string) {\n    super(`Missing required option \"${getFlag(option)}\".`);\n    Object.setPrototypeOf(this, MissingRequiredOptionError.prototype);\n  }\n}\n\nexport class UnexpectedRequiredArgumentError extends ValidationError {\n  constructor(arg: string) {\n    super(\n      `An required argument cannot follow an optional argument, but \"${arg}\"  is defined as required.`,\n    );\n    Object.setPrototypeOf(\n      this,\n      UnexpectedRequiredArgumentError.prototype,\n    );\n  }\n}\n\nexport class UnexpectedArgumentAfterVariadicArgumentError\n  extends ValidationError {\n  constructor(arg: string) {\n    super(`An argument cannot follow an variadic argument, but got \"${arg}\".`);\n    Object.setPrototypeOf(\n      this,\n      UnexpectedArgumentAfterVariadicArgumentError.prototype,\n    );\n  }\n}\n\nexport class InvalidTypeError extends ValidationError {\n  constructor(\n    { label, name, value, type }: ArgumentValue,\n    expected?: Array<string | number | boolean>,\n  ) {\n    super(\n      `${label} \"${name}\" must be of type \"${type}\", but got \"${value}\".` + (\n        expected\n          ? ` Expected values: ${\n            expected.map((value) => `\"${value}\"`).join(\", \")\n          }`\n          : \"\"\n      ),\n    );\n    Object.setPrototypeOf(this, MissingOptionValueError.prototype);\n  }\n}\n", "import {\n  UnexpectedArgumentAfterVariadicArgumentError,\n  UnexpectedRequiredArgumentError,\n} from \"../flags/_errors.ts\";\nimport { didYouMean } from \"../flags/_utils.ts\";\nimport { OptionType } from \"../flags/deprecated.ts\";\nimport type { Command } from \"./command.ts\";\nimport type { Argument } from \"./types.ts\";\n\nexport function didYouMeanCommand(\n  command: string,\n  commands: Array<Command>,\n  excludes: Array<string> = [],\n): string {\n  const commandNames = commands\n    .map((command) => command.getName())\n    .filter((command) => !excludes.includes(command));\n  return didYouMean(\" Did you mean command\", command, commandNames);\n}\n\nconst ARGUMENT_REGEX = /^[<\\[].+[\\]>]$/;\nconst ARGUMENT_DETAILS_REGEX = /[<\\[:>\\]]/;\n\ninterface SplitArgumentsResult {\n  flags: string[];\n  typeDefinition: string;\n  equalsSign: boolean;\n}\n\n/**\n * Split options and arguments.\n * @param args Arguments definition: `--color, -c <color1:string> <color2:string>`\n *\n * For example: `-c, --color <color1:string> <color2:string>`\n *\n * Will result in:\n * ```\n * {\n *   flags: [ \"-c\", \"--color\" ],\n *   typeDefinition: \"<color1:string> <color2:string>\"\n * }\n * ```\n */\nexport function splitArguments(\n  args: string,\n): SplitArgumentsResult {\n  const parts = args.trim().split(/[, =] */g);\n  const typeParts = [];\n\n  while (\n    parts[parts.length - 1] &&\n    ARGUMENT_REGEX.test(parts[parts.length - 1])\n  ) {\n    typeParts.unshift(parts.pop());\n  }\n\n  const typeDefinition: string = typeParts.join(\" \");\n\n  return { flags: parts, typeDefinition, equalsSign: args.includes(\"=\") };\n}\n\n/**\n * Parse arguments string.\n * @param argsDefinition Arguments definition: `<color1:string> <color2:string>`\n */\nexport function parseArgumentsDefinition<T extends boolean>(\n  argsDefinition: string,\n  validate: boolean,\n  all: true,\n): Array<Argument | string>;\nexport function parseArgumentsDefinition<T extends boolean>(\n  argsDefinition: string,\n  validate?: boolean,\n  all?: false,\n): Array<Argument>;\nexport function parseArgumentsDefinition<T extends boolean>(\n  argsDefinition: string,\n  validate = true,\n  all?: T,\n): T extends true ? Array<Argument | string> : Array<Argument> {\n  const argumentDetails: Array<Argument | string> = [];\n\n  let hasOptional = false;\n  let hasVariadic = false;\n  const parts: string[] = argsDefinition.split(/ +/);\n\n  for (const arg of parts) {\n    if (validate && hasVariadic) {\n      throw new UnexpectedArgumentAfterVariadicArgumentError(arg);\n    }\n    const parts: string[] = arg.split(ARGUMENT_DETAILS_REGEX);\n\n    if (!parts[1]) {\n      if (all) {\n        argumentDetails.push(parts[0]);\n      }\n      continue;\n    }\n    const type: string | undefined = parts[2] || OptionType.STRING;\n\n    const details: Argument = {\n      optionalValue: arg[0] === \"[\",\n      requiredValue: arg[0] === \"<\",\n      name: parts[1],\n      action: parts[3] || type,\n      variadic: false,\n      list: type ? arg.indexOf(type + \"[]\") !== -1 : false,\n      type,\n    };\n\n    if (validate && !details.optionalValue && hasOptional) {\n      throw new UnexpectedRequiredArgumentError(details.name);\n    }\n\n    if (arg[0] === \"[\") {\n      hasOptional = true;\n    }\n\n    if (details.name.length > 3) {\n      const istVariadicLeft = details.name.slice(0, 3) === \"...\";\n      const istVariadicRight = details.name.slice(-3) === \"...\";\n\n      hasVariadic = details.variadic = istVariadicLeft || istVariadicRight;\n\n      if (istVariadicLeft) {\n        details.name = details.name.slice(3);\n      } else if (istVariadicRight) {\n        details.name = details.name.slice(0, -3);\n      }\n    }\n\n    argumentDetails.push(details);\n  }\n\n  return argumentDetails as (\n    T extends true ? Array<Argument | string> : Array<Argument>\n  );\n}\n\nexport function dedent(str: string): string {\n  const lines = str.split(/\\r?\\n|\\r/g);\n  let text = \"\";\n  let indent = 0;\n\n  for (const line of lines) {\n    if (text || line.trim()) {\n      if (!text) {\n        text = line.trimStart();\n        indent = line.length - text.length;\n      } else {\n        text += line.slice(indent);\n      }\n      text += \"\\n\";\n    }\n  }\n\n  return text.trimEnd();\n}\n\nexport function getDescription(\n  description: string,\n  short?: boolean,\n): string {\n  return short\n    ? description.trim().split(\"\\n\", 1)[0].trim()\n    : dedent(description);\n}\n", "import { didYouMeanCommand } from \"./_utils.ts\";\nimport type { Command } from \"./command.ts\";\nimport { getFlag } from \"../flags/_utils.ts\";\nimport { EnvVar } from \"./types.ts\";\n\nexport class CommandError extends Error {\n  constructor(message: string) {\n    super(message);\n    Object.setPrototypeOf(this, CommandError.prototype);\n  }\n}\n\nexport interface ValidationErrorOptions {\n  exitCode?: number;\n}\n\nexport class ValidationError extends CommandError {\n  public readonly exitCode: number;\n  public cmd?: Command;\n\n  constructor(message: string, { exitCode }: ValidationErrorOptions = {}) {\n    super(message);\n    Object.setPrototypeOf(this, ValidationError.prototype);\n    this.exitCode = exitCode ?? 1;\n  }\n}\n\nexport class DuplicateOptionNameError extends CommandError {\n  constructor(name: string) {\n    super(`Option with name \"${getFlag(name)}\" already exists.`);\n    Object.setPrototypeOf(this, DuplicateOptionNameError.prototype);\n  }\n}\n\nexport class MissingCommandNameError extends CommandError {\n  constructor() {\n    super(\"Missing command name.\");\n    Object.setPrototypeOf(this, MissingCommandNameError.prototype);\n  }\n}\n\nexport class DuplicateCommandNameError extends CommandError {\n  constructor(name: string) {\n    super(`Duplicate command name \"${name}\".`);\n    Object.setPrototypeOf(this, DuplicateCommandNameError.prototype);\n  }\n}\n\nexport class DuplicateCommandAliasError extends CommandError {\n  constructor(alias: string) {\n    super(`Duplicate command alias \"${alias}\".`);\n    Object.setPrototypeOf(this, DuplicateCommandAliasError.prototype);\n  }\n}\n\nexport class CommandNotFoundError extends CommandError {\n  constructor(\n    name: string,\n    commands: Array<Command>,\n    excluded?: Array<string>,\n  ) {\n    super(\n      `Unknown command \"${name}\".${\n        didYouMeanCommand(name, commands, excluded)\n      }`,\n    );\n    Object.setPrototypeOf(this, CommandNotFoundError.prototype);\n  }\n}\n\nexport class DuplicateTypeError extends CommandError {\n  constructor(name: string) {\n    super(`Type with name \"${name}\" already exists.`);\n    Object.setPrototypeOf(this, DuplicateTypeError.prototype);\n  }\n}\n\nexport class DuplicateCompletionError extends CommandError {\n  constructor(name: string) {\n    super(`Completion with name \"${name}\" already exists.`);\n    Object.setPrototypeOf(this, DuplicateCompletionError.prototype);\n  }\n}\n\nexport class DuplicateExampleError extends CommandError {\n  constructor(name: string) {\n    super(`Example with name \"${name}\" already exists.`);\n    Object.setPrototypeOf(this, DuplicateExampleError.prototype);\n  }\n}\n\nexport class DuplicateEnvVarError extends CommandError {\n  constructor(name: string) {\n    super(`Environment variable with name \"${name}\" already exists.`);\n    Object.setPrototypeOf(this, DuplicateEnvVarError.prototype);\n  }\n}\n\nexport class MissingRequiredEnvVarError extends ValidationError {\n  constructor(envVar: EnvVar) {\n    super(`Missing required environment variable \"${envVar.names[0]}\".`);\n    Object.setPrototypeOf(this, MissingRequiredEnvVarError.prototype);\n  }\n}\n\nexport class TooManyEnvVarValuesError extends CommandError {\n  constructor(name: string) {\n    super(\n      `An environment variable can only have one value, but \"${name}\" has more than one.`,\n    );\n    Object.setPrototypeOf(this, TooManyEnvVarValuesError.prototype);\n  }\n}\n\nexport class UnexpectedOptionalEnvVarValueError extends CommandError {\n  constructor(name: string) {\n    super(\n      `An environment variable cannot have an optional value, but \"${name}\" is defined as optional.`,\n    );\n    Object.setPrototypeOf(this, UnexpectedOptionalEnvVarValueError.prototype);\n  }\n}\n\nexport class UnexpectedVariadicEnvVarValueError extends CommandError {\n  constructor(name: string) {\n    super(\n      `An environment variable cannot have an variadic value, but \"${name}\" is defined as variadic.`,\n    );\n    Object.setPrototypeOf(this, UnexpectedVariadicEnvVarValueError.prototype);\n  }\n}\n\nexport class DefaultCommandNotFoundError extends CommandError {\n  constructor(name: string, commands: Array<Command>) {\n    super(\n      `Default command \"${name}\" not found.${\n        didYouMeanCommand(name, commands)\n      }`,\n    );\n    Object.setPrototypeOf(this, DefaultCommandNotFoundError.prototype);\n  }\n}\n\nexport class CommandExecutableNotFoundError extends CommandError {\n  constructor(name: string) {\n    super(\n      `Command executable not found: ${name}`,\n    );\n    Object.setPrototypeOf(this, CommandExecutableNotFoundError.prototype);\n  }\n}\n\nexport class UnknownCompletionCommandError extends CommandError {\n  constructor(name: string, commands: Array<Command>) {\n    super(\n      `Auto-completion failed. Unknown command \"${name}\".${\n        didYouMeanCommand(name, commands)\n      }`,\n    );\n    Object.setPrototypeOf(this, UnknownCompletionCommandError.prototype);\n  }\n}\n\n/* Validation errors. */\n\nexport class UnknownCommandError extends ValidationError {\n  constructor(\n    name: string,\n    commands: Array<Command>,\n    excluded?: Array<string>,\n  ) {\n    super(\n      `Unknown command \"${name}\".${\n        didYouMeanCommand(name, commands, excluded)\n      }`,\n    );\n    Object.setPrototypeOf(this, UnknownCommandError.prototype);\n  }\n}\n\nexport class NoArgumentsAllowedError extends ValidationError {\n  constructor(name: string) {\n    super(`No arguments allowed for command \"${name}\".`);\n    Object.setPrototypeOf(this, NoArgumentsAllowedError.prototype);\n  }\n}\n\nexport class MissingArgumentsError extends ValidationError {\n  constructor(names: Array<string>) {\n    super(`Missing argument(s): ${names.join(\", \")}`);\n    Object.setPrototypeOf(this, MissingArgumentsError.prototype);\n  }\n}\n\nexport class MissingArgumentError extends ValidationError {\n  constructor(name: string) {\n    super(`Missing argument: ${name}`);\n    Object.setPrototypeOf(this, MissingArgumentError.prototype);\n  }\n}\n\nexport class TooManyArgumentsError extends ValidationError {\n  constructor(args: Array<string>) {\n    super(`Too many arguments: ${args.join(\" \")}`);\n    Object.setPrototypeOf(this, TooManyArgumentsError.prototype);\n  }\n}\n", "import type { ArgumentValue, TypeHandler } from \"../types.ts\";\nimport { InvalidTypeError } from \"../_errors.ts\";\n\n/** Boolean type handler. Excepts `true`, `false`, `1`, `0` */\nexport const boolean: TypeHandler<boolean> = (\n  type: ArgumentValue,\n): boolean => {\n  if (~[\"1\", \"true\"].indexOf(type.value)) {\n    return true;\n  }\n\n  if (~[\"0\", \"false\"].indexOf(type.value)) {\n    return false;\n  }\n\n  throw new InvalidTypeError(type, [\"true\", \"false\", \"1\", \"0\"]);\n};\n", "import type { ArgumentValue, TypeHandler } from \"../types.ts\";\nimport { InvalidTypeError } from \"../_errors.ts\";\n\n/** Number type handler. Excepts any numeric value. */\nexport const number: TypeHandler<number> = (type: ArgumentValue): number => {\n  const value = Number(type.value);\n  if (Number.isFinite(value)) {\n    return value;\n  }\n\n  throw new InvalidTypeError(type);\n};\n", "import type { ArgumentValue, TypeHandler } from \"../types.ts\";\n\n/** String type handler. Excepts any value. */\nexport const string: TypeHandler<string> = (\n  { value }: ArgumentValue,\n): string => {\n  return value;\n};\n", "import { getDefaultValue, getOption, paramCaseToCamelCase } from \"./_utils.ts\";\nimport {\n  ConflictingOptionError,\n  DependingOptionError,\n  MissingOptionValueError,\n  MissingRequiredOptionError,\n  OptionNotCombinableError,\n  UnknownOptionError,\n} from \"./_errors.ts\";\nimport { ParseFlagsContext, ParseFlagsOptions } from \"./types.ts\";\nimport type { ArgumentOptions, FlagOptions } from \"./types.ts\";\n\n/**\n * Flags post validation. Validations that are not already done by the parser.\n *\n * @param ctx     Parse context.\n * @param opts    Parse options.\n * @param options Option name mappings: propertyName -> option\n */\nexport function validateFlags<T extends FlagOptions = FlagOptions>(\n  ctx: ParseFlagsContext<Record<string, unknown>>,\n  opts: ParseFlagsOptions<T>,\n  options: Map<string, FlagOptions> = new Map(),\n): void {\n  if (!opts.flags) {\n    return;\n  }\n  const defaultValues = setDefaultValues(ctx, opts);\n\n  const optionNames = Object.keys(ctx.flags);\n  if (!optionNames.length && opts.allowEmpty) {\n    return;\n  }\n\n  if (ctx.standalone) {\n    validateStandaloneOption(\n      ctx,\n      options,\n      optionNames,\n      defaultValues,\n    );\n    return;\n  }\n\n  for (const [name, option] of options) {\n    validateUnknownOption(option, opts);\n    validateConflictingOptions(ctx, option);\n    validateDependingOptions(ctx, option, defaultValues);\n    validateRequiredValues(ctx, option, name);\n  }\n\n  validateRequiredOptions(ctx, options, opts);\n}\n\nfunction validateUnknownOption<T extends FlagOptions = FlagOptions>(\n  option: FlagOptions,\n  opts: ParseFlagsOptions<T>,\n) {\n  if (!getOption(opts.flags ?? [], option.name)) {\n    throw new UnknownOptionError(option.name, opts.flags ?? []);\n  }\n}\n\n/**\n * Adds all default values to ctx.flags and returns a boolean object map with\n * only the default option names `{ [OptionName: string]: boolean }`.\n */\nfunction setDefaultValues<T extends FlagOptions = FlagOptions>(\n  ctx: ParseFlagsContext<Record<string, unknown>>,\n  opts: ParseFlagsOptions<T>,\n) {\n  const defaultValues: Record<string, boolean> = {};\n  if (!opts.flags?.length) {\n    return defaultValues;\n  }\n\n  // Set default values\n  for (const option of opts.flags) {\n    let name: string | undefined;\n    let defaultValue: unknown = undefined;\n\n    // if --no-[flag] is present set --[flag] default value to true\n    if (option.name.startsWith(\"no-\")) {\n      const propName = option.name.replace(/^no-/, \"\");\n      if (typeof ctx.flags[propName] !== \"undefined\") {\n        continue;\n      }\n      const positiveOption = getOption(opts.flags, propName);\n      if (positiveOption) {\n        continue;\n      }\n      name = paramCaseToCamelCase(propName);\n      defaultValue = true;\n    }\n\n    if (!name) {\n      name = paramCaseToCamelCase(option.name);\n    }\n\n    const hasDefaultValue: boolean = (!opts.ignoreDefaults ||\n      typeof opts.ignoreDefaults[name] === \"undefined\") &&\n      typeof ctx.flags[name] === \"undefined\" && (\n        typeof option.default !== \"undefined\" ||\n        typeof defaultValue !== \"undefined\"\n      );\n\n    if (hasDefaultValue) {\n      ctx.flags[name] = getDefaultValue(option) ?? defaultValue;\n      defaultValues[option.name] = true;\n      if (typeof option.value === \"function\") {\n        ctx.flags[name] = option.value(ctx.flags[name]);\n      }\n    }\n  }\n\n  return defaultValues;\n}\n\nfunction validateStandaloneOption(\n  ctx: ParseFlagsContext,\n  options: Map<string, FlagOptions>,\n  optionNames: Array<string>,\n  defaultValues: Record<string, boolean>,\n): void {\n  if (!ctx.standalone || optionNames.length === 1) {\n    return;\n  }\n\n  // Don't throw an error if all values are coming from the default option.\n  for (const [_, opt] of options) {\n    if (!defaultValues[opt.name] && opt !== ctx.standalone) {\n      throw new OptionNotCombinableError(ctx.standalone.name);\n    }\n  }\n}\n\nfunction validateConflictingOptions(\n  ctx: ParseFlagsContext<Record<string, unknown>>,\n  option: FlagOptions,\n): void {\n  if (!option.conflicts?.length) {\n    return;\n  }\n  for (const flag of option.conflicts) {\n    if (isset(flag, ctx.flags)) {\n      throw new ConflictingOptionError(option.name, flag);\n    }\n  }\n}\n\nfunction validateDependingOptions(\n  ctx: ParseFlagsContext<Record<string, unknown>>,\n  option: FlagOptions,\n  defaultValues: Record<string, boolean>,\n): void {\n  if (!option.depends) {\n    return;\n  }\n  for (const flag of option.depends) {\n    // Don't throw an error if the value is coming from the default option.\n    if (!isset(flag, ctx.flags) && !defaultValues[option.name]) {\n      throw new DependingOptionError(option.name, flag);\n    }\n  }\n}\n\nfunction validateRequiredValues(\n  ctx: ParseFlagsContext<Record<string, unknown>>,\n  option: FlagOptions,\n  name: string,\n): void {\n  if (!option.args) {\n    return;\n  }\n  const isArray = option.args.length > 1;\n\n  for (let i = 0; i < option.args.length; i++) {\n    const arg: ArgumentOptions = option.args[i];\n    if (!arg.requiredValue) {\n      continue;\n    }\n    const hasValue = isArray\n      ? typeof (ctx.flags[name] as Array<unknown>)[i] !== \"undefined\"\n      : typeof ctx.flags[name] !== \"undefined\";\n\n    if (!hasValue) {\n      throw new MissingOptionValueError(option.name);\n    }\n  }\n}\n\nfunction validateRequiredOptions<T extends FlagOptions = FlagOptions>(\n  ctx: ParseFlagsContext<Record<string, unknown>>,\n  options: Map<string, FlagOptions>,\n  opts: ParseFlagsOptions<T>,\n): void {\n  if (!opts.flags?.length) {\n    return;\n  }\n  const optionsValues = [...options.values()];\n\n  for (const option of opts.flags) {\n    if (!option.required || paramCaseToCamelCase(option.name) in ctx.flags) {\n      continue;\n    }\n    const conflicts = option.conflicts ?? [];\n    const hasConflict = conflicts.find((flag: string) => !!ctx.flags[flag]);\n    const hasConflicts = hasConflict ||\n      optionsValues.find((opt) =>\n        opt.conflicts?.find((flag: string) => flag === option.name)\n      );\n\n    if (hasConflicts) {\n      continue;\n    }\n    throw new MissingRequiredOptionError(option.name);\n  }\n}\n\n/**\n * Check if value exists for flag.\n * @param flagName  Flag name.\n * @param flags     Parsed values.\n */\nfunction isset(flagName: string, flags: Record<string, unknown>): boolean {\n  const name = paramCaseToCamelCase(flagName);\n  // return typeof values[ name ] !== 'undefined' && values[ name ] !== false;\n  return typeof flags[name] !== \"undefined\";\n}\n", "import type { ArgumentValue, TypeHandler } from \"../types.ts\";\nimport { InvalidTypeError } from \"../_errors.ts\";\n\n/** Integer type handler. Excepts any integer value. */\nexport const integer: TypeHandler<number> = (type: ArgumentValue): number => {\n  const value = Number(type.value);\n  if (Number.isInteger(value)) {\n    return value;\n  }\n\n  throw new InvalidTypeError(type);\n};\n", "import {\n  getDefaultValue,\n  getOption,\n  matchWildCardOptions,\n  paramCaseToCamelCase,\n} from \"./_utils.ts\";\nimport {\n  DuplicateOptionError,\n  InvalidOptionError,\n  InvalidOptionValueError,\n  MissingOptionValueError,\n  UnexpectedArgumentAfterVariadicArgumentError,\n  UnexpectedOptionValueError,\n  UnexpectedRequiredArgumentError,\n  UnknownConflictingOptionError,\n  UnknownOptionError,\n  UnknownRequiredOptionError,\n  UnknownTypeError,\n} from \"./_errors.ts\";\nimport { OptionType } from \"./deprecated.ts\";\nimport type {\n  ArgumentOptions,\n  ArgumentType,\n  FlagOptions,\n  ParseFlagsContext,\n  ParseFlagsOptions,\n  TypeHandler,\n} from \"./types.ts\";\nimport { boolean } from \"./types/boolean.ts\";\nimport { number } from \"./types/number.ts\";\nimport { string } from \"./types/string.ts\";\nimport { validateFlags } from \"./_validate_flags.ts\";\nimport { integer } from \"./types/integer.ts\";\n\nconst DefaultTypes: Record<ArgumentType, TypeHandler> = {\n  string,\n  number,\n  integer,\n  boolean,\n};\n\n/**\n * Parse command line arguments.\n * @param argsOrCtx Command line arguments e.g: `Deno.args` or parse context.\n * @param opts      Parse options.\n *\n * ```\n * // examples/flags/flags.ts -x 3 -y.z -n5 -abc --beep=boop foo bar baz --deno.land --deno.com -- --cliffy\n * parseFlags(Deno.args);\n * ```\n *\n * Output:\n *\n * ```\n * {\n *   flags: {\n *     x: \"3\",\n *     y: { z: true },\n *     n: \"5\",\n *     a: true,\n *     b: true,\n *     c: true,\n *     beep: \"boop\",\n *     deno: { land: true, com: true }\n *   },\n *   literal: [ \"--cliffy\" ],\n *   unknown: [ \"foo\", \"bar\", \"baz\" ],\n *   stopEarly: false,\n *   stopOnUnknown: false\n * }\n * ```\n */\nexport function parseFlags<\n  TFlags extends Record<string, unknown>,\n  TFlagOptions extends FlagOptions,\n  TFlagsResult extends ParseFlagsContext,\n>(\n  argsOrCtx: string[] | TFlagsResult,\n  opts: ParseFlagsOptions<TFlagOptions> = {},\n): TFlagsResult & ParseFlagsContext<TFlags, TFlagOptions> {\n  let args: Array<string>;\n  let ctx: ParseFlagsContext<Record<string, unknown>>;\n\n  if (Array.isArray(argsOrCtx)) {\n    ctx = {} as ParseFlagsContext<Record<string, unknown>>;\n    args = argsOrCtx;\n  } else {\n    ctx = argsOrCtx;\n    args = argsOrCtx.unknown;\n    argsOrCtx.unknown = [];\n  }\n  args = args.slice();\n\n  ctx.flags ??= {};\n  ctx.literal ??= [];\n  ctx.unknown ??= [];\n  ctx.stopEarly = false;\n  ctx.stopOnUnknown = false;\n\n  opts.dotted ??= true;\n\n  validateOptions(opts);\n  const options = parseArgs(ctx, args, opts);\n  validateFlags(ctx, opts, options);\n\n  if (opts.dotted) {\n    parseDottedOptions(ctx);\n  }\n\n  return ctx as TFlagsResult & ParseFlagsContext<TFlags, TFlagOptions>;\n}\n\nfunction validateOptions<TFlagOptions extends FlagOptions>(\n  opts: ParseFlagsOptions<TFlagOptions>,\n) {\n  opts.flags?.forEach((opt) => {\n    opt.depends?.forEach((flag) => {\n      if (!opts.flags || !getOption(opts.flags, flag)) {\n        throw new UnknownRequiredOptionError(flag, opts.flags ?? []);\n      }\n    });\n    opt.conflicts?.forEach((flag) => {\n      if (!opts.flags || !getOption(opts.flags, flag)) {\n        throw new UnknownConflictingOptionError(flag, opts.flags ?? []);\n      }\n    });\n  });\n}\n\nfunction parseArgs<TFlagOptions extends FlagOptions>(\n  ctx: ParseFlagsContext<Record<string, unknown>>,\n  args: Array<string>,\n  opts: ParseFlagsOptions<TFlagOptions>,\n): Map<string, FlagOptions> {\n  /** Option name mapping: propertyName -> option.name */\n  const optionsMap: Map<string, FlagOptions> = new Map();\n  let inLiteral = false;\n\n  for (\n    let argsIndex = 0;\n    argsIndex < args.length;\n    argsIndex++\n  ) {\n    let option: FlagOptions | undefined;\n    let current: string = args[argsIndex];\n    let currentValue: string | undefined;\n    let negate = false;\n\n    // literal args after --\n    if (inLiteral) {\n      ctx.literal.push(current);\n      continue;\n    } else if (current === \"--\") {\n      inLiteral = true;\n      continue;\n    } else if (ctx.stopEarly || ctx.stopOnUnknown) {\n      ctx.unknown.push(current);\n      continue;\n    }\n\n    const isFlag = current.length > 1 && current[0] === \"-\";\n\n    if (!isFlag) {\n      if (opts.stopEarly) {\n        ctx.stopEarly = true;\n      }\n      ctx.unknown.push(current);\n      continue;\n    }\n    const isShort = current[1] !== \"-\";\n    const isLong = isShort ? false : current.length > 3 && current[2] !== \"-\";\n\n    if (!isShort && !isLong) {\n      throw new InvalidOptionError(current, opts.flags ?? []);\n    }\n\n    // normalize short flags: -abc => -a -b -c\n    if (isShort && current.length > 2 && current[2] !== \".\") {\n      args.splice(argsIndex, 1, ...splitFlags(current));\n      current = args[argsIndex];\n    } else if (isLong && current.startsWith(\"--no-\")) {\n      negate = true;\n    }\n\n    // split value: --foo=\"bar=baz\" => --foo bar=baz\n    const equalSignIndex = current.indexOf(\"=\");\n    if (equalSignIndex !== -1) {\n      currentValue = current.slice(equalSignIndex + 1) || undefined;\n      current = current.slice(0, equalSignIndex);\n    }\n\n    if (opts.flags) {\n      option = getOption(opts.flags, current);\n\n      if (!option) {\n        const name = current.replace(/^-+/, \"\");\n        option = matchWildCardOptions(name, opts.flags);\n        if (!option) {\n          if (opts.stopOnUnknown) {\n            ctx.stopOnUnknown = true;\n            ctx.unknown.push(args[argsIndex]);\n            continue;\n          }\n          throw new UnknownOptionError(current, opts.flags);\n        }\n      }\n    } else {\n      option = {\n        name: current.replace(/^-+/, \"\"),\n        optionalValue: true,\n        type: OptionType.STRING,\n      };\n    }\n\n    if (option.standalone) {\n      ctx.standalone = option;\n    }\n\n    const positiveName: string = negate\n      ? option.name.replace(/^no-?/, \"\")\n      : option.name;\n    const propName: string = paramCaseToCamelCase(positiveName);\n\n    if (typeof ctx.flags[propName] !== \"undefined\") {\n      if (!opts.flags?.length) {\n        option.collect = true;\n      } else if (!option.collect) {\n        throw new DuplicateOptionError(current);\n      }\n    }\n\n    if (option.type && !option.args?.length) {\n      option.args = [{\n        type: option.type,\n        requiredValue: option.requiredValue,\n        optionalValue: option.optionalValue,\n        variadic: option.variadic,\n        list: option.list,\n        separator: option.separator,\n      }];\n    }\n\n    if (\n      opts.flags?.length && !option.args?.length &&\n      typeof currentValue !== \"undefined\"\n    ) {\n      throw new UnexpectedOptionValueError(option.name, currentValue);\n    }\n\n    let optionArgsIndex = 0;\n    let inOptionalArg = false;\n    const next = () => currentValue ?? args[argsIndex + 1];\n    const previous = ctx.flags[propName];\n\n    parseNext(option);\n\n    if (typeof ctx.flags[propName] === \"undefined\") {\n      if (option.args?.[optionArgsIndex]?.requiredValue) {\n        throw new MissingOptionValueError(option.name);\n      } else if (typeof option.default !== \"undefined\") {\n        ctx.flags[propName] = getDefaultValue(option);\n      } else {\n        ctx.flags[propName] = true;\n      }\n    }\n\n    if (option.value) {\n      ctx.flags[propName] = option.value(ctx.flags[propName], previous);\n    } else if (option.collect) {\n      const value: unknown[] = typeof previous !== \"undefined\"\n        ? (Array.isArray(previous) ? previous : [previous])\n        : [];\n\n      value.push(ctx.flags[propName]);\n      ctx.flags[propName] = value;\n    }\n\n    optionsMap.set(propName, option);\n\n    opts.option?.(option as TFlagOptions, ctx.flags[propName]);\n\n    /** Parse next argument for current option. */\n    // deno-lint-ignore no-inner-declarations\n    function parseNext(option: FlagOptions): void {\n      if (negate) {\n        ctx.flags[propName] = false;\n        return;\n      } else if (!option.args?.length) {\n        ctx.flags[propName] = undefined;\n        return;\n      }\n      const arg: ArgumentOptions | undefined = option.args[optionArgsIndex];\n\n      if (!arg) {\n        const flag = next();\n        throw new UnknownOptionError(flag, opts.flags ?? []);\n      }\n\n      if (!arg.type) {\n        arg.type = OptionType.BOOLEAN;\n      }\n\n      if (option.args?.length && !option.type) {\n        // make all values required by default\n        if (\n          (typeof arg.optionalValue === \"undefined\" ||\n            arg.optionalValue === false) &&\n          typeof arg.requiredValue === \"undefined\"\n        ) {\n          arg.requiredValue = true;\n        }\n      } else {\n        // make non boolean value required by default\n        if (\n          arg.type !== OptionType.BOOLEAN &&\n          (typeof arg.optionalValue === \"undefined\" ||\n            arg.optionalValue === false) &&\n          typeof arg.requiredValue === \"undefined\"\n        ) {\n          arg.requiredValue = true;\n        }\n      }\n\n      if (!arg.requiredValue) {\n        inOptionalArg = true;\n      } else if (inOptionalArg) {\n        throw new UnexpectedRequiredArgumentError(option.name);\n      }\n\n      let result: unknown;\n      let increase = false;\n\n      if (arg.list && hasNext(arg)) {\n        const parsed: unknown[] = next()\n          .split(arg.separator || \",\")\n          .map((nextValue: string) => {\n            const value = parseValue(option, arg, nextValue);\n            if (typeof value === \"undefined\") {\n              throw new InvalidOptionValueError(\n                option.name,\n                arg.type ?? \"?\",\n                nextValue,\n              );\n            }\n            return value;\n          });\n\n        if (parsed?.length) {\n          result = parsed;\n        }\n      } else {\n        if (hasNext(arg)) {\n          result = parseValue(option, arg, next());\n        } else if (arg.optionalValue && arg.type === OptionType.BOOLEAN) {\n          result = true;\n        }\n      }\n\n      if (increase && typeof currentValue === \"undefined\") {\n        argsIndex++;\n        if (!arg.variadic) {\n          optionArgsIndex++;\n        } else if (option.args[optionArgsIndex + 1]) {\n          throw new UnexpectedArgumentAfterVariadicArgumentError(next());\n        }\n      }\n\n      if (\n        typeof result !== \"undefined\" &&\n        (option.args.length > 1 || arg.variadic)\n      ) {\n        if (!ctx.flags[propName]) {\n          ctx.flags[propName] = [];\n        }\n\n        (ctx.flags[propName] as Array<unknown>).push(result);\n\n        if (hasNext(arg)) {\n          parseNext(option);\n        }\n      } else {\n        ctx.flags[propName] = result;\n      }\n\n      /** Check if current option should have an argument. */\n      function hasNext(arg: ArgumentOptions): boolean {\n        if (!option.args?.length) {\n          return false;\n        }\n        const nextValue = currentValue ?? args[argsIndex + 1];\n        if (!nextValue) {\n          return false;\n        }\n        if (option.args.length > 1 && optionArgsIndex >= option.args.length) {\n          return false;\n        }\n        if (arg.requiredValue) {\n          return true;\n        }\n        // require optional values to be called with an equal sign: foo=bar\n        if (\n          option.equalsSign && arg.optionalValue && !arg.variadic &&\n          typeof currentValue === \"undefined\"\n        ) {\n          return false;\n        }\n        if (arg.optionalValue || arg.variadic) {\n          return nextValue[0] !== \"-\" ||\n            typeof currentValue !== \"undefined\" ||\n            (arg.type === OptionType.NUMBER && !isNaN(Number(nextValue)));\n        }\n\n        return false;\n      }\n\n      /** Parse argument value.  */\n      function parseValue(\n        option: FlagOptions,\n        arg: ArgumentOptions,\n        value: string,\n      ): unknown {\n        const result: unknown = opts.parse\n          ? opts.parse({\n            label: \"Option\",\n            type: arg.type || OptionType.STRING,\n            name: `--${option.name}`,\n            value,\n          })\n          : parseDefaultType(option, arg, value);\n\n        if (\n          typeof result !== \"undefined\"\n        ) {\n          increase = true;\n        }\n\n        return result;\n      }\n    }\n  }\n\n  return optionsMap;\n}\n\nfunction parseDottedOptions(ctx: ParseFlagsContext): void {\n  // convert dotted option keys into nested objects\n  ctx.flags = Object.keys(ctx.flags).reduce(\n    (result: Record<string, unknown>, key: string) => {\n      if (~key.indexOf(\".\")) {\n        key.split(\".\").reduce(\n          (\n            // deno-lint-ignore no-explicit-any\n            result: Record<string, any>,\n            subKey: string,\n            index: number,\n            parts: string[],\n          ) => {\n            if (index === parts.length - 1) {\n              result[subKey] = ctx.flags[key];\n            } else {\n              result[subKey] = result[subKey] ?? {};\n            }\n            return result[subKey];\n          },\n          result,\n        );\n      } else {\n        result[key] = ctx.flags[key];\n      }\n      return result;\n    },\n    {},\n  );\n}\n\nfunction splitFlags(flag: string): Array<string> {\n  flag = flag.slice(1);\n  const normalized: Array<string> = [];\n  const index = flag.indexOf(\"=\");\n  const flags = (index !== -1 ? flag.slice(0, index) : flag).split(\"\");\n\n  if (isNaN(Number(flag[flag.length - 1]))) {\n    flags.forEach((val) => normalized.push(`-${val}`));\n  } else {\n    normalized.push(`-${flags.shift()}`);\n    if (flags.length) {\n      normalized.push(flags.join(\"\"));\n    }\n  }\n\n  if (index !== -1) {\n    normalized[normalized.length - 1] += flag.slice(index);\n  }\n\n  return normalized;\n}\n\nfunction parseDefaultType(\n  option: FlagOptions,\n  arg: ArgumentOptions,\n  value: string,\n): unknown {\n  const type: ArgumentType = arg.type as ArgumentType || OptionType.STRING;\n  const parseType = DefaultTypes[type];\n\n  if (!parseType) {\n    throw new UnknownTypeError(type, Object.keys(DefaultTypes));\n  }\n\n  return parseType({\n    label: \"Option\",\n    type,\n    name: `--${option.name}`,\n    value,\n  });\n}\n", "import type { Command } from \"./command.ts\";\nimport { TypeOrTypeHandler } from \"./types.ts\";\nimport type {\n  ArgumentValue,\n  CompleteHandlerResult,\n  ValuesHandlerResult,\n} from \"./types.ts\";\n\n/**\n * Base class for custom types.\n *\n * **Custom type example:**\n * ```\n * export class ColorType extends Type<string> {\n *   public parse({ label, name, value, type }: ArgumentValue): string {\n *     if ([\"red\", \"blue\"].includes(value)) {\n *       trow new Error(\n *         `${label} \"${name}\" must be of type \"${type}\", but got \"${value}\".` +\n *         \"Valid colors are: red, blue\"\n *       );\n *     }\n *     return value;\n *   }\n *\n *   public complete(): string[] {\n *     return [\"red\", \"blue\"];\n *   }\n * }\n * ```\n */\nexport abstract class Type<TValue> {\n  public abstract parse(type: ArgumentValue): TValue;\n\n  /**\n   * Returns values displayed in help text. If no complete method is provided,\n   * these values are also used for shell completions.\n   */\n  public values?(\n    cmd: Command,\n    parent?: Command,\n  ): ValuesHandlerResult;\n\n  /**\n   * Returns shell completion values. If no complete method is provided,\n   * values from the values method are used.\n   */\n  public complete?(\n    cmd: Command,\n    parent?: Command,\n  ): CompleteHandlerResult;\n}\n\n// deno-lint-ignore no-namespace\nexport namespace Type {\n  export type infer<TType, TDefault = TType> = TType extends\n    TypeOrTypeHandler<infer Value> ? Value : TDefault;\n}\n", "import { boolean } from \"../../flags/types/boolean.ts\";\nimport type { ArgumentValue } from \"../types.ts\";\nimport { Type } from \"../type.ts\";\n\n/** Boolean type with auto completion. Allows `true`, `false`, `0` and `1`. */\nexport class BooleanType extends Type<boolean> {\n  /** Parse boolean type. */\n  public parse(type: ArgumentValue): boolean {\n    return boolean(type);\n  }\n\n  /** Complete boolean type. */\n  public complete(): string[] {\n    return [\"true\", \"false\"];\n  }\n}\n", "import { string } from \"../../flags/types/string.ts\";\nimport { Type } from \"../type.ts\";\nimport type { ArgumentValue } from \"../types.ts\";\n\n/** String type. Allows any value. */\nexport class StringType extends Type<string> {\n  /** Complete string type. */\n  public parse(type: ArgumentValue): string {\n    return string(type);\n  }\n}\n", "import { StringType } from \"./string.ts\";\n\n// export interface FileTypeOptions {\n//   dirsOnly?: boolean;\n//   pattern?: string;\n//   ignore?: Array<string>;\n// }\n\n/** Integer type. */\nexport class FileType extends StringType {\n  constructor() {\n    super();\n  }\n\n  // getOptions(): FileTypeOptions {\n  //   return this.opts;\n  // }\n}\n", "import { number } from \"../../flags/types/number.ts\";\nimport { Type } from \"../type.ts\";\nimport type { ArgumentValue } from \"../types.ts\";\n\n/** Number type. */\nexport class NumberType extends Type<number> {\n  /** Parse number type. */\n  public parse(type: ArgumentValue): number {\n    return number(type);\n  }\n}\n", "/** Border characters interface. */\nexport interface IBorder {\n  top: string;\n  topMid: string;\n  topLeft: string;\n  topRight: string;\n  bottom: string;\n  bottomMid: string;\n  bottomLeft: string;\n  bottomRight: string;\n  left: string;\n  leftMid: string;\n  mid: string;\n  midMid: string;\n  right: string;\n  rightMid: string;\n  middle: string;\n}\n\n/** Default border characters. */\nexport const border: IBorder = {\n  top: \"\u2500\",\n  topMid: \"\u252C\",\n  topLeft: \"\u250C\",\n  topRight: \"\u2510\",\n  bottom: \"\u2500\",\n  bottomMid: \"\u2534\",\n  bottomLeft: \"\u2514\",\n  bottomRight: \"\u2518\",\n  left: \"\u2502\",\n  leftMid: \"\u251C\",\n  mid: \"\u2500\",\n  midMid: \"\u253C\",\n  right: \"\u2502\",\n  rightMid: \"\u2524\",\n  middle: \"\u2502\",\n};\n", "/** Cell type */\n// deno-lint-ignore ban-types\nexport type ICell = number | string | String | Cell;\n\nexport type Direction = \"left\" | \"right\" | \"center\";\n\n/** Cell options. */\nexport interface ICellOptions {\n  border?: boolean;\n  colSpan?: number;\n  rowSpan?: number;\n  align?: Direction;\n}\n\n/** Cell representation. */\nexport class Cell {\n  protected options: ICellOptions = {};\n\n  /** Get cell length. */\n  public get length(): number {\n    return this.toString().length;\n  }\n\n  /**\n   * Create a new cell. If value is a cell, the value and all options of the cell\n   * will be copied to the new cell.\n   * @param value Cell or cell value.\n   */\n  public static from(value: ICell): Cell {\n    const cell = new this(value);\n    if (value instanceof Cell) {\n      cell.options = { ...value.options };\n    }\n    return cell;\n  }\n\n  /**\n   * Cell constructor.\n   * @param value Cell value.\n   */\n  public constructor(private value: ICell) {}\n\n  /** Get cell value. */\n  public toString(): string {\n    return this.value.toString();\n  }\n\n  /**\n   * Set cell value.\n   * @param value Cell or cell value.\n   */\n  public setValue(value: ICell): this {\n    this.value = value;\n    return this;\n  }\n\n  /**\n   * Clone cell with all options.\n   * @param value Cell or cell value.\n   */\n  public clone(value?: ICell): Cell {\n    const cell = new Cell(value ?? this);\n    cell.options = { ...this.options };\n    return cell;\n  }\n\n  /**\n   * Setter:\n   */\n\n  /**\n   * Enable/disable cell border.\n   * @param enable    Enable/disable cell border.\n   * @param override  Override existing value.\n   */\n  public border(enable: boolean, override = true): this {\n    if (override || typeof this.options.border === \"undefined\") {\n      this.options.border = enable;\n    }\n    return this;\n  }\n\n  /**\n   * Set col span.\n   * @param span      Number of cols to span.\n   * @param override  Override existing value.\n   */\n  public colSpan(span: number, override = true): this {\n    if (override || typeof this.options.colSpan === \"undefined\") {\n      this.options.colSpan = span;\n    }\n    return this;\n  }\n\n  /**\n   * Set row span.\n   * @param span      Number of rows to span.\n   * @param override  Override existing value.\n   */\n  public rowSpan(span: number, override = true): this {\n    if (override || typeof this.options.rowSpan === \"undefined\") {\n      this.options.rowSpan = span;\n    }\n    return this;\n  }\n\n  /**\n   * Align cell content.\n   * @param direction Align direction.\n   * @param override  Override existing value.\n   */\n  public align(direction: Direction, override = true): this {\n    if (override || typeof this.options.align === \"undefined\") {\n      this.options.align = direction;\n    }\n    return this;\n  }\n\n  /**\n   * Getter:\n   */\n\n  /** Check if cell has border. */\n  public getBorder(): boolean {\n    return this.options.border === true;\n  }\n\n  /** Get col span. */\n  public getColSpan(): number {\n    return typeof this.options.colSpan === \"number\" && this.options.colSpan > 0\n      ? this.options.colSpan\n      : 1;\n  }\n\n  /** Get row span. */\n  public getRowSpan(): number {\n    return typeof this.options.rowSpan === \"number\" && this.options.rowSpan > 0\n      ? this.options.rowSpan\n      : 1;\n  }\n\n  /** Get row span. */\n  public getAlign(): Direction {\n    return this.options.align ?? \"left\";\n  }\n}\n", "import { Cell, Direction, ICell } from \"./cell.ts\";\n\n/** Row type */\nexport type IRow<T extends ICell | undefined = ICell | undefined> =\n  | T[]\n  | Row<T>;\n/** Json row. */\nexport type IDataRow = Record<string, string | number>;\n\n/** Row options. */\nexport interface IRowOptions {\n  indent?: number;\n  border?: boolean;\n  align?: Direction;\n}\n\n/**\n * Row representation.\n */\nexport class Row<T extends ICell | undefined = ICell | undefined>\n  extends Array<T> {\n  protected options: IRowOptions = {};\n\n  /**\n   * Create a new row. If cells is a row, all cells and options of the row will\n   * be copied to the new row.\n   * @param cells Cells or row.\n   */\n  public static from<T extends ICell | undefined>(\n    cells: IRow<T>,\n  ): Row<T> {\n    const row = new this(...cells);\n    if (cells instanceof Row) {\n      row.options = { ...(cells as Row).options };\n    }\n    return row;\n  }\n\n  /** Clone row recursively with all options. */\n  public clone(): Row {\n    const row = new Row(\n      ...this.map((cell: T) => cell instanceof Cell ? cell.clone() : cell),\n    );\n    row.options = { ...this.options };\n    return row;\n  }\n\n  /**\n   * Setter:\n   */\n\n  /**\n   * Enable/disable cell border.\n   * @param enable    Enable/disable cell border.\n   * @param override  Override existing value.\n   */\n  public border(enable: boolean, override = true): this {\n    if (override || typeof this.options.border === \"undefined\") {\n      this.options.border = enable;\n    }\n    return this;\n  }\n\n  /**\n   * Align row content.\n   * @param direction Align direction.\n   * @param override  Override existing value.\n   */\n  public align(direction: Direction, override = true): this {\n    if (override || typeof this.options.align === \"undefined\") {\n      this.options.align = direction;\n    }\n    return this;\n  }\n\n  /**\n   * Getter:\n   */\n\n  /** Check if row has border. */\n  public getBorder(): boolean {\n    return this.options.border === true;\n  }\n\n  /** Check if row or any child cell has border. */\n  public hasBorder(): boolean {\n    return this.getBorder() ||\n      this.some((cell) => cell instanceof Cell && cell.getBorder());\n  }\n\n  /** Get row alignment. */\n  public getAlign(): Direction {\n    return this.options.align ?? \"left\";\n  }\n}\n", "/**\n * Get next words from the beginning of [content] until all words have a length lower or equal then [length].\n *\n * @param length    Max length of all words.\n * @param content   The text content.\n */\nimport { Cell, ICell } from \"./cell.ts\";\nimport { stripColor } from \"./deps.ts\";\n\nexport function consumeWords(length: number, content: string): string {\n  let consumed = \"\";\n  const words: string[] = content.split(\"\\n\")[0]?.split(/ /g);\n\n  for (let i = 0; i < words.length; i++) {\n    const word: string = words[i];\n\n    // consume minimum one word\n    if (consumed) {\n      const nextLength = strLength(word);\n      const consumedLength = strLength(consumed);\n      if (consumedLength + nextLength >= length) {\n        break;\n      }\n    }\n\n    consumed += (i > 0 ? \" \" : \"\") + word;\n  }\n\n  return consumed;\n}\n\n/**\n * Get longest cell from given row index.\n */\nexport function longest(\n  index: number,\n  rows: ICell[][],\n  maxWidth?: number,\n): number {\n  const cellLengths = rows.map((row) => {\n    const cell = row[index];\n    const cellValue = cell instanceof Cell && cell.getColSpan() > 1\n      ? \"\"\n      : cell?.toString() || \"\";\n\n    return cellValue\n      .split(\"\\n\")\n      .map((line: string) => {\n        const str = typeof maxWidth === \"undefined\"\n          ? line\n          : consumeWords(maxWidth, line);\n\n        return strLength(str) || 0;\n      });\n  }).flat();\n\n  return Math.max(...cellLengths);\n}\n\nexport const strLength = (str: string): number => {\n  str = stripColor(str);\n  let length = 0;\n  for (let i = 0; i < str.length; i++) {\n    const charCode = str.charCodeAt(i);\n    // Check for chinese characters: \\u4e00 - \\u9fa5\n    if (charCode >= 19968 && charCode <= 40869) {\n      length += 2;\n    } else {\n      length += 1;\n    }\n  }\n  return length;\n};\n", "import { Cell, Direction, ICell } from \"./cell.ts\";\nimport { IRow, Row } from \"./row.ts\";\nimport type { IBorderOptions, ITableSettings, Table } from \"./table.ts\";\nimport { consumeWords, longest, strLength } from \"./utils.ts\";\n\n/** Layout render settings. */\ninterface IRenderSettings {\n  padding: number[];\n  width: number[];\n  columns: number;\n  hasBorder: boolean;\n  hasHeaderBorder: boolean;\n  hasBodyBorder: boolean;\n  rows: Row<Cell>[];\n}\n\n/** Table layout renderer. */\nexport class TableLayout {\n  /**\n   * Table layout constructor.\n   * @param table   Table instance.\n   * @param options Render options.\n   */\n  public constructor(\n    private table: Table,\n    private options: ITableSettings,\n  ) {}\n\n  /** Generate table string. */\n  public toString(): string {\n    const opts: IRenderSettings = this.createLayout();\n    return opts.rows.length ? this.renderRows(opts) : \"\";\n  }\n\n  /**\n   * Generates table layout including row and col span, converts all none\n   * Cell/Row values to Cells and Rows and returns the layout rendering\n   * settings.\n   */\n  protected createLayout(): IRenderSettings {\n    Object.keys(this.options.chars).forEach((key: string) => {\n      if (typeof this.options.chars[key as keyof IBorderOptions] !== \"string\") {\n        this.options.chars[key as keyof IBorderOptions] = \"\";\n      }\n    });\n\n    const hasBodyBorder: boolean = this.table.getBorder() ||\n      this.table.hasBodyBorder();\n    const hasHeaderBorder: boolean = this.table.hasHeaderBorder();\n    const hasBorder: boolean = hasHeaderBorder || hasBodyBorder;\n\n    const rows = this.#getRows();\n\n    const columns: number = Math.max(...rows.map((row) => row.length));\n    for (const row of rows) {\n      const length: number = row.length;\n      if (length < columns) {\n        const diff = columns - length;\n        for (let i = 0; i < diff; i++) {\n          row.push(this.createCell(null, row));\n        }\n      }\n    }\n\n    const padding: number[] = [];\n    const width: number[] = [];\n    for (let colIndex = 0; colIndex < columns; colIndex++) {\n      const minColWidth: number = Array.isArray(this.options.minColWidth)\n        ? this.options.minColWidth[colIndex]\n        : this.options.minColWidth;\n      const maxColWidth: number = Array.isArray(this.options.maxColWidth)\n        ? this.options.maxColWidth[colIndex]\n        : this.options.maxColWidth;\n      const colWidth: number = longest(colIndex, rows, maxColWidth);\n      width[colIndex] = Math.min(maxColWidth, Math.max(minColWidth, colWidth));\n      padding[colIndex] = Array.isArray(this.options.padding)\n        ? this.options.padding[colIndex]\n        : this.options.padding;\n    }\n\n    return {\n      padding,\n      width,\n      rows,\n      columns,\n      hasBorder,\n      hasBodyBorder,\n      hasHeaderBorder,\n    };\n  }\n\n  #getRows(): Array<Row<Cell>> {\n    const header: Row | undefined = this.table.getHeader();\n    const rows = header ? [header, ...this.table] : this.table.slice();\n    const hasSpan = rows.some((row) =>\n      row.some((cell) =>\n        cell instanceof Cell && (cell.getColSpan() > 1 || cell.getRowSpan() > 1)\n      )\n    );\n\n    if (hasSpan) {\n      return this.spanRows(rows);\n    }\n\n    return rows.map((row) => {\n      const newRow = this.createRow(row);\n      for (let i = 0; i < row.length; i++) {\n        newRow[i] = this.createCell(row[i], newRow);\n      }\n      return newRow;\n    });\n  }\n\n  /**\n   * Fills rows and cols by specified row/col span with a reference of the\n   * original cell.\n   */\n  protected spanRows(rows: Array<IRow>) {\n    const rowSpan: Array<number> = [];\n    let colSpan = 1;\n    let rowIndex = -1;\n\n    while (true) {\n      rowIndex++;\n      if (rowIndex === rows.length && rowSpan.every((span) => span === 1)) {\n        break;\n      }\n      const row = rows[rowIndex] = this.createRow(rows[rowIndex] || []);\n      let colIndex = -1;\n\n      while (true) {\n        colIndex++;\n        if (\n          colIndex === row.length &&\n          colIndex === rowSpan.length && colSpan === 1\n        ) {\n          break;\n        }\n\n        if (colSpan > 1) {\n          colSpan--;\n          rowSpan[colIndex] = rowSpan[colIndex - 1];\n          row.splice(\n            colIndex,\n            this.getDeleteCount(rows, rowIndex, colIndex),\n            row[colIndex - 1],\n          );\n\n          continue;\n        }\n\n        if (rowSpan[colIndex] > 1) {\n          rowSpan[colIndex]--;\n          rows[rowIndex].splice(\n            colIndex,\n            this.getDeleteCount(rows, rowIndex, colIndex),\n            rows[rowIndex - 1][colIndex],\n          );\n\n          continue;\n        }\n\n        const cell = row[colIndex] = this.createCell(\n          row[colIndex] || null,\n          row,\n        );\n\n        colSpan = cell.getColSpan();\n        rowSpan[colIndex] = cell.getRowSpan();\n      }\n    }\n\n    return rows as Array<Row<Cell>>;\n  }\n\n  protected getDeleteCount(\n    rows: Array<Array<unknown>>,\n    rowIndex: number,\n    colIndex: number,\n  ) {\n    return colIndex <= rows[rowIndex].length - 1 &&\n        typeof rows[rowIndex][colIndex] === \"undefined\"\n      ? 1\n      : 0;\n  }\n\n  /**\n   * Create a new row from existing row or cell array.\n   * @param row Original row.\n   */\n  protected createRow(row: IRow): Row<Cell> {\n    return Row.from(row)\n      .border(this.table.getBorder(), false)\n      .align(this.table.getAlign(), false) as Row<Cell>;\n  }\n\n  /**\n   * Create a new cell from existing cell or cell value.\n   * @param cell  Original cell.\n   * @param row   Parent row.\n   */\n  protected createCell(cell: ICell | null | undefined, row: Row): Cell {\n    return Cell.from(cell ?? \"\")\n      .border(row.getBorder(), false)\n      .align(row.getAlign(), false);\n  }\n\n  /**\n   * Render table layout.\n   * @param opts Render options.\n   */\n  protected renderRows(opts: IRenderSettings): string {\n    let result = \"\";\n    const rowSpan: number[] = new Array(opts.columns).fill(1);\n\n    for (let rowIndex = 0; rowIndex < opts.rows.length; rowIndex++) {\n      result += this.renderRow(rowSpan, rowIndex, opts);\n    }\n\n    return result.slice(0, -1);\n  }\n\n  /**\n   * Render row.\n   * @param rowSpan     Current row span.\n   * @param rowIndex    Current row index.\n   * @param opts        Render options.\n   * @param isMultiline Is multiline row.\n   */\n  protected renderRow(\n    rowSpan: number[],\n    rowIndex: number,\n    opts: IRenderSettings,\n    isMultiline?: boolean,\n  ): string {\n    const row: Row<Cell> = opts.rows[rowIndex];\n    const prevRow: Row<Cell> | undefined = opts.rows[rowIndex - 1];\n    const nextRow: Row<Cell> | undefined = opts.rows[rowIndex + 1];\n    let result = \"\";\n\n    let colSpan = 1;\n\n    // border top row\n    if (!isMultiline && rowIndex === 0 && row.hasBorder()) {\n      result += this.renderBorderRow(undefined, row, rowSpan, opts);\n    }\n\n    let isMultilineRow = false;\n\n    result += \" \".repeat(this.options.indent || 0);\n\n    for (let colIndex = 0; colIndex < opts.columns; colIndex++) {\n      if (colSpan > 1) {\n        colSpan--;\n        rowSpan[colIndex] = rowSpan[colIndex - 1];\n        continue;\n      }\n\n      result += this.renderCell(colIndex, row, opts);\n\n      if (rowSpan[colIndex] > 1) {\n        if (!isMultiline) {\n          rowSpan[colIndex]--;\n        }\n      } else if (!prevRow || prevRow[colIndex] !== row[colIndex]) {\n        rowSpan[colIndex] = row[colIndex].getRowSpan();\n      }\n\n      colSpan = row[colIndex].getColSpan();\n\n      if (rowSpan[colIndex] === 1 && row[colIndex].length) {\n        isMultilineRow = true;\n      }\n    }\n\n    if (opts.columns > 0) {\n      if (row[opts.columns - 1].getBorder()) {\n        result += this.options.chars.right;\n      } else if (opts.hasBorder) {\n        result += \" \";\n      }\n    }\n\n    result += \"\\n\";\n\n    if (isMultilineRow) { // skip border\n      return result + this.renderRow(rowSpan, rowIndex, opts, isMultilineRow);\n    }\n\n    // border mid row\n    if (\n      (rowIndex === 0 && opts.hasHeaderBorder) ||\n      (rowIndex < opts.rows.length - 1 && opts.hasBodyBorder)\n    ) {\n      result += this.renderBorderRow(row, nextRow, rowSpan, opts);\n    }\n\n    // border bottom row\n    if (rowIndex === opts.rows.length - 1 && row.hasBorder()) {\n      result += this.renderBorderRow(row, undefined, rowSpan, opts);\n    }\n\n    return result;\n  }\n\n  /**\n   * Render cell.\n   * @param colIndex  Current col index.\n   * @param row       Current row.\n   * @param opts      Render options.\n   * @param noBorder  Disable border.\n   */\n  protected renderCell(\n    colIndex: number,\n    row: Row<Cell>,\n    opts: IRenderSettings,\n    noBorder?: boolean,\n  ): string {\n    let result = \"\";\n    const prevCell: Cell | undefined = row[colIndex - 1];\n\n    const cell: Cell = row[colIndex];\n\n    if (!noBorder) {\n      if (colIndex === 0) {\n        if (cell.getBorder()) {\n          result += this.options.chars.left;\n        } else if (opts.hasBorder) {\n          result += \" \";\n        }\n      } else {\n        if (cell.getBorder() || prevCell?.getBorder()) {\n          result += this.options.chars.middle;\n        } else if (opts.hasBorder) {\n          result += \" \";\n        }\n      }\n    }\n\n    let maxLength: number = opts.width[colIndex];\n\n    const colSpan: number = cell.getColSpan();\n    if (colSpan > 1) {\n      for (let o = 1; o < colSpan; o++) {\n        // add padding and with of next cell\n        maxLength += opts.width[colIndex + o] + opts.padding[colIndex + o];\n        if (opts.hasBorder) {\n          // add padding again and border with\n          maxLength += opts.padding[colIndex + o] + 1;\n        }\n      }\n    }\n\n    const { current, next } = this.renderCellValue(cell, maxLength);\n\n    row[colIndex].setValue(next);\n\n    if (opts.hasBorder) {\n      result += \" \".repeat(opts.padding[colIndex]);\n    }\n\n    result += current;\n\n    if (opts.hasBorder || colIndex < opts.columns - 1) {\n      result += \" \".repeat(opts.padding[colIndex]);\n    }\n\n    return result;\n  }\n\n  /**\n   * Render specified length of cell. Returns the rendered value and a new cell\n   * with the rest value.\n   * @param cell      Cell to render.\n   * @param maxLength Max length of content to render.\n   */\n  protected renderCellValue(\n    cell: Cell,\n    maxLength: number,\n  ): { current: string; next: Cell } {\n    const length: number = Math.min(\n      maxLength,\n      strLength(cell.toString()),\n    );\n    let words: string = consumeWords(length, cell.toString());\n\n    // break word if word is longer than max length\n    const breakWord = strLength(words) > length;\n    if (breakWord) {\n      words = words.slice(0, length);\n    }\n\n    // get next content and remove leading space if breakWord is not true\n    const next = cell.toString().slice(words.length + (breakWord ? 0 : 1));\n    const fillLength = maxLength - strLength(words);\n\n    // Align content\n    const align: Direction = cell.getAlign();\n    let current: string;\n    if (fillLength === 0) {\n      current = words;\n    } else if (align === \"left\") {\n      current = words + \" \".repeat(fillLength);\n    } else if (align === \"center\") {\n      current = \" \".repeat(Math.floor(fillLength / 2)) + words +\n        \" \".repeat(Math.ceil(fillLength / 2));\n    } else if (align === \"right\") {\n      current = \" \".repeat(fillLength) + words;\n    } else {\n      throw new Error(\"Unknown direction: \" + align);\n    }\n\n    return {\n      current,\n      next: cell.clone(next),\n    };\n  }\n\n  /**\n   * Render border row.\n   * @param prevRow Previous row.\n   * @param nextRow Next row.\n   * @param rowSpan Current row span.\n   * @param opts    Render options.\n   */\n  protected renderBorderRow(\n    prevRow: Row<Cell> | undefined,\n    nextRow: Row<Cell> | undefined,\n    rowSpan: number[],\n    opts: IRenderSettings,\n  ): string {\n    let result = \"\";\n\n    let colSpan = 1;\n    for (let colIndex = 0; colIndex < opts.columns; colIndex++) {\n      if (rowSpan[colIndex] > 1) {\n        if (!nextRow) {\n          throw new Error(\"invalid layout\");\n        }\n        if (colSpan > 1) {\n          colSpan--;\n          continue;\n        }\n      }\n      result += this.renderBorderCell(\n        colIndex,\n        prevRow,\n        nextRow,\n        rowSpan,\n        opts,\n      );\n      colSpan = nextRow?.[colIndex].getColSpan() ?? 1;\n    }\n\n    return result.length ? \" \".repeat(this.options.indent) + result + \"\\n\" : \"\";\n  }\n\n  /**\n   * Render border cell.\n   * @param colIndex  Current index.\n   * @param prevRow   Previous row.\n   * @param nextRow   Next row.\n   * @param rowSpan   Current row span.\n   * @param opts      Render options.\n   */\n  protected renderBorderCell(\n    colIndex: number,\n    prevRow: Row<Cell> | undefined,\n    nextRow: Row<Cell> | undefined,\n    rowSpan: number[],\n    opts: IRenderSettings,\n  ): string {\n    // a1 | b1\n    // -------\n    // a2 | b2\n\n    const a1: Cell | undefined = prevRow?.[colIndex - 1];\n    const a2: Cell | undefined = nextRow?.[colIndex - 1];\n    const b1: Cell | undefined = prevRow?.[colIndex];\n    const b2: Cell | undefined = nextRow?.[colIndex];\n\n    const a1Border = !!a1?.getBorder();\n    const a2Border = !!a2?.getBorder();\n    const b1Border = !!b1?.getBorder();\n    const b2Border = !!b2?.getBorder();\n\n    const hasColSpan = (cell: Cell | undefined): boolean =>\n      (cell?.getColSpan() ?? 1) > 1;\n    const hasRowSpan = (cell: Cell | undefined): boolean =>\n      (cell?.getRowSpan() ?? 1) > 1;\n\n    let result = \"\";\n\n    if (colIndex === 0) {\n      if (rowSpan[colIndex] > 1) {\n        if (b1Border) {\n          result += this.options.chars.left;\n        } else {\n          result += \" \";\n        }\n      } else if (b1Border && b2Border) {\n        result += this.options.chars.leftMid;\n      } else if (b1Border) {\n        result += this.options.chars.bottomLeft;\n      } else if (b2Border) {\n        result += this.options.chars.topLeft;\n      } else {\n        result += \" \";\n      }\n    } else if (colIndex < opts.columns) {\n      if ((a1Border && b2Border) || (b1Border && a2Border)) {\n        const a1ColSpan: boolean = hasColSpan(a1);\n        const a2ColSpan: boolean = hasColSpan(a2);\n        const b1ColSpan: boolean = hasColSpan(b1);\n        const b2ColSpan: boolean = hasColSpan(b2);\n\n        const a1RowSpan: boolean = hasRowSpan(a1);\n        const a2RowSpan: boolean = hasRowSpan(a2);\n        const b1RowSpan: boolean = hasRowSpan(b1);\n        const b2RowSpan: boolean = hasRowSpan(b2);\n\n        const hasAllBorder = a1Border && b2Border && b1Border && a2Border;\n        const hasAllRowSpan = a1RowSpan && b1RowSpan && a2RowSpan && b2RowSpan;\n        const hasAllColSpan = a1ColSpan && b1ColSpan && a2ColSpan && b2ColSpan;\n\n        if (hasAllRowSpan && hasAllBorder) {\n          result += this.options.chars.middle;\n        } else if (hasAllColSpan && hasAllBorder && a1 === b1 && a2 === b2) {\n          result += this.options.chars.mid;\n        } else if (a1ColSpan && b1ColSpan && a1 === b1) {\n          result += this.options.chars.topMid;\n        } else if (a2ColSpan && b2ColSpan && a2 === b2) {\n          result += this.options.chars.bottomMid;\n        } else if (a1RowSpan && a2RowSpan && a1 === a2) {\n          result += this.options.chars.leftMid;\n        } else if (b1RowSpan && b2RowSpan && b1 === b2) {\n          result += this.options.chars.rightMid;\n        } else {\n          result += this.options.chars.midMid;\n        }\n      } else if (a1Border && b1Border) {\n        if (hasColSpan(a1) && hasColSpan(b1) && a1 === b1) {\n          result += this.options.chars.bottom;\n        } else {\n          result += this.options.chars.bottomMid;\n        }\n      } else if (b1Border && b2Border) {\n        if (rowSpan[colIndex] > 1) {\n          result += this.options.chars.left;\n        } else {\n          result += this.options.chars.leftMid;\n        }\n      } else if (b2Border && a2Border) {\n        if (hasColSpan(a2) && hasColSpan(b2) && a2 === b2) {\n          result += this.options.chars.top;\n        } else {\n          result += this.options.chars.topMid;\n        }\n      } else if (a1Border && a2Border) {\n        if (hasRowSpan(a1) && a1 === a2) {\n          result += this.options.chars.right;\n        } else {\n          result += this.options.chars.rightMid;\n        }\n      } else if (a1Border) {\n        result += this.options.chars.bottomRight;\n      } else if (b1Border) {\n        result += this.options.chars.bottomLeft;\n      } else if (a2Border) {\n        result += this.options.chars.topRight;\n      } else if (b2Border) {\n        result += this.options.chars.topLeft;\n      } else {\n        result += \" \";\n      }\n    }\n\n    const length = opts.padding[colIndex] + opts.width[colIndex] +\n      opts.padding[colIndex];\n\n    if (rowSpan[colIndex] > 1 && nextRow) {\n      result += this.renderCell(\n        colIndex,\n        nextRow,\n        opts,\n        true,\n      );\n      if (nextRow[colIndex] === nextRow[nextRow.length - 1]) {\n        if (b1Border) {\n          result += this.options.chars.right;\n        } else {\n          result += \" \";\n        }\n        return result;\n      }\n    } else if (b1Border && b2Border) {\n      result += this.options.chars.mid.repeat(length);\n    } else if (b1Border) {\n      result += this.options.chars.bottom.repeat(length);\n    } else if (b2Border) {\n      result += this.options.chars.top.repeat(length);\n    } else {\n      result += \" \".repeat(length);\n    }\n\n    if (colIndex === opts.columns - 1) {\n      if (b1Border && b2Border) {\n        result += this.options.chars.rightMid;\n      } else if (b1Border) {\n        result += this.options.chars.bottomRight;\n      } else if (b2Border) {\n        result += this.options.chars.topRight;\n      } else {\n        result += \" \";\n      }\n    }\n\n    return result;\n  }\n}\n", "import { border, IBorder } from \"./border.ts\";\nimport { Cell, Direction } from \"./cell.ts\";\nimport { TableLayout } from \"./layout.ts\";\nimport { IDataRow, IRow, Row } from \"./row.ts\";\n\n/** Border characters settings. */\nexport type IBorderOptions = Partial<IBorder>;\n\n/** Table options. */\nexport interface ITableOptions {\n  indent?: number;\n  border?: boolean;\n  align?: Direction;\n  maxColWidth?: number | number[];\n  minColWidth?: number | number[];\n  padding?: number | number[];\n  chars?: IBorderOptions;\n}\n\n/** Table settings. */\nexport interface ITableSettings extends Required<Omit<ITableOptions, \"align\">> {\n  chars: IBorder;\n  align?: Direction;\n}\n\n/** Table type. */\nexport type ITable<T extends IRow = IRow> = T[] | Table<T>;\n\n/** Table representation. */\nexport class Table<T extends IRow = IRow> extends Array<T> {\n  protected static _chars: IBorder = { ...border };\n  protected options: ITableSettings = {\n    indent: 0,\n    border: false,\n    maxColWidth: Infinity,\n    minColWidth: 0,\n    padding: 1,\n    chars: { ...Table._chars },\n  };\n  private headerRow?: Row;\n\n  /**\n   * Create a new table. If rows is a table, all rows and options of the table\n   * will be copied to the new table.\n   * @param rows\n   */\n  public static from<T extends IRow>(rows: ITable<T>): Table<T> {\n    const table = new this(...rows);\n    if (rows instanceof Table) {\n      table.options = { ...(rows as Table).options };\n      table.headerRow = rows.headerRow ? Row.from(rows.headerRow) : undefined;\n    }\n    return table;\n  }\n\n  /**\n   * Create a new table from an array of json objects. An object represents a\n   * row and each property a column.\n   * @param rows Array of objects.\n   */\n  public static fromJson(rows: IDataRow[]): Table {\n    return new this().fromJson(rows);\n  }\n\n  /**\n   * Set global default border characters.\n   * @param chars Border options.\n   */\n  public static chars(chars: IBorderOptions): typeof Table {\n    Object.assign(this._chars, chars);\n    return this;\n  }\n\n  /**\n   * Write table or rows to stdout.\n   * @param rows Table or rows.\n   */\n  public static render<T extends IRow>(rows: ITable<T>): void {\n    Table.from(rows).render();\n  }\n\n  /**\n   * Read data from an array of json objects. An object represents a\n   * row and each property a column.\n   * @param rows Array of objects.\n   */\n  public fromJson(rows: IDataRow[]): this {\n    this.header(Object.keys(rows[0]));\n    this.body(rows.map((row) => Object.values(row) as T));\n    return this;\n  }\n\n  /**\n   * Set table header.\n   * @param header Header row or cells.\n   */\n  public header(header: IRow): this {\n    this.headerRow = header instanceof Row ? header : Row.from(header);\n    return this;\n  }\n\n  /**\n   * Set table body.\n   * @param rows Table rows.\n   */\n  public body(rows: T[]): this {\n    this.length = 0;\n    this.push(...rows);\n    return this;\n  }\n\n  /** Clone table recursively with header and options. */\n  public clone(): Table {\n    const table = new Table(\n      ...this.map((row: T) =>\n        row instanceof Row ? row.clone() : Row.from(row).clone()\n      ),\n    );\n    table.options = { ...this.options };\n    table.headerRow = this.headerRow?.clone();\n    return table;\n  }\n\n  /** Generate table string. */\n  public toString(): string {\n    return new TableLayout(this, this.options).toString();\n  }\n\n  /** Write table to stdout. */\n  public render(): this {\n    console.log(this.toString());\n    return this;\n  }\n\n  /**\n   * Set max col with.\n   * @param width     Max col width.\n   * @param override  Override existing value.\n   */\n  public maxColWidth(width: number | number[], override = true): this {\n    if (override || typeof this.options.maxColWidth === \"undefined\") {\n      this.options.maxColWidth = width;\n    }\n    return this;\n  }\n\n  /**\n   * Set min col width.\n   * @param width     Min col width.\n   * @param override  Override existing value.\n   */\n  public minColWidth(width: number | number[], override = true): this {\n    if (override || typeof this.options.minColWidth === \"undefined\") {\n      this.options.minColWidth = width;\n    }\n    return this;\n  }\n\n  /**\n   * Set table indentation.\n   * @param width     Indent width.\n   * @param override  Override existing value.\n   */\n  public indent(width: number, override = true): this {\n    if (override || typeof this.options.indent === \"undefined\") {\n      this.options.indent = width;\n    }\n    return this;\n  }\n\n  /**\n   * Set cell padding.\n   * @param padding   Cell padding.\n   * @param override  Override existing value.\n   */\n  public padding(padding: number | number[], override = true): this {\n    if (override || typeof this.options.padding === \"undefined\") {\n      this.options.padding = padding;\n    }\n    return this;\n  }\n\n  /**\n   * Enable/disable cell border.\n   * @param enable    Enable/disable cell border.\n   * @param override  Override existing value.\n   */\n  public border(enable: boolean, override = true): this {\n    if (override || typeof this.options.border === \"undefined\") {\n      this.options.border = enable;\n    }\n    return this;\n  }\n\n  /**\n   * Align table content.\n   * @param direction Align direction.\n   * @param override  Override existing value.\n   */\n  public align(direction: Direction, override = true): this {\n    if (override || typeof this.options.align === \"undefined\") {\n      this.options.align = direction;\n    }\n    return this;\n  }\n\n  /**\n   * Set border characters.\n   * @param chars Border options.\n   */\n  public chars(chars: IBorderOptions): this {\n    Object.assign(this.options.chars, chars);\n    return this;\n  }\n\n  /** Get table header. */\n  public getHeader(): Row | undefined {\n    return this.headerRow;\n  }\n\n  /** Get table body. */\n  public getBody(): T[] {\n    return [...this];\n  }\n\n  /** Get mac col widrth. */\n  public getMaxColWidth(): number | number[] {\n    return this.options.maxColWidth;\n  }\n\n  /** Get min col width. */\n  public getMinColWidth(): number | number[] {\n    return this.options.minColWidth;\n  }\n\n  /** Get table indentation. */\n  public getIndent(): number {\n    return this.options.indent;\n  }\n\n  /** Get cell padding. */\n  public getPadding(): number | number[] {\n    return this.options.padding;\n  }\n\n  /** Check if table has border. */\n  public getBorder(): boolean {\n    return this.options.border === true;\n  }\n\n  /** Check if header row has border. */\n  public hasHeaderBorder(): boolean {\n    const hasBorder = this.headerRow?.hasBorder();\n    return hasBorder === true || (this.getBorder() && hasBorder !== false);\n  }\n\n  /** Check if table bordy has border. */\n  public hasBodyBorder(): boolean {\n    return this.getBorder() ||\n      this.some((row) =>\n        row instanceof Row\n          ? row.hasBorder()\n          : row.some((cell) => cell instanceof Cell ? cell.getBorder : false)\n      );\n  }\n\n  /** Check if table header or body has border. */\n  public hasBorder(): boolean {\n    return this.hasHeaderBorder() || this.hasBodyBorder();\n  }\n\n  /** Get table alignment. */\n  public getAlign(): Direction {\n    return this.options.align ?? \"left\";\n  }\n}\n", "import { getFlag } from \"../../flags/_utils.ts\";\nimport { Table } from \"../../table/table.ts\";\nimport { dedent, getDescription, parseArgumentsDefinition } from \"../_utils.ts\";\nimport type { Command } from \"../command.ts\";\nimport {\n  bold,\n  brightBlue,\n  brightMagenta,\n  dim,\n  getColorEnabled,\n  green,\n  italic,\n  red,\n  setColorEnabled,\n  yellow,\n} from \"../deps.ts\";\nimport { Type } from \"../type.ts\";\nimport type { Argument, EnvVar, Example, Option } from \"../types.ts\";\n\nexport interface HelpOptions {\n  types?: boolean;\n  hints?: boolean;\n  colors?: boolean;\n  long?: boolean;\n}\n\ninterface OptionGroup {\n  name?: string;\n  options: Array<Option>;\n}\n\n/** Help text generator. */\nexport class HelpGenerator {\n  private indent = 2;\n  private options: Required<HelpOptions>;\n\n  /** Generate help text for given command. */\n  public static generate(cmd: Command, options?: HelpOptions): string {\n    return new HelpGenerator(cmd, options).generate();\n  }\n\n  private constructor(\n    private cmd: Command,\n    options: HelpOptions = {},\n  ) {\n    this.options = {\n      types: false,\n      hints: true,\n      colors: true,\n      long: false,\n      ...options,\n    };\n  }\n\n  private generate(): string {\n    const areColorsEnabled = getColorEnabled();\n    setColorEnabled(this.options.colors);\n\n    const result = this.generateHeader() +\n      this.generateMeta() +\n      this.generateDescription() +\n      this.generateOptions() +\n      this.generateCommands() +\n      this.generateEnvironmentVariables() +\n      this.generateExamples();\n\n    setColorEnabled(areColorsEnabled);\n\n    return result;\n  }\n\n  private generateHeader(): string {\n    const usage = this.cmd.getUsage();\n    const rows = [\n      [\n        bold(\"Usage:\"),\n        brightMagenta(\n          this.cmd.getPath() +\n            (usage ? \" \" + highlightArguments(usage, this.options.types) : \"\"),\n        ),\n      ],\n    ];\n    const version: string | undefined = this.cmd.getVersion();\n    if (version) {\n      rows.push([bold(\"Version:\"), yellow(`${this.cmd.getVersion()}`)]);\n    }\n    return \"\\n\" +\n      Table.from(rows)\n        .indent(this.indent)\n        .padding(1)\n        .toString() +\n      \"\\n\";\n  }\n\n  private generateMeta(): string {\n    const meta = Object.entries(this.cmd.getMeta());\n    if (!meta.length) {\n      return \"\";\n    }\n\n    const rows = [];\n    for (const [name, value] of meta) {\n      rows.push([bold(`${name}: `) + value]);\n    }\n\n    return \"\\n\" +\n      Table.from(rows)\n        .indent(this.indent)\n        .padding(1)\n        .toString() +\n      \"\\n\";\n  }\n\n  private generateDescription(): string {\n    if (!this.cmd.getDescription()) {\n      return \"\";\n    }\n    return this.label(\"Description\") +\n      Table.from([\n        [dedent(this.cmd.getDescription())],\n      ])\n        .indent(this.indent * 2)\n        .maxColWidth(140)\n        .padding(1)\n        .toString() +\n      \"\\n\";\n  }\n\n  private generateOptions(): string {\n    const options = this.cmd.getOptions(false);\n    if (!options.length) {\n      return \"\";\n    }\n\n    let groups: Array<OptionGroup> = [];\n    const hasGroups = options.some((option) => option.groupName);\n    if (hasGroups) {\n      for (const option of options) {\n        let group = groups.find((group) => group.name === option.groupName);\n        if (!group) {\n          group = {\n            name: option.groupName,\n            options: [],\n          };\n          groups.push(group);\n        }\n        group.options.push(option);\n      }\n    } else {\n      groups = [{\n        name: \"Options\",\n        options,\n      }];\n    }\n\n    let result = \"\";\n    for (const group of groups) {\n      result += this.generateOptionGroup(group);\n    }\n\n    return result;\n  }\n\n  private generateOptionGroup(group: OptionGroup): string {\n    if (!group.options.length) {\n      return \"\";\n    }\n    const hasTypeDefinitions = !!group.options.find((option) =>\n      !!option.typeDefinition\n    );\n\n    if (hasTypeDefinitions) {\n      return this.label(group.name ?? \"Options\") +\n        Table.from([\n          ...group.options.map((option: Option) => [\n            option.flags.map((flag) => brightBlue(flag)).join(\", \"),\n            highlightArguments(\n              option.typeDefinition || \"\",\n              this.options.types,\n            ),\n            red(bold(\"-\")),\n            getDescription(option.description, !this.options.long),\n            this.generateHints(option),\n          ]),\n        ])\n          .padding([2, 2, 1, 2])\n          .indent(this.indent * 2)\n          .maxColWidth([60, 60, 1, 80, 60])\n          .toString() +\n        \"\\n\";\n    }\n\n    return this.label(group.name ?? \"Options\") +\n      Table.from([\n        ...group.options.map((option: Option) => [\n          option.flags.map((flag) => brightBlue(flag)).join(\", \"),\n          red(bold(\"-\")),\n          getDescription(option.description, !this.options.long),\n          this.generateHints(option),\n        ]),\n      ])\n        .indent(this.indent * 2)\n        .maxColWidth([60, 1, 80, 60])\n        .padding([2, 1, 2])\n        .toString() +\n      \"\\n\";\n  }\n\n  private generateCommands(): string {\n    const commands = this.cmd.getCommands(false);\n    if (!commands.length) {\n      return \"\";\n    }\n\n    const hasTypeDefinitions = !!commands.find((command) =>\n      !!command.getArgsDefinition()\n    );\n\n    if (hasTypeDefinitions) {\n      return this.label(\"Commands\") +\n        Table.from([\n          ...commands.map((command: Command) => [\n            [command.getName(), ...command.getAliases()].map((name) =>\n              brightBlue(name)\n            ).join(\", \"),\n            highlightArguments(\n              command.getArgsDefinition() || \"\",\n              this.options.types,\n            ),\n            red(bold(\"-\")),\n            command.getShortDescription(),\n          ]),\n        ])\n          .indent(this.indent * 2)\n          .maxColWidth([60, 60, 1, 80])\n          .padding([2, 2, 1, 2])\n          .toString() +\n        \"\\n\";\n    }\n\n    return this.label(\"Commands\") +\n      Table.from([\n        ...commands.map((command: Command) => [\n          [command.getName(), ...command.getAliases()].map((name) =>\n            brightBlue(name)\n          )\n            .join(\", \"),\n          red(bold(\"-\")),\n          command.getShortDescription(),\n        ]),\n      ])\n        .maxColWidth([60, 1, 80])\n        .padding([2, 1, 2])\n        .indent(this.indent * 2)\n        .toString() +\n      \"\\n\";\n  }\n\n  private generateEnvironmentVariables(): string {\n    const envVars = this.cmd.getEnvVars(false);\n    if (!envVars.length) {\n      return \"\";\n    }\n    return this.label(\"Environment variables\") +\n      Table.from([\n        ...envVars.map((envVar: EnvVar) => [\n          envVar.names.map((name: string) => brightBlue(name)).join(\", \"),\n          highlightArgumentDetails(\n            envVar.details,\n            this.options.types,\n          ),\n          red(bold(\"-\")),\n          this.options.long\n            ? dedent(envVar.description)\n            : envVar.description.trim().split(\"\\n\", 1)[0],\n          envVar.required ? `(${yellow(`required`)})` : \"\",\n        ]),\n      ])\n        .padding([2, 2, 1, 2])\n        .indent(this.indent * 2)\n        .maxColWidth([60, 60, 1, 80, 10])\n        .toString() +\n      \"\\n\";\n  }\n\n  private generateExamples(): string {\n    const examples = this.cmd.getExamples();\n    if (!examples.length) {\n      return \"\";\n    }\n    return this.label(\"Examples\") +\n      Table.from(examples.map((example: Example) => [\n        dim(bold(`${capitalize(example.name)}:`)),\n        dedent(example.description),\n      ]))\n        .padding(1)\n        .indent(this.indent * 2)\n        .maxColWidth(150)\n        .toString() +\n      \"\\n\";\n  }\n\n  private generateHints(option: Option): string {\n    if (!this.options.hints) {\n      return \"\";\n    }\n    const hints = [];\n\n    option.required && hints.push(yellow(`required`));\n    typeof option.default !== \"undefined\" && hints.push(\n      bold(`Default: `) + inspect(option.default, this.options.colors),\n    );\n    option.depends?.length && hints.push(\n      yellow(bold(`Depends: `)) +\n        italic(option.depends.map(getFlag).join(\", \")),\n    );\n    option.conflicts?.length && hints.push(\n      red(bold(`Conflicts: `)) +\n        italic(option.conflicts.map(getFlag).join(\", \")),\n    );\n\n    const type = this.cmd.getType(option.args[0]?.type)?.handler;\n    if (type instanceof Type) {\n      const possibleValues = type.values?.(this.cmd, this.cmd.getParent());\n      if (possibleValues?.length) {\n        hints.push(\n          bold(`Values: `) +\n            possibleValues.map((value: unknown) =>\n              inspect(value, this.options.colors)\n            ).join(\", \"),\n        );\n      }\n    }\n\n    if (hints.length) {\n      return `(${hints.join(\", \")})`;\n    }\n\n    return \"\";\n  }\n\n  private label(label: string) {\n    return \"\\n\" +\n      \" \".repeat(this.indent) + bold(`${label}:`) +\n      \"\\n\\n\";\n  }\n}\n\nfunction capitalize(string: string): string {\n  return string?.charAt(0).toUpperCase() + string.slice(1) ?? \"\";\n}\n\nfunction inspect(value: unknown, colors: boolean): string {\n  return Deno.inspect(\n    value,\n    // deno < 1.4.3 doesn't support the colors property.\n    { depth: 1, colors, trailingComma: false } as Deno.InspectOptions,\n  );\n}\n\n/**\n * Colorize arguments string.\n * @param argsDefinition Arguments definition: `<color1:string> <color2:string>`\n * @param types Show types.\n */\nfunction highlightArguments(argsDefinition: string, types = true) {\n  if (!argsDefinition) {\n    return \"\";\n  }\n\n  return parseArgumentsDefinition(argsDefinition, false, true)\n    .map((arg: Argument | string) =>\n      typeof arg === \"string\" ? arg : highlightArgumentDetails(arg, types)\n    )\n    .join(\" \");\n}\n\n/**\n * Colorize argument string.\n * @param arg Argument details.\n * @param types Show types.\n */\nfunction highlightArgumentDetails(\n  arg: Argument,\n  types = true,\n): string {\n  let str = \"\";\n\n  str += yellow(arg.optionalValue ? \"[\" : \"<\");\n\n  let name = \"\";\n  name += arg.name;\n  if (arg.variadic) {\n    name += \"...\";\n  }\n  name = brightMagenta(name);\n\n  str += name;\n\n  if (types) {\n    str += yellow(\":\");\n    str += red(arg.type);\n    if (arg.list) {\n      str += green(\"[]\");\n    }\n  }\n\n  str += yellow(arg.optionalValue ? \"]\" : \">\");\n\n  return str;\n}\n", "import { Type } from \"../type.ts\";\nimport type { ArgumentValue } from \"../types.ts\";\nimport { integer } from \"../../flags/types/integer.ts\";\n\n/** Integer type. */\nexport class IntegerType extends Type<number> {\n  /** Parse integer type. */\n  public parse(type: ArgumentValue): number {\n    return integer(type);\n  }\n}\n", "// deno-lint-ignore-file no-explicit-any\nimport {\n  UnknownTypeError,\n  ValidationError as FlagsValidationError,\n} from \"../flags/_errors.ts\";\nimport { MissingRequiredEnvVarError } from \"./_errors.ts\";\nimport { parseFlags } from \"../flags/flags.ts\";\nimport type { ParseFlagsContext } from \"../flags/types.ts\";\nimport {\n  getDescription,\n  parseArgumentsDefinition,\n  splitArguments,\n} from \"./_utils.ts\";\nimport { bold, brightBlue, red, yellow } from \"./deps.ts\";\nimport {\n  CommandExecutableNotFoundError,\n  CommandNotFoundError,\n  DefaultCommandNotFoundError,\n  DuplicateCommandAliasError,\n  DuplicateCommandNameError,\n  DuplicateCompletionError,\n  DuplicateEnvVarError,\n  DuplicateExampleError,\n  DuplicateOptionNameError,\n  DuplicateTypeError,\n  MissingArgumentError,\n  MissingArgumentsError,\n  MissingCommandNameError,\n  NoArgumentsAllowedError,\n  TooManyArgumentsError,\n  TooManyEnvVarValuesError,\n  UnexpectedOptionalEnvVarValueError,\n  UnexpectedVariadicEnvVarValueError,\n  UnknownCommandError,\n  ValidationError,\n} from \"./_errors.ts\";\nimport { DefaultValue, ErrorHandler, OptionValueHandler } from \"./types.ts\";\nimport { BooleanType } from \"./types/boolean.ts\";\nimport { FileType } from \"./types/file.ts\";\nimport { NumberType } from \"./types/number.ts\";\nimport { StringType } from \"./types/string.ts\";\nimport { Type } from \"./type.ts\";\nimport { HelpGenerator } from \"./help/_help_generator.ts\";\nimport type { HelpOptions } from \"./help/_help_generator.ts\";\nimport type {\n  ActionHandler,\n  Argument,\n  ArgumentValue,\n  CommandResult,\n  CompleteHandler,\n  CompleteOptions,\n  Completion,\n  Description,\n  EnvVar,\n  EnvVarOptions,\n  EnvVarValueHandler,\n  Example,\n  GlobalEnvVarOptions,\n  GlobalOptionOptions,\n  HelpHandler,\n  MapTypes,\n  Option,\n  OptionOptions,\n  TypeDef,\n  TypeOptions,\n  TypeOrTypeHandler,\n  VersionHandler,\n} from \"./types.ts\";\nimport { IntegerType } from \"./types/integer.ts\";\nimport { underscoreToCamelCase } from \"../flags/_utils.ts\";\n\nexport class Command<\n  TParentCommandGlobals extends Record<string, unknown> | void = void,\n  TParentCommandTypes extends Record<string, unknown> | void =\n    TParentCommandGlobals extends number ? any : void,\n  TCommandOptions extends Record<string, unknown> | void =\n    TParentCommandGlobals extends number ? any : void,\n  TCommandArguments extends Array<unknown> = TParentCommandGlobals extends\n    number ? any : [],\n  TCommandGlobals extends Record<string, unknown> | void =\n    TParentCommandGlobals extends number ? any : void,\n  TCommandTypes extends Record<string, unknown> | void =\n    TParentCommandGlobals extends number ? any : {\n      number: number;\n      integer: number;\n      string: string;\n      boolean: boolean;\n      file: string;\n    },\n  TCommandGlobalTypes extends Record<string, unknown> | void =\n    TParentCommandGlobals extends number ? any : void,\n  TParentCommand extends Command<any> | undefined =\n    TParentCommandGlobals extends number ? any : undefined,\n> {\n  private types: Map<string, TypeDef> = new Map();\n  private rawArgs: Array<string> = [];\n  private literalArgs: Array<string> = [];\n  // @TODO: get script name: https://github.com/denoland/deno/pull/5034\n  // private name: string = location.pathname.split( '/' ).pop() as string;\n  private _name = \"COMMAND\";\n  private _parent?: TParentCommand;\n  private _globalParent?: Command<any>;\n  private ver?: VersionHandler;\n  private desc: Description = \"\";\n  private _usage?: string;\n  private fn?: ActionHandler;\n  private options: Array<Option> = [];\n  private commands: Map<string, Command<any>> = new Map();\n  private examples: Array<Example> = [];\n  private envVars: Array<EnvVar> = [];\n  private aliases: Array<string> = [];\n  private completions: Map<string, Completion> = new Map();\n  private cmd: Command<any> = this;\n  private argsDefinition?: string;\n  private isExecutable = false;\n  private throwOnError = false;\n  private _allowEmpty = false;\n  private _stopEarly = false;\n  private defaultCommand?: string;\n  private _useRawArgs = false;\n  private args: Array<Argument> = [];\n  private isHidden = false;\n  private isGlobal = false;\n  private hasDefaults = false;\n  private _versionOptions?: DefaultOption | false;\n  private _helpOptions?: DefaultOption | false;\n  private _versionOption?: Option;\n  private _helpOption?: Option;\n  private _help?: HelpHandler;\n  private _shouldExit?: boolean;\n  private _meta: Record<string, string> = {};\n  private _groupName?: string;\n  private _noGlobals = false;\n  private errorHandler?: ErrorHandler;\n\n  /** Disable version option. */\n  public versionOption(enable: false): this;\n\n  /**\n   * Set global version option.\n   * @param flags The flags of the version option.\n   * @param desc  The description of the version option.\n   * @param opts  Version option options.\n   */\n  public versionOption(\n    flags: string,\n    desc?: string,\n    opts?:\n      & OptionOptions<\n        Partial<TCommandOptions>,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n      & {\n        global: true;\n      },\n  ): this;\n\n  /**\n   * Set version option.\n   * @param flags The flags of the version option.\n   * @param desc  The description of the version option.\n   * @param opts  Version option options.\n   */\n  public versionOption(\n    flags: string,\n    desc?: string,\n    opts?: OptionOptions<\n      TCommandOptions,\n      TCommandArguments,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      TParentCommand\n    >,\n  ): this;\n\n  /**\n   * Set version option.\n   * @param flags The flags of the version option.\n   * @param desc  The description of the version option.\n   * @param opts  The action of the version option.\n   */\n  public versionOption(\n    flags: string,\n    desc?: string,\n    opts?: ActionHandler<\n      TCommandOptions,\n      TCommandArguments,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      TParentCommand\n    >,\n  ): this;\n\n  public versionOption(\n    flags: string | false,\n    desc?: string,\n    opts?:\n      | ActionHandler<\n        TCommandOptions,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n      | OptionOptions<\n        TCommandOptions,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n      | OptionOptions<\n        Partial<TCommandOptions>,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n        & {\n          global: true;\n        },\n  ): this {\n    this._versionOptions = flags === false ? flags : {\n      flags,\n      desc,\n      opts: typeof opts === \"function\" ? { action: opts } : opts,\n    };\n    return this;\n  }\n\n  /** Disable help option. */\n  public helpOption(enable: false): this;\n\n  /**\n   * Set global help option.\n   * @param flags The flags of the help option.\n   * @param desc  The description of the help option.\n   * @param opts  Help option options.\n   */\n  public helpOption(\n    flags: string,\n    desc?: string,\n    opts?:\n      & OptionOptions<\n        Partial<TCommandOptions>,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n      & {\n        global: true;\n      },\n  ): this;\n\n  /**\n   * Set help option.\n   * @param flags The flags of the help option.\n   * @param desc  The description of the help option.\n   * @param opts  Help option options.\n   */\n  public helpOption(\n    flags: string,\n    desc?: string,\n    opts?: OptionOptions<\n      TCommandOptions,\n      TCommandArguments,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      TParentCommand\n    >,\n  ): this;\n\n  /**\n   * Set help option.\n   * @param flags The flags of the help option.\n   * @param desc  The description of the help option.\n   * @param opts  The action of the help option.\n   */\n  public helpOption(\n    flags: string,\n    desc?: string,\n    opts?: ActionHandler<\n      TCommandOptions,\n      TCommandArguments,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      TParentCommand\n    >,\n  ): this;\n\n  public helpOption(\n    flags: string | false,\n    desc?: string,\n    opts?:\n      | ActionHandler<\n        TCommandOptions,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n      | OptionOptions<\n        TCommandOptions,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n      | OptionOptions<\n        Partial<TCommandOptions>,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n        & {\n          global: true;\n        },\n  ): this {\n    this._helpOptions = flags === false ? flags : {\n      flags,\n      desc,\n      opts: typeof opts === \"function\" ? { action: opts } : opts,\n    };\n    return this;\n  }\n\n  /**\n   * Add new sub-command.\n   * @param name      Command definition. E.g: `my-command <input-file:string> <output-file:string>`\n   * @param cmd       The new child command to register.\n   * @param override  Override existing child command.\n   */\n  public command<\n    TCommand extends Command<\n      (TGlobalOptions & Record<string, unknown>) | void | undefined,\n      TGlobalTypes | void | undefined,\n      Record<string, unknown> | void,\n      Array<unknown>,\n      Record<string, unknown> | void,\n      Record<string, unknown> | void,\n      Record<string, unknown> | void,\n      Command<\n        TGlobalOptions | void | undefined,\n        TGlobalTypes | void | undefined,\n        Record<string, unknown> | void,\n        Array<unknown>,\n        Record<string, unknown> | void,\n        Record<string, unknown> | void,\n        Record<string, unknown> | void,\n        undefined\n      >\n    >,\n    TGlobalOptions\n      extends (TParentCommand extends Command<any> ? TParentCommandGlobals\n        : Merge<TParentCommandGlobals, TCommandGlobals>),\n    TGlobalTypes\n      extends (TParentCommand extends Command<any> ? TParentCommandTypes\n        : Merge<TParentCommandTypes, TCommandTypes>),\n  >(\n    name: string,\n    cmd: TCommand,\n    override?: boolean,\n  ): ReturnType<TCommand[\"reset\"]> extends Command<\n    Record<string, unknown> | void,\n    Record<string, unknown> | void,\n    infer Options,\n    infer Arguments,\n    infer GlobalOptions,\n    infer Types,\n    infer GlobalTypes,\n    undefined\n  > ? Command<\n      TGlobalOptions,\n      TGlobalTypes,\n      Options,\n      Arguments,\n      GlobalOptions,\n      Types,\n      GlobalTypes,\n      OneOf<TParentCommand, this>\n    >\n    : never;\n\n  /**\n   * Add new sub-command.\n   * @param name      Command definition. E.g: `my-command <input-file:string> <output-file:string>`\n   * @param cmd       The new child command to register.\n   * @param override  Override existing child command.\n   */\n  public command<\n    TCommand extends Command<\n      TGlobalOptions | void | undefined,\n      TGlobalTypes | void | undefined,\n      Record<string, unknown> | void,\n      Array<unknown>,\n      Record<string, unknown> | void,\n      Record<string, unknown> | void,\n      Record<string, unknown> | void,\n      OneOf<TParentCommand, this> | undefined\n    >,\n    TGlobalOptions\n      extends (TParentCommand extends Command<any> ? TParentCommandGlobals\n        : Merge<TParentCommandGlobals, TCommandGlobals>),\n    TGlobalTypes\n      extends (TParentCommand extends Command<any> ? TParentCommandTypes\n        : Merge<TParentCommandTypes, TCommandTypes>),\n  >(\n    name: string,\n    cmd: TCommand,\n    override?: boolean,\n  ): TCommand extends Command<\n    Record<string, unknown> | void,\n    Record<string, unknown> | void,\n    infer Options,\n    infer Arguments,\n    infer GlobalOptions,\n    infer Types,\n    infer GlobalTypes,\n    OneOf<TParentCommand, this> | undefined\n  > ? Command<\n      TGlobalOptions,\n      TGlobalTypes,\n      Options,\n      Arguments,\n      GlobalOptions,\n      Types,\n      GlobalTypes,\n      OneOf<TParentCommand, this>\n    >\n    : never;\n\n  /**\n   * Add new sub-command.\n   * @param nameAndArguments  Command definition. E.g: `my-command <input-file:string> <output-file:string>`\n   * @param desc              The description of the new child command.\n   * @param override          Override existing child command.\n   */\n  public command<\n    TNameAndArguments extends string,\n    TArguments extends TypedCommandArguments<\n      TNameAndArguments,\n      TParentCommand extends Command<any> ? TParentCommandTypes\n        : Merge<TParentCommandTypes, TCommandGlobalTypes>\n    >,\n  >(\n    nameAndArguments: TNameAndArguments,\n    desc?: string,\n    override?: boolean,\n  ): TParentCommandGlobals extends number ? Command<any> : Command<\n    TParentCommand extends Command<any> ? TParentCommandGlobals\n      : Merge<TParentCommandGlobals, TCommandGlobals>,\n    TParentCommand extends Command<any> ? TParentCommandTypes\n      : Merge<TParentCommandTypes, TCommandGlobalTypes>,\n    void,\n    TArguments,\n    void,\n    void,\n    void,\n    OneOf<TParentCommand, this>\n  >;\n\n  /**\n   * Add new sub-command.\n   * @param nameAndArguments  Command definition. E.g: `my-command <input-file:string> <output-file:string>`\n   * @param cmdOrDescription  The description of the new child command.\n   * @param override          Override existing child command.\n   */\n  command(\n    nameAndArguments: string,\n    cmdOrDescription?: Command<any> | string,\n    override?: boolean,\n  ): Command<any> {\n    this.reset();\n\n    const result = splitArguments(nameAndArguments);\n\n    const name: string | undefined = result.flags.shift();\n    const aliases: string[] = result.flags;\n\n    if (!name) {\n      throw new MissingCommandNameError();\n    }\n\n    if (this.getBaseCommand(name, true)) {\n      if (!override) {\n        throw new DuplicateCommandNameError(name);\n      }\n      this.removeCommand(name);\n    }\n\n    let description: string | undefined;\n    let cmd: Command<any>;\n\n    if (typeof cmdOrDescription === \"string\") {\n      description = cmdOrDescription;\n    }\n\n    if (cmdOrDescription instanceof Command) {\n      cmd = cmdOrDescription.reset();\n    } else {\n      cmd = new Command();\n    }\n\n    cmd._name = name;\n    cmd._parent = this;\n\n    if (description) {\n      cmd.description(description);\n    }\n\n    if (result.typeDefinition) {\n      cmd.arguments(result.typeDefinition);\n    }\n\n    aliases.forEach((alias: string) => cmd.alias(alias));\n\n    this.commands.set(name, cmd);\n\n    this.select(name);\n\n    return this;\n  }\n\n  /**\n   * Add new command alias.\n   * @param alias Tha name of the alias.\n   */\n  public alias(alias: string): this {\n    if (this.cmd._name === alias || this.cmd.aliases.includes(alias)) {\n      throw new DuplicateCommandAliasError(alias);\n    }\n\n    this.cmd.aliases.push(alias);\n\n    return this;\n  }\n\n  /** Reset internal command reference to main command. */\n  public reset(): OneOf<TParentCommand, this> {\n    this._groupName = undefined;\n    this.cmd = this;\n    return this as OneOf<TParentCommand, this>;\n  }\n\n  /**\n   * Set internal command pointer to child command with given name.\n   * @param name The name of the command to select.\n   */\n  public select<\n    TOptions extends Record<string, unknown> | void = any,\n    TArguments extends Array<unknown> = any,\n    TGlobalOptions extends Record<string, unknown> | void = any,\n  >(\n    name: string,\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TOptions,\n    TArguments,\n    TGlobalOptions,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  > {\n    const cmd = this.getBaseCommand(name, true);\n\n    if (!cmd) {\n      throw new CommandNotFoundError(name, this.getBaseCommands(true));\n    }\n\n    this.cmd = cmd;\n\n    return this as Command<any>;\n  }\n\n  /*****************************************************************************\n   **** SUB HANDLER ************************************************************\n   *****************************************************************************/\n\n  /** Set command name. */\n  public name(name: string): this {\n    this.cmd._name = name;\n    return this;\n  }\n\n  /**\n   * Set command version.\n   * @param version Semantic version string string or method that returns the version string.\n   */\n  public version(\n    version:\n      | string\n      | VersionHandler<\n        Partial<TCommandOptions>,\n        Partial<TCommandArguments>,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >,\n  ): this {\n    if (typeof version === \"string\") {\n      this.cmd.ver = () => version;\n    } else if (typeof version === \"function\") {\n      this.cmd.ver = version;\n    }\n    return this;\n  }\n\n  public meta(name: string, value: string): this {\n    this.cmd._meta[name] = value;\n    return this;\n  }\n\n  public getMeta(): Record<string, string>;\n  public getMeta(name: string): string;\n  public getMeta(name?: string): Record<string, string> | string {\n    return typeof name === \"undefined\" ? this._meta : this._meta[name];\n  }\n\n  /**\n   * Set command help.\n   * @param help Help string, method, or config for generator that returns the help string.\n   */\n  public help(\n    help:\n      | string\n      | HelpHandler<\n        Partial<TCommandOptions>,\n        Partial<TCommandArguments>,\n        TCommandGlobals,\n        TParentCommandGlobals\n      >\n      | HelpOptions,\n  ): this {\n    if (typeof help === \"string\") {\n      this.cmd._help = () => help;\n    } else if (typeof help === \"function\") {\n      this.cmd._help = help;\n    } else {\n      this.cmd._help = (cmd: Command, options: HelpOptions): string =>\n        HelpGenerator.generate(cmd, { ...help, ...options });\n    }\n    return this;\n  }\n\n  /**\n   * Set the long command description.\n   * @param description The command description.\n   */\n  public description(\n    description: Description<\n      TCommandOptions,\n      TCommandArguments,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      TParentCommand\n    >,\n  ): this {\n    this.cmd.desc = description;\n    return this;\n  }\n\n  /**\n   * Set the command usage. Defaults to arguments.\n   * @param usage The command usage.\n   */\n  public usage(usage: string): this {\n    this.cmd._usage = usage;\n    return this;\n  }\n\n  /**\n   * Hide command from help, completions, etc.\n   */\n  public hidden(): this {\n    this.cmd.isHidden = true;\n    return this;\n  }\n\n  /** Make command globally available. */\n  public global(): this {\n    this.cmd.isGlobal = true;\n    return this;\n  }\n\n  /** Make command executable. */\n  public executable(): this {\n    this.cmd.isExecutable = true;\n    return this;\n  }\n\n  /**\n   * Set command arguments:\n   *\n   *   <requiredArg:string> [optionalArg: number] [...restArgs:string]\n   */\n  public arguments<\n    TArguments extends TypedArguments<\n      TArgs,\n      Merge<TParentCommandTypes, Merge<TCommandGlobalTypes, TCommandTypes>>\n    >,\n    TArgs extends string = string,\n  >(\n    args: TArgs,\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TCommandOptions,\n    TArguments,\n    TCommandGlobals,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  > {\n    this.cmd.argsDefinition = args;\n    return this as Command<any>;\n  }\n\n  /**\n   * Set command callback method.\n   * @param fn Command action handler.\n   */\n  public action(\n    fn: ActionHandler<\n      TCommandOptions,\n      TCommandArguments,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      TParentCommand\n    >,\n  ): this {\n    this.cmd.fn = fn;\n    return this;\n  }\n\n  /**\n   * Don't throw an error if the command was called without arguments.\n   * @param allowEmpty Enable/disable allow empty.\n   */\n  // public allowEmpty<TAllowEmpty extends boolean | undefined = undefined>(\n  //   allowEmpty?: TAllowEmpty,\n  // ): false extends TAllowEmpty ? this\n  //   : Command<\n  //     Partial<TParentCommandGlobals>,\n  //     TParentCommandTypes,\n  //     Partial<TCommandOptions>,\n  //     TCommandArguments,\n  //     TCommandGlobals,\n  //     TCommandTypes,\n  //     TCommandGlobalTypes,\n  //     TParentCommand\n  //   > {\n  //   this.cmd._allowEmpty = allowEmpty !== false;\n  //   return this;\n  // }\n\n  public allowEmpty<TAllowEmpty extends boolean | undefined = undefined>(\n    allowEmpty?: TAllowEmpty,\n  ): false extends TAllowEmpty ? this\n    : Command<\n      Partial<TParentCommandGlobals>,\n      TParentCommandTypes,\n      Partial<TCommandOptions>,\n      TCommandArguments,\n      TCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommand\n    > {\n    this.cmd._allowEmpty = allowEmpty !== false;\n    return this as false extends TAllowEmpty ? this\n      : Command<\n        Partial<TParentCommandGlobals>,\n        TParentCommandTypes,\n        Partial<TCommandOptions>,\n        TCommandArguments,\n        TCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommand\n      >;\n  }\n\n  /**\n   * Enable stop early. If enabled, all arguments starting from the first non\n   * option argument will be passed as arguments with type string to the command\n   * action handler.\n   *\n   * For example:\n   *     `command --debug-level warning server --port 80`\n   *\n   * Will result in:\n   *     - options: `{debugLevel: 'warning'}`\n   *     - args: `['server', '--port', '80']`\n   *\n   * @param stopEarly Enable/disable stop early.\n   */\n  public stopEarly(stopEarly = true): this {\n    this.cmd._stopEarly = stopEarly;\n    return this;\n  }\n\n  /**\n   * Disable parsing arguments. If enabled the raw arguments will be passed to\n   * the action handler. This has no effect for parent or child commands. Only\n   * for the command on which this method was called.\n   * @param useRawArgs Enable/disable raw arguments.\n   */\n  public useRawArgs(\n    useRawArgs = true,\n  ): Command<\n    void,\n    void,\n    void,\n    Array<string>,\n    void,\n    void,\n    void,\n    TParentCommand\n  > {\n    this.cmd._useRawArgs = useRawArgs;\n    return this as Command<any>;\n  }\n\n  /**\n   * Set default command. The default command is executed when the program\n   * was called without any argument and if no action handler is registered.\n   * @param name Name of the default command.\n   */\n  public default(name: string): this {\n    this.cmd.defaultCommand = name;\n    return this;\n  }\n\n  public globalType<\n    THandler extends TypeOrTypeHandler<unknown>,\n    TName extends string = string,\n  >(\n    name: TName,\n    handler: THandler,\n    options?: Omit<TypeOptions, \"global\">,\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TCommandOptions,\n    TCommandArguments,\n    TCommandGlobals,\n    TCommandTypes,\n    Merge<TCommandGlobalTypes, TypedType<TName, THandler>>,\n    TParentCommand\n  > {\n    return this.type(name, handler, { ...options, global: true });\n  }\n\n  /**\n   * Register custom type.\n   * @param name    The name of the type.\n   * @param handler The callback method to parse the type.\n   * @param options Type options.\n   */\n  public type<\n    THandler extends TypeOrTypeHandler<unknown>,\n    TName extends string = string,\n  >(\n    name: TName,\n    handler: THandler,\n    options?: TypeOptions,\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TCommandOptions,\n    TCommandArguments,\n    TCommandGlobals,\n    Merge<TCommandTypes, TypedType<TName, THandler>>,\n    TCommandGlobalTypes,\n    TParentCommand\n  > {\n    if (this.cmd.types.get(name) && !options?.override) {\n      throw new DuplicateTypeError(name);\n    }\n\n    this.cmd.types.set(name, {\n      ...options,\n      name,\n      handler: handler as TypeOrTypeHandler<unknown>,\n    });\n\n    if (\n      handler instanceof Type &&\n      (typeof handler.complete !== \"undefined\" ||\n        typeof handler.values !== \"undefined\")\n    ) {\n      const completeHandler: CompleteHandler = (\n        cmd: Command,\n        parent?: Command,\n      ) => handler.complete?.(cmd, parent) || [];\n      this.complete(name, completeHandler, options);\n    }\n\n    return this as Command<any>;\n  }\n\n  public globalComplete(\n    name: string,\n    complete: CompleteHandler,\n    options?: Omit<CompleteOptions, \"global\">,\n  ): this {\n    return this.complete(name, complete, { ...options, global: true });\n  }\n\n  /**\n   * Register command specific custom type.\n   * @param name      The name of the completion.\n   * @param complete  The callback method to complete the type.\n   * @param options   Complete options.\n   */\n  public complete(\n    name: string,\n    complete: CompleteHandler<\n      Partial<TCommandOptions>,\n      Partial<TCommandArguments>,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      any\n    >,\n    options: CompleteOptions & { global: boolean },\n  ): this;\n  public complete(\n    name: string,\n    complete: CompleteHandler<\n      TCommandOptions,\n      TCommandArguments,\n      TCommandGlobals,\n      TParentCommandGlobals,\n      TCommandTypes,\n      TCommandGlobalTypes,\n      TParentCommandTypes,\n      TParentCommand\n    >,\n    options?: CompleteOptions,\n  ): this;\n\n  public complete(\n    name: string,\n    complete:\n      | CompleteHandler<\n        TCommandOptions,\n        TCommandArguments,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n      | CompleteHandler<\n        Partial<TCommandOptions>,\n        Partial<TCommandArguments>,\n        TCommandGlobals,\n        TParentCommandGlobals,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        any\n      >,\n    options?: CompleteOptions,\n  ): this {\n    if (this.cmd.completions.has(name) && !options?.override) {\n      throw new DuplicateCompletionError(name);\n    }\n\n    this.cmd.completions.set(name, {\n      name,\n      complete,\n      ...options,\n    });\n\n    return this;\n  }\n\n  /**\n   * Throw validation errors instead of calling `Deno.exit()` to handle\n   * validation errors manually.\n   *\n   * A validation error is thrown when the command is wrongly used by the user.\n   * For example: If the user passes some invalid options or arguments to the\n   * command.\n   *\n   * This has no effect for parent commands. Only for the command on which this\n   * method was called and all child commands.\n   *\n   * **Example:**\n   *\n   * ```\n   * try {\n   *   cmd.parse();\n   * } catch(error) {\n   *   if (error instanceof ValidationError) {\n   *     cmd.showHelp();\n   *     Deno.exit(1);\n   *   }\n   *   throw error;\n   * }\n   * ```\n   *\n   * @see ValidationError\n   */\n  public throwErrors(): this {\n    this.cmd.throwOnError = true;\n    return this;\n  }\n\n  public error(handler: ErrorHandler): this {\n    this.cmd.errorHandler = handler;\n    return this;\n  }\n\n  private getErrorHandler(): ErrorHandler | undefined {\n    return this.errorHandler ?? this._parent?.errorHandler;\n  }\n\n  /**\n   * Same as `.throwErrors()` but also prevents calling `Deno.exit` after\n   * printing help or version with the --help and --version option.\n   */\n  public noExit(): this {\n    this.cmd._shouldExit = false;\n    this.throwErrors();\n    return this;\n  }\n\n  /**\n   * Disable inheriting global commands, options and environment variables from\n   * parent commands.\n   */\n  public noGlobals(): this {\n    this.cmd._noGlobals = true;\n    return this;\n  }\n\n  /** Check whether the command should throw errors or exit. */\n  protected shouldThrowErrors(): boolean {\n    return this.throwOnError || !!this._parent?.shouldThrowErrors();\n  }\n\n  /** Check whether the command should exit after printing help or version. */\n  protected shouldExit(): boolean {\n    return this._shouldExit ?? this._parent?.shouldExit() ?? true;\n  }\n\n  public globalOption<\n    TFlags extends string,\n    TGlobalOptions extends TypedOption<\n      TFlags,\n      TCommandOptions,\n      Merge<TParentCommandTypes, Merge<TCommandGlobalTypes, TCommandTypes>>,\n      undefined extends TConflicts ? TRequired : false,\n      TDefaultValue\n    >,\n    TMappedGlobalOptions extends MapValue<\n      TGlobalOptions,\n      TMappedValue,\n      TCollect\n    >,\n    TRequired extends OptionOptions[\"required\"] = undefined,\n    TCollect extends OptionOptions[\"collect\"] = undefined,\n    TConflicts extends OptionOptions[\"conflicts\"] = undefined,\n    TDefaultValue = undefined,\n    TMappedValue = undefined,\n  >(\n    flags: TFlags,\n    desc: string,\n    opts?:\n      | Omit<\n        GlobalOptionOptions<\n          Partial<TCommandOptions>,\n          TCommandArguments,\n          MergeOptions<TFlags, TCommandGlobals, TGlobalOptions>,\n          TParentCommandGlobals,\n          TCommandTypes,\n          TCommandGlobalTypes,\n          TParentCommandTypes,\n          TParentCommand\n        >,\n        \"value\"\n      >\n        & {\n          default?: DefaultValue<TDefaultValue>;\n          required?: TRequired;\n          collect?: TCollect;\n          value?: OptionValueHandler<\n            MapTypes<ValueOf<TGlobalOptions>>,\n            TMappedValue\n          >;\n        }\n      | OptionValueHandler<MapTypes<ValueOf<TGlobalOptions>>, TMappedValue>,\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TCommandOptions,\n    TCommandArguments,\n    MergeOptions<TFlags, TCommandGlobals, TMappedGlobalOptions>,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  > {\n    if (typeof opts === \"function\") {\n      return this.option(\n        flags,\n        desc,\n        { value: opts, global: true } as OptionOptions,\n      ) as Command<any>;\n    }\n    return this.option(\n      flags,\n      desc,\n      { ...opts, global: true } as OptionOptions,\n    ) as Command<any>;\n  }\n\n  /**\n   * Enable grouping of options and set the name of the group.\n   * All option which are added after calling the `.group()` method will be\n   * grouped in the help output. If the `.group()` method can be use multiple\n   * times to create more groups.\n   *\n   * @param name The name of the option group.\n   */\n  public group(name: string): this {\n    this.cmd._groupName = name;\n    return this;\n  }\n\n  /**\n   * Add a new option.\n   * @param flags Flags string e.g: -h, --help, --manual <requiredArg:string> [optionalArg:number] [...restArgs:string]\n   * @param desc Flag description.\n   * @param opts Flag options or custom handler for processing flag value.\n   */\n  public option<\n    TFlags extends string,\n    TGlobalOptions extends TypedOption<\n      TFlags,\n      TCommandOptions,\n      Merge<TParentCommandTypes, Merge<TCommandGlobalTypes, TCommandTypes>>,\n      undefined extends TConflicts ? TRequired : false,\n      TDefault\n    >,\n    TMappedGlobalOptions extends MapValue<\n      TGlobalOptions,\n      TMappedValue,\n      TCollect\n    >,\n    TRequired extends OptionOptions[\"required\"] = undefined,\n    TCollect extends OptionOptions[\"collect\"] = undefined,\n    TConflicts extends OptionOptions[\"conflicts\"] = undefined,\n    TDefault = undefined,\n    TMappedValue = undefined,\n  >(\n    flags: TFlags,\n    desc: string,\n    opts:\n      | Omit<\n        OptionOptions<\n          Partial<TCommandOptions>,\n          TCommandArguments,\n          MergeOptions<TFlags, TCommandGlobals, TGlobalOptions>,\n          TParentCommandGlobals,\n          TCommandTypes,\n          TCommandGlobalTypes,\n          TParentCommandTypes,\n          TParentCommand\n        >,\n        \"value\"\n      >\n        & {\n          global: true;\n          default?: DefaultValue<TDefault>;\n          required?: TRequired;\n          collect?: TCollect;\n          value?: OptionValueHandler<\n            MapTypes<ValueOf<TGlobalOptions>>,\n            TMappedValue\n          >;\n        }\n      | OptionValueHandler<MapTypes<ValueOf<TGlobalOptions>>, TMappedValue>,\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TCommandOptions,\n    TCommandArguments,\n    MergeOptions<TFlags, TCommandGlobals, TMappedGlobalOptions>,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  >;\n\n  public option<\n    TFlags extends string,\n    TOptions extends TypedOption<\n      TFlags,\n      TCommandOptions,\n      Merge<TParentCommandTypes, Merge<TCommandGlobalTypes, TCommandTypes>>,\n      undefined extends TConflicts ? TRequired : false,\n      TDefaultValue\n    >,\n    TMappedOptions extends MapValue<TOptions, TMappedValue, TCollect>,\n    TRequired extends OptionOptions[\"required\"] = undefined,\n    TCollect extends OptionOptions[\"collect\"] = undefined,\n    TConflicts extends OptionOptions[\"conflicts\"] = undefined,\n    TDefaultValue = undefined,\n    TMappedValue = undefined,\n  >(\n    flags: TFlags,\n    desc: string,\n    opts?:\n      | Omit<\n        OptionOptions<\n          MergeOptions<TFlags, TCommandOptions, TMappedOptions>,\n          TCommandArguments,\n          TCommandGlobals,\n          TParentCommandGlobals,\n          TCommandTypes,\n          TCommandGlobalTypes,\n          TParentCommandTypes,\n          TParentCommand\n        >,\n        \"value\"\n      >\n        & {\n          default?: DefaultValue<TDefaultValue>;\n          required?: TRequired;\n          collect?: TCollect;\n          conflicts?: TConflicts;\n          value?: OptionValueHandler<MapTypes<ValueOf<TOptions>>, TMappedValue>;\n        }\n      | OptionValueHandler<MapTypes<ValueOf<TOptions>>, TMappedValue>,\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    MergeOptions<TFlags, TCommandOptions, TMappedOptions>,\n    TCommandArguments,\n    TCommandGlobals,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  >;\n\n  public option(\n    flags: string,\n    desc: string,\n    opts?: OptionOptions | OptionValueHandler,\n  ): Command<any> {\n    if (typeof opts === \"function\") {\n      return this.option(flags, desc, { value: opts });\n    }\n\n    const result = splitArguments(flags);\n\n    const args: Argument[] = result.typeDefinition\n      ? parseArgumentsDefinition(result.typeDefinition)\n      : [];\n\n    const option: Option = {\n      ...opts,\n      name: \"\",\n      description: desc,\n      args,\n      flags: result.flags,\n      equalsSign: result.equalsSign,\n      typeDefinition: result.typeDefinition,\n      groupName: this._groupName,\n    };\n\n    if (option.separator) {\n      for (const arg of args) {\n        if (arg.list) {\n          arg.separator = option.separator;\n        }\n      }\n    }\n\n    for (const part of option.flags) {\n      const arg = part.trim();\n      const isLong = /^--/.test(arg);\n      const name = isLong ? arg.slice(2) : arg.slice(1);\n\n      if (this.cmd.getBaseOption(name, true)) {\n        if (opts?.override) {\n          this.removeOption(name);\n        } else {\n          throw new DuplicateOptionNameError(name);\n        }\n      }\n\n      if (!option.name && isLong) {\n        option.name = name;\n      } else if (!option.aliases) {\n        option.aliases = [name];\n      } else {\n        option.aliases.push(name);\n      }\n    }\n\n    if (option.prepend) {\n      this.cmd.options.unshift(option);\n    } else {\n      this.cmd.options.push(option);\n    }\n\n    return this;\n  }\n\n  /**\n   * Add new command example.\n   * @param name          Name of the example.\n   * @param description   The content of the example.\n   */\n  public example(name: string, description: string): this {\n    if (this.cmd.hasExample(name)) {\n      throw new DuplicateExampleError(name);\n    }\n\n    this.cmd.examples.push({ name, description });\n\n    return this;\n  }\n\n  public globalEnv<\n    TNameAndValue extends string,\n    TGlobalEnvVars extends TypedEnv<\n      TNameAndValue,\n      TPrefix,\n      TCommandOptions,\n      Merge<TParentCommandTypes, Merge<TCommandGlobalTypes, TCommandTypes>>,\n      TRequired\n    >,\n    TMappedGlobalEnvVars extends MapValue<TGlobalEnvVars, TMappedValue>,\n    TRequired extends EnvVarOptions[\"required\"] = undefined,\n    TPrefix extends EnvVarOptions[\"prefix\"] = undefined,\n    TMappedValue = undefined,\n  >(\n    name: TNameAndValue,\n    description: string,\n    options?: Omit<GlobalEnvVarOptions, \"value\"> & {\n      required?: TRequired;\n      prefix?: TPrefix;\n      value?: EnvVarValueHandler<\n        MapTypes<ValueOf<TGlobalEnvVars>>,\n        TMappedValue\n      >;\n    },\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TCommandOptions,\n    TCommandArguments,\n    Merge<TCommandGlobals, TMappedGlobalEnvVars>,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  > {\n    return this.env(\n      name,\n      description,\n      { ...options, global: true } as EnvVarOptions,\n    ) as Command<any>;\n  }\n\n  /**\n   * Add new environment variable.\n   * @param name          Name of the environment variable.\n   * @param description   The description of the environment variable.\n   * @param options       Environment variable options.\n   */\n  public env<\n    N extends string,\n    G extends TypedEnv<\n      N,\n      P,\n      TCommandOptions,\n      Merge<TParentCommandTypes, Merge<TCommandGlobalTypes, TCommandTypes>>,\n      R\n    >,\n    MG extends MapValue<G, V>,\n    R extends EnvVarOptions[\"required\"] = undefined,\n    P extends EnvVarOptions[\"prefix\"] = undefined,\n    V = undefined,\n  >(\n    name: N,\n    description: string,\n    options: Omit<EnvVarOptions, \"value\"> & {\n      global: true;\n      required?: R;\n      prefix?: P;\n      value?: EnvVarValueHandler<MapTypes<ValueOf<G>>, V>;\n    },\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    TCommandOptions,\n    TCommandArguments,\n    Merge<TCommandGlobals, MG>,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  >;\n\n  public env<\n    TNameAndValue extends string,\n    TEnvVar extends TypedEnv<\n      TNameAndValue,\n      TPrefix,\n      TCommandOptions,\n      Merge<TParentCommandTypes, Merge<TCommandGlobalTypes, TCommandTypes>>,\n      TRequired\n    >,\n    TMappedEnvVar extends MapValue<TEnvVar, TMappedValue>,\n    TRequired extends EnvVarOptions[\"required\"] = undefined,\n    TPrefix extends EnvVarOptions[\"prefix\"] = undefined,\n    TMappedValue = undefined,\n  >(\n    name: TNameAndValue,\n    description: string,\n    options?: Omit<EnvVarOptions, \"value\"> & {\n      required?: TRequired;\n      prefix?: TPrefix;\n      value?: EnvVarValueHandler<MapTypes<ValueOf<TEnvVar>>, TMappedValue>;\n    },\n  ): Command<\n    TParentCommandGlobals,\n    TParentCommandTypes,\n    Merge<TCommandOptions, TMappedEnvVar>,\n    TCommandArguments,\n    TCommandGlobals,\n    TCommandTypes,\n    TCommandGlobalTypes,\n    TParentCommand\n  >;\n\n  public env(\n    name: string,\n    description: string,\n    options?: EnvVarOptions,\n  ): Command<any> {\n    const result = splitArguments(name);\n\n    if (!result.typeDefinition) {\n      result.typeDefinition = \"<value:boolean>\";\n    }\n\n    if (result.flags.some((envName) => this.cmd.getBaseEnvVar(envName, true))) {\n      throw new DuplicateEnvVarError(name);\n    }\n\n    const details: Argument[] = parseArgumentsDefinition(\n      result.typeDefinition,\n    );\n\n    if (details.length > 1) {\n      throw new TooManyEnvVarValuesError(name);\n    } else if (details.length && details[0].optionalValue) {\n      throw new UnexpectedOptionalEnvVarValueError(name);\n    } else if (details.length && details[0].variadic) {\n      throw new UnexpectedVariadicEnvVarValueError(name);\n    }\n\n    this.cmd.envVars.push({\n      name: result.flags[0],\n      names: result.flags,\n      description,\n      type: details[0].type,\n      details: details.shift() as Argument,\n      ...options,\n    });\n\n    return this;\n  }\n\n  /*****************************************************************************\n   **** MAIN HANDLER ***********************************************************\n   *****************************************************************************/\n\n  /**\n   * Parse command line arguments and execute matched command.\n   * @param args Command line args to parse. Ex: `cmd.parse( Deno.args )`\n   */\n  public parse(\n    args: string[] = Deno.args,\n  ): Promise<\n    TParentCommand extends Command<any> ? CommandResult<\n        Record<string, unknown>,\n        Array<unknown>,\n        Record<string, unknown>,\n        Record<string, unknown>,\n        Record<string, unknown>,\n        Record<string, unknown>,\n        Record<string, unknown>,\n        undefined\n      >\n      : CommandResult<\n        MapTypes<TCommandOptions>,\n        MapTypes<TCommandArguments>,\n        MapTypes<TCommandGlobals>,\n        MapTypes<TParentCommandGlobals>,\n        TCommandTypes,\n        TCommandGlobalTypes,\n        TParentCommandTypes,\n        TParentCommand\n      >\n  > {\n    const ctx: ParseContext = {\n      unknown: args.slice(),\n      flags: {},\n      env: {},\n      literal: [],\n      stopEarly: false,\n      stopOnUnknown: false,\n    };\n    return this.parseCommand(ctx) as any;\n  }\n\n  private async parseCommand(ctx: ParseContext): Promise<CommandResult> {\n    try {\n      this.reset();\n      this.registerDefaults();\n      this.rawArgs = ctx.unknown.slice();\n\n      if (this.isExecutable) {\n        await this.executeExecutable(ctx.unknown);\n        return { options: {}, args: [], cmd: this, literal: [] } as any;\n      } else if (this._useRawArgs) {\n        await this.parseEnvVars(ctx, this.envVars);\n        return this.execute(ctx.env, ...ctx.unknown) as any;\n      }\n\n      let preParseGlobals = false;\n      let subCommand: Command<any> | undefined;\n\n      // Pre parse globals to support: cmd --global-option sub-command --option\n      if (ctx.unknown.length > 0) {\n        // Detect sub command.\n        subCommand = this.getSubCommand(ctx);\n\n        if (!subCommand) {\n          // Only pre parse globals if first arg ist a global option.\n          const optionName = ctx.unknown[0].replace(/^-+/, \"\");\n          const option = this.getOption(optionName, true);\n\n          if (option?.global) {\n            preParseGlobals = true;\n            await this.parseGlobalOptionsAndEnvVars(ctx);\n          }\n        }\n      }\n\n      if (subCommand || ctx.unknown.length > 0) {\n        subCommand ??= this.getSubCommand(ctx);\n\n        if (subCommand) {\n          subCommand._globalParent = this;\n          return subCommand.parseCommand(ctx);\n        }\n      }\n\n      // Parse rest options & env vars.\n      await this.parseOptionsAndEnvVars(ctx, preParseGlobals);\n      const options = { ...ctx.env, ...ctx.flags };\n      const args = this.parseArguments(ctx, options);\n      this.literalArgs = ctx.literal;\n\n      // Execute option action.\n      if (ctx.action) {\n        await ctx.action.action.call(this, options, ...args);\n\n        if (ctx.action.standalone) {\n          return {\n            options,\n            args,\n            cmd: this,\n            literal: this.literalArgs,\n          } as any;\n        }\n      }\n\n      return await this.execute(options, ...args) as any;\n    } catch (error: unknown) {\n      this.handleError(error);\n    }\n  }\n\n  private getSubCommand(ctx: ParseContext) {\n    const subCommand = this.getCommand(ctx.unknown[0], true);\n\n    if (subCommand) {\n      ctx.unknown.shift();\n    }\n\n    return subCommand;\n  }\n\n  private async parseGlobalOptionsAndEnvVars(\n    ctx: ParseContext,\n  ): Promise<void> {\n    const isHelpOption = this.getHelpOption()?.flags.includes(ctx.unknown[0]);\n\n    // Parse global env vars.\n    const envVars = [\n      ...this.envVars.filter((envVar) => envVar.global),\n      ...this.getGlobalEnvVars(true),\n    ];\n\n    await this.parseEnvVars(ctx, envVars, !isHelpOption);\n\n    // Parse global options.\n    const options = [\n      ...this.options.filter((option) => option.global),\n      ...this.getGlobalOptions(true),\n    ];\n\n    this.parseOptions(ctx, options, {\n      stopEarly: true,\n      stopOnUnknown: true,\n      dotted: false,\n    });\n  }\n\n  private async parseOptionsAndEnvVars(\n    ctx: ParseContext,\n    preParseGlobals: boolean,\n  ): Promise<void> {\n    const helpOption = this.getHelpOption();\n    const isVersionOption = this._versionOption?.flags.includes(ctx.unknown[0]);\n    const isHelpOption = helpOption && ctx.flags?.[helpOption.name] === true;\n\n    // Parse env vars.\n    const envVars = preParseGlobals\n      ? this.envVars.filter((envVar) => !envVar.global)\n      : this.getEnvVars(true);\n\n    await this.parseEnvVars(\n      ctx,\n      envVars,\n      !isHelpOption && !isVersionOption,\n    );\n\n    // Parse options.\n    const options = this.getOptions(true);\n\n    this.parseOptions(ctx, options);\n  }\n\n  /** Register default options like `--version` and `--help`. */\n  private registerDefaults(): this {\n    if (this.hasDefaults || this.getParent()) {\n      return this;\n    }\n    this.hasDefaults = true;\n\n    this.reset();\n\n    !this.types.has(\"string\") &&\n      this.type(\"string\", new StringType(), { global: true });\n    !this.types.has(\"number\") &&\n      this.type(\"number\", new NumberType(), { global: true });\n    !this.types.has(\"integer\") &&\n      this.type(\"integer\", new IntegerType(), { global: true });\n    !this.types.has(\"boolean\") &&\n      this.type(\"boolean\", new BooleanType(), { global: true });\n    !this.types.has(\"file\") &&\n      this.type(\"file\", new FileType(), { global: true });\n\n    if (!this._help) {\n      this.help({\n        hints: true,\n        types: false,\n      });\n    }\n\n    if (this._versionOptions !== false && (this._versionOptions || this.ver)) {\n      this.option(\n        this._versionOptions?.flags || \"-V, --version\",\n        this._versionOptions?.desc ||\n          \"Show the version number for this program.\",\n        {\n          standalone: true,\n          prepend: true,\n          action: async function () {\n            const long = this.getRawArgs().includes(\n              `--${this._versionOption?.name}`,\n            );\n            if (long) {\n              await this.checkVersion();\n              this.showLongVersion();\n            } else {\n              this.showVersion();\n            }\n            this.exit();\n          },\n          ...(this._versionOptions?.opts ?? {}),\n        },\n      );\n      this._versionOption = this.options[0];\n    }\n\n    if (this._helpOptions !== false) {\n      this.option(\n        this._helpOptions?.flags || \"-h, --help\",\n        this._helpOptions?.desc || \"Show this help.\",\n        {\n          standalone: true,\n          global: true,\n          prepend: true,\n          action: async function () {\n            const long = this.getRawArgs().includes(\n              `--${this.getHelpOption()?.name}`,\n            );\n            await this.checkVersion();\n            this.showHelp({ long });\n            this.exit();\n          },\n          ...(this._helpOptions?.opts ?? {}),\n        },\n      );\n      this._helpOption = this.options[0];\n    }\n\n    return this;\n  }\n\n  /**\n   * Execute command.\n   * @param options A map of options.\n   * @param args Command arguments.\n   */\n  protected async execute(\n    options: Record<string, unknown>,\n    ...args: Array<unknown>\n  ): Promise<CommandResult> {\n    if (this.fn) {\n      await this.fn(options, ...args);\n    } else if (this.defaultCommand) {\n      const cmd = this.getCommand(this.defaultCommand, true);\n\n      if (!cmd) {\n        throw new DefaultCommandNotFoundError(\n          this.defaultCommand,\n          this.getCommands(),\n        );\n      }\n      cmd._globalParent = this;\n\n      return cmd.execute(options, ...args);\n    }\n\n    return {\n      options,\n      args,\n      cmd: this,\n      literal: this.literalArgs,\n    };\n  }\n\n  /**\n   * Execute external sub-command.\n   * @param args Raw command line arguments.\n   */\n  protected async executeExecutable(args: string[]) {\n    const command = this.getPath().replace(/\\s+/g, \"-\");\n\n    await Deno.permissions.request({ name: \"run\", command });\n\n    try {\n      const process: Deno.Process = Deno.run({\n        cmd: [command, ...args],\n      });\n      const status: Deno.ProcessStatus = await process.status();\n\n      if (!status.success) {\n        Deno.exit(status.code);\n      }\n    } catch (error) {\n      if (error instanceof Deno.errors.NotFound) {\n        throw new CommandExecutableNotFoundError(command);\n      }\n      throw error;\n    }\n  }\n\n  /** Parse raw command line arguments. */\n  protected parseOptions(\n    ctx: ParseContext,\n    options: Option[],\n    {\n      stopEarly = this._stopEarly,\n      stopOnUnknown = false,\n      dotted = true,\n    }: ParseOptionsOptions = {},\n  ): void {\n    parseFlags(ctx, {\n      stopEarly,\n      stopOnUnknown,\n      dotted,\n      allowEmpty: this._allowEmpty,\n      flags: options,\n      ignoreDefaults: ctx.env,\n      parse: (type: ArgumentValue) => this.parseType(type),\n      option: (option: Option) => {\n        if (!ctx.action && option.action) {\n          ctx.action = option as ActionOption;\n        }\n      },\n    });\n  }\n\n  /** Parse argument type. */\n  protected parseType(type: ArgumentValue): unknown {\n    const typeSettings: TypeDef | undefined = this.getType(type.type);\n\n    if (!typeSettings) {\n      throw new UnknownTypeError(\n        type.type,\n        this.getTypes().map((type) => type.name),\n      );\n    }\n\n    return typeSettings.handler instanceof Type\n      ? typeSettings.handler.parse(type)\n      : typeSettings.handler(type);\n  }\n\n  /**\n   * Read and validate environment variables.\n   * @param ctx Parse context.\n   * @param envVars env vars defined by the command.\n   * @param validate when true, throws an error if a required env var is missing.\n   */\n  protected async parseEnvVars(\n    ctx: ParseContext,\n    envVars: Array<EnvVar>,\n    validate = true,\n  ): Promise<void> {\n    for (const envVar of envVars) {\n      const env = await this.findEnvVar(envVar.names);\n\n      if (env) {\n        const parseType = (value: string) => {\n          return this.parseType({\n            label: \"Environment variable\",\n            type: envVar.type,\n            name: env.name,\n            value,\n          });\n        };\n\n        const propertyName = underscoreToCamelCase(\n          envVar.prefix\n            ? envVar.names[0].replace(new RegExp(`^${envVar.prefix}`), \"\")\n            : envVar.names[0],\n        );\n\n        if (envVar.details.list) {\n          ctx.env[propertyName] = env.value\n            .split(envVar.details.separator ?? \",\")\n            .map(parseType);\n        } else {\n          ctx.env[propertyName] = parseType(env.value);\n        }\n\n        if (envVar.value && typeof ctx.env[propertyName] !== \"undefined\") {\n          ctx.env[propertyName] = envVar.value(ctx.env[propertyName]);\n        }\n      } else if (envVar.required && validate) {\n        throw new MissingRequiredEnvVarError(envVar);\n      }\n    }\n  }\n\n  protected async findEnvVar(\n    names: readonly string[],\n  ): Promise<{ name: string; value: string } | undefined> {\n    for (const name of names) {\n      const status = await Deno.permissions.query({\n        name: \"env\",\n        variable: name,\n      });\n\n      if (status.state === \"granted\") {\n        const value = Deno.env.get(name);\n\n        if (value) {\n          return { name, value };\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Parse command-line arguments.\n   * @param ctx     Parse context.\n   * @param options Parsed command line options.\n   */\n  protected parseArguments(\n    ctx: ParseContext,\n    options: Record<string, unknown>,\n  ): TCommandArguments {\n    const params: Array<unknown> = [];\n    const args = ctx.unknown.slice();\n\n    if (!this.hasArguments()) {\n      if (args.length) {\n        if (this.hasCommands(true)) {\n          if (this.hasCommand(args[0], true)) {\n            // e.g: command --global-foo --foo sub-command\n            throw new TooManyArgumentsError(args);\n          } else {\n            throw new UnknownCommandError(args[0], this.getCommands());\n          }\n        } else {\n          throw new NoArgumentsAllowedError(this.getPath());\n        }\n      }\n    } else {\n      if (!args.length) {\n        const required = this.getArguments()\n          .filter((expectedArg) => !expectedArg.optionalValue)\n          .map((expectedArg) => expectedArg.name);\n\n        if (required.length) {\n          const optionNames: string[] = Object.keys(options);\n          const hasStandaloneOption = !!optionNames.find((name) =>\n            this.getOption(name, true)?.standalone\n          );\n\n          if (!hasStandaloneOption) {\n            throw new MissingArgumentsError(required);\n          }\n        }\n      } else {\n        for (const expectedArg of this.getArguments()) {\n          if (!args.length) {\n            if (expectedArg.optionalValue) {\n              break;\n            }\n            throw new MissingArgumentError(expectedArg.name);\n          }\n\n          let arg: unknown;\n\n          const parseArgValue = (value: string) => {\n            return expectedArg.list\n              ? value.split(\",\").map((value) => parseArgType(value))\n              : parseArgType(value);\n          };\n\n          const parseArgType = (value: string) => {\n            return this.parseType({\n              label: \"Argument\",\n              type: expectedArg.type,\n              name: expectedArg.name,\n              value,\n            });\n          };\n\n          if (expectedArg.variadic) {\n            arg = args.splice(0, args.length).map((value) =>\n              parseArgValue(value)\n            );\n          } else {\n            arg = parseArgValue(args.shift() as string);\n          }\n\n          if (expectedArg.variadic && Array.isArray(arg)) {\n            params.push(...arg);\n          } else if (typeof arg !== \"undefined\") {\n            params.push(arg);\n          }\n        }\n\n        if (args.length) {\n          throw new TooManyArgumentsError(args);\n        }\n      }\n    }\n\n    return params as TCommandArguments;\n  }\n\n  private handleError(error: unknown): never {\n    this.throw(\n      error instanceof FlagsValidationError\n        ? new ValidationError(error.message)\n        : error instanceof Error\n        ? error\n        : new Error(`[non-error-thrown] ${error}`),\n    );\n  }\n\n  /**\n   * Handle error. If `throwErrors` is enabled the error will be thrown,\n   * otherwise a formatted error message will be printed and `Deno.exit(1)`\n   * will be called. This will also trigger registered error handlers.\n   *\n   * @param error The error to handle.\n   */\n  public throw(error: Error): never {\n    if (error instanceof ValidationError) {\n      error.cmd = this as unknown as Command;\n    }\n    this.getErrorHandler()?.(error, this as unknown as Command);\n\n    if (this.shouldThrowErrors() || !(error instanceof ValidationError)) {\n      throw error;\n    }\n    this.showHelp();\n\n    console.error(red(`  ${bold(\"error\")}: ${error.message}\\n`));\n\n    Deno.exit(error instanceof ValidationError ? error.exitCode : 1);\n  }\n\n  /*****************************************************************************\n   **** GETTER *****************************************************************\n   *****************************************************************************/\n\n  /** Get command name. */\n  public getName(): string {\n    return this._name;\n  }\n\n  /** Get parent command. */\n  public getParent(): TParentCommand {\n    return this._parent as TParentCommand;\n  }\n\n  /**\n   * Get parent command from global executed command.\n   * Be sure, to call this method only inside an action handler. Unless this or any child command was executed,\n   * this method returns always undefined.\n   */\n  public getGlobalParent(): Command<any> | undefined {\n    return this._globalParent;\n  }\n\n  /** Get main command. */\n  public getMainCommand(): Command<any> {\n    return this._parent?.getMainCommand() ?? this;\n  }\n\n  /** Get command name aliases. */\n  public getAliases(): string[] {\n    return this.aliases;\n  }\n\n  /** Get full command path. */\n  public getPath(): string {\n    return this._parent\n      ? this._parent.getPath() + \" \" + this._name\n      : this._name;\n  }\n\n  /** Get arguments definition. E.g: <input-file:string> <output-file:string> */\n  public getArgsDefinition(): string | undefined {\n    return this.argsDefinition;\n  }\n\n  /**\n   * Get argument by name.\n   * @param name Name of the argument.\n   */\n  public getArgument(name: string): Argument | undefined {\n    return this.getArguments().find((arg) => arg.name === name);\n  }\n\n  /** Get arguments. */\n  public getArguments(): Argument[] {\n    if (!this.args.length && this.argsDefinition) {\n      this.args = parseArgumentsDefinition(this.argsDefinition);\n    }\n\n    return this.args;\n  }\n\n  /** Check if command has arguments. */\n  public hasArguments() {\n    return !!this.argsDefinition;\n  }\n\n  /** Get command version. */\n  public getVersion(): string | undefined {\n    return this.getVersionHandler()?.call(this, this);\n  }\n\n  /** Get help handler method. */\n  private getVersionHandler(): VersionHandler | undefined {\n    return this.ver ?? this._parent?.getVersionHandler();\n  }\n\n  /** Get command description. */\n  public getDescription(): string {\n    // call description method only once\n    return typeof this.desc === \"function\"\n      ? this.desc = this.desc()\n      : this.desc;\n  }\n\n  public getUsage() {\n    return this._usage ?? this.getArgsDefinition();\n  }\n\n  /** Get short command description. This is the first line of the description. */\n  public getShortDescription(): string {\n    return getDescription(this.getDescription(), true);\n  }\n\n  /** Get original command-line arguments. */\n  public getRawArgs(): string[] {\n    return this.rawArgs;\n  }\n\n  /** Get all arguments defined after the double dash. */\n  public getLiteralArgs(): string[] {\n    return this.literalArgs;\n  }\n\n  /** Output generated help without exiting. */\n  public showVersion(): void {\n    console.log(this.getVersion());\n  }\n\n  /** Returns command name, version and meta data. */\n  public getLongVersion(): string {\n    return `${bold(this.getMainCommand().getName())} ${\n      brightBlue(this.getVersion() ?? \"\")\n    }` +\n      Object.entries(this.getMeta()).map(\n        ([k, v]) => `\\n${bold(k)} ${brightBlue(v)}`,\n      ).join(\"\");\n  }\n\n  /** Outputs command name, version and meta data. */\n  public showLongVersion(): void {\n    console.log(this.getLongVersion());\n  }\n\n  /** Output generated help without exiting. */\n  public showHelp(options?: HelpOptions): void {\n    console.log(this.getHelp(options));\n  }\n\n  /** Get generated help. */\n  public getHelp(options?: HelpOptions): string {\n    this.registerDefaults();\n    return this.getHelpHandler().call(this, this, options ?? {});\n  }\n\n  /** Get help handler method. */\n  private getHelpHandler(): HelpHandler {\n    return this._help ?? this._parent?.getHelpHandler() as HelpHandler;\n  }\n\n  private exit(code = 0) {\n    if (this.shouldExit()) {\n      Deno.exit(code);\n    }\n  }\n\n  /** Check if new version is available and add hint to version. */\n  public async checkVersion(): Promise<void> {\n    const mainCommand = this.getMainCommand();\n    const upgradeCommand = mainCommand.getCommand(\"upgrade\");\n\n    if (!isUpgradeCommand(upgradeCommand)) {\n      return;\n    }\n    const latestVersion = await upgradeCommand.getLatestVersion();\n    const currentVersion = mainCommand.getVersion();\n\n    if (currentVersion === latestVersion) {\n      return;\n    }\n    const versionHelpText =\n      `(New version available: ${latestVersion}. Run '${mainCommand.getName()} upgrade' to upgrade to the latest version!)`;\n\n    mainCommand.version(`${currentVersion}  ${bold(yellow(versionHelpText))}`);\n  }\n\n  /*****************************************************************************\n   **** Options GETTER *********************************************************\n   *****************************************************************************/\n\n  /**\n   * Checks whether the command has options or not.\n   * @param hidden Include hidden options.\n   */\n  public hasOptions(hidden?: boolean): boolean {\n    return this.getOptions(hidden).length > 0;\n  }\n\n  /**\n   * Get options.\n   * @param hidden Include hidden options.\n   */\n  public getOptions(hidden?: boolean): Option[] {\n    return this.getGlobalOptions(hidden).concat(this.getBaseOptions(hidden));\n  }\n\n  /**\n   * Get base options.\n   * @param hidden Include hidden options.\n   */\n  public getBaseOptions(hidden?: boolean): Option[] {\n    if (!this.options.length) {\n      return [];\n    }\n\n    return hidden\n      ? this.options.slice(0)\n      : this.options.filter((opt) => !opt.hidden);\n  }\n\n  /**\n   * Get global options.\n   * @param hidden Include hidden options.\n   */\n  public getGlobalOptions(hidden?: boolean): Option[] {\n    const helpOption = this.getHelpOption();\n    const getGlobals = (\n      cmd: Command<any>,\n      noGlobals: boolean,\n      options: Option[] = [],\n      names: string[] = [],\n    ): Option[] => {\n      if (cmd.options.length) {\n        for (const option of cmd.options) {\n          if (\n            option.global &&\n            !this.options.find((opt) => opt.name === option.name) &&\n            names.indexOf(option.name) === -1 &&\n            (hidden || !option.hidden)\n          ) {\n            if (noGlobals && option !== helpOption) {\n              continue;\n            }\n\n            names.push(option.name);\n            options.push(option);\n          }\n        }\n      }\n\n      return cmd._parent\n        ? getGlobals(\n          cmd._parent,\n          noGlobals || cmd._noGlobals,\n          options,\n          names,\n        )\n        : options;\n    };\n\n    return this._parent ? getGlobals(this._parent, this._noGlobals) : [];\n  }\n\n  /**\n   * Checks whether the command has an option with given name or not.\n   * @param name Name of the option. Must be in param-case.\n   * @param hidden Include hidden options.\n   */\n  public hasOption(name: string, hidden?: boolean): boolean {\n    return !!this.getOption(name, hidden);\n  }\n\n  /**\n   * Get option by name.\n   * @param name Name of the option. Must be in param-case.\n   * @param hidden Include hidden options.\n   */\n  public getOption(name: string, hidden?: boolean): Option | undefined {\n    return this.getBaseOption(name, hidden) ??\n      this.getGlobalOption(name, hidden);\n  }\n\n  /**\n   * Get base option by name.\n   * @param name Name of the option. Must be in param-case.\n   * @param hidden Include hidden options.\n   */\n  public getBaseOption(name: string, hidden?: boolean): Option | undefined {\n    const option = this.options.find((option) =>\n      option.name === name || option.aliases?.includes(name)\n    );\n\n    return option && (hidden || !option.hidden) ? option : undefined;\n  }\n\n  /**\n   * Get global option from parent commands by name.\n   * @param name Name of the option. Must be in param-case.\n   * @param hidden Include hidden options.\n   */\n  public getGlobalOption(name: string, hidden?: boolean): Option | undefined {\n    const helpOption = this.getHelpOption();\n    const getGlobalOption = (\n      parent: Command,\n      noGlobals: boolean,\n    ): Option | undefined => {\n      const option: Option | undefined = parent.getBaseOption(\n        name,\n        hidden,\n      );\n\n      if (!option?.global) {\n        return parent._parent && getGlobalOption(\n          parent._parent,\n          noGlobals || parent._noGlobals,\n        );\n      }\n      if (noGlobals && option !== helpOption) {\n        return;\n      }\n\n      return option;\n    };\n\n    return this._parent && getGlobalOption(\n      this._parent,\n      this._noGlobals,\n    );\n  }\n\n  /**\n   * Remove option by name.\n   * @param name Name of the option. Must be in param-case.\n   */\n  public removeOption(name: string): Option | undefined {\n    const index = this.options.findIndex((option) => option.name === name);\n\n    if (index === -1) {\n      return;\n    }\n\n    return this.options.splice(index, 1)[0];\n  }\n\n  /**\n   * Checks whether the command has sub-commands or not.\n   * @param hidden Include hidden commands.\n   */\n  public hasCommands(hidden?: boolean): boolean {\n    return this.getCommands(hidden).length > 0;\n  }\n\n  /**\n   * Get commands.\n   * @param hidden Include hidden commands.\n   */\n  public getCommands(hidden?: boolean): Array<Command<any>> {\n    return this.getGlobalCommands(hidden).concat(this.getBaseCommands(hidden));\n  }\n\n  /**\n   * Get base commands.\n   * @param hidden Include hidden commands.\n   */\n  public getBaseCommands(hidden?: boolean): Array<Command<any>> {\n    const commands = Array.from(this.commands.values());\n    return hidden ? commands : commands.filter((cmd) => !cmd.isHidden);\n  }\n\n  /**\n   * Get global commands.\n   * @param hidden Include hidden commands.\n   */\n  public getGlobalCommands(hidden?: boolean): Array<Command<any>> {\n    const getCommands = (\n      command: Command<any>,\n      noGlobals: boolean,\n      commands: Array<Command<any>> = [],\n      names: string[] = [],\n    ): Array<Command<any>> => {\n      if (command.commands.size) {\n        for (const [_, cmd] of command.commands) {\n          if (\n            cmd.isGlobal &&\n            this !== cmd &&\n            !this.commands.has(cmd._name) &&\n            names.indexOf(cmd._name) === -1 &&\n            (hidden || !cmd.isHidden)\n          ) {\n            if (noGlobals && cmd?.getName() !== \"help\") {\n              continue;\n            }\n\n            names.push(cmd._name);\n            commands.push(cmd);\n          }\n        }\n      }\n\n      return command._parent\n        ? getCommands(\n          command._parent,\n          noGlobals || command._noGlobals,\n          commands,\n          names,\n        )\n        : commands;\n    };\n\n    return this._parent ? getCommands(this._parent, this._noGlobals) : [];\n  }\n\n  /**\n   * Checks whether a child command exists by given name or alias.\n   * @param name Name or alias of the command.\n   * @param hidden Include hidden commands.\n   */\n  public hasCommand(name: string, hidden?: boolean): boolean {\n    return !!this.getCommand(name, hidden);\n  }\n\n  /**\n   * Get command by name or alias.\n   * @param name Name or alias of the command.\n   * @param hidden Include hidden commands.\n   */\n  public getCommand<TCommand extends Command<any>>(\n    name: string,\n    hidden?: boolean,\n  ): TCommand | undefined {\n    return this.getBaseCommand(name, hidden) ??\n      this.getGlobalCommand(name, hidden);\n  }\n\n  /**\n   * Get base command by name or alias.\n   * @param name Name or alias of the command.\n   * @param hidden Include hidden commands.\n   */\n  public getBaseCommand<TCommand extends Command<any>>(\n    name: string,\n    hidden?: boolean,\n  ): TCommand | undefined {\n    for (const cmd of this.commands.values()) {\n      if (cmd._name === name || cmd.aliases.includes(name)) {\n        return (cmd && (hidden || !cmd.isHidden) ? cmd : undefined) as\n          | TCommand\n          | undefined;\n      }\n    }\n  }\n\n  /**\n   * Get global command by name or alias.\n   * @param name Name or alias of the command.\n   * @param hidden Include hidden commands.\n   */\n  public getGlobalCommand<TCommand extends Command<any>>(\n    name: string,\n    hidden?: boolean,\n  ): TCommand | undefined {\n    const getGlobalCommand = (\n      parent: Command,\n      noGlobals: boolean,\n    ): Command | undefined => {\n      const cmd: Command | undefined = parent.getBaseCommand(name, hidden);\n\n      if (!cmd?.isGlobal) {\n        return parent._parent &&\n          getGlobalCommand(parent._parent, noGlobals || parent._noGlobals);\n      }\n      if (noGlobals && cmd.getName() !== \"help\") {\n        return;\n      }\n\n      return cmd;\n    };\n\n    return this._parent &&\n      getGlobalCommand(this._parent, this._noGlobals) as TCommand;\n  }\n\n  /**\n   * Remove sub-command by name or alias.\n   * @param name Name or alias of the command.\n   */\n  public removeCommand(name: string): Command<any> | undefined {\n    const command = this.getBaseCommand(name, true);\n\n    if (command) {\n      this.commands.delete(command._name);\n    }\n\n    return command;\n  }\n\n  /** Get types. */\n  public getTypes(): Array<TypeDef> {\n    return this.getGlobalTypes().concat(this.getBaseTypes());\n  }\n\n  /** Get base types. */\n  public getBaseTypes(): Array<TypeDef> {\n    return Array.from(this.types.values());\n  }\n\n  /** Get global types. */\n  public getGlobalTypes(): Array<TypeDef> {\n    const getTypes = (\n      cmd: Command<any> | undefined,\n      types: Array<TypeDef> = [],\n      names: Array<string> = [],\n    ): Array<TypeDef> => {\n      if (cmd) {\n        if (cmd.types.size) {\n          cmd.types.forEach((type: TypeDef) => {\n            if (\n              type.global &&\n              !this.types.has(type.name) &&\n              names.indexOf(type.name) === -1\n            ) {\n              names.push(type.name);\n              types.push(type);\n            }\n          });\n        }\n\n        return getTypes(cmd._parent, types, names);\n      }\n\n      return types;\n    };\n\n    return getTypes(this._parent);\n  }\n\n  /**\n   * Get type by name.\n   * @param name Name of the type.\n   */\n  public getType(name: string): TypeDef | undefined {\n    return this.getBaseType(name) ?? this.getGlobalType(name);\n  }\n\n  /**\n   * Get base type by name.\n   * @param name Name of the type.\n   */\n  public getBaseType(name: string): TypeDef | undefined {\n    return this.types.get(name);\n  }\n\n  /**\n   * Get global type by name.\n   * @param name Name of the type.\n   */\n  public getGlobalType(name: string): TypeDef | undefined {\n    if (!this._parent) {\n      return;\n    }\n\n    const cmd: TypeDef | undefined = this._parent.getBaseType(name);\n\n    if (!cmd?.global) {\n      return this._parent.getGlobalType(name);\n    }\n\n    return cmd;\n  }\n\n  /** Get completions. */\n  public getCompletions() {\n    return this.getGlobalCompletions().concat(this.getBaseCompletions());\n  }\n\n  /** Get base completions. */\n  public getBaseCompletions(): Completion[] {\n    return Array.from(this.completions.values());\n  }\n\n  /** Get global completions. */\n  public getGlobalCompletions(): Completion[] {\n    const getCompletions = (\n      cmd: Command<any> | undefined,\n      completions: Completion[] = [],\n      names: string[] = [],\n    ): Completion[] => {\n      if (cmd) {\n        if (cmd.completions.size) {\n          cmd.completions.forEach((completion: Completion) => {\n            if (\n              completion.global &&\n              !this.completions.has(completion.name) &&\n              names.indexOf(completion.name) === -1\n            ) {\n              names.push(completion.name);\n              completions.push(completion);\n            }\n          });\n        }\n\n        return getCompletions(cmd._parent, completions, names);\n      }\n\n      return completions;\n    };\n\n    return getCompletions(this._parent);\n  }\n\n  /**\n   * Get completion by name.\n   * @param name Name of the completion.\n   */\n  public getCompletion(name: string): Completion | undefined {\n    return this.getBaseCompletion(name) ?? this.getGlobalCompletion(name);\n  }\n\n  /**\n   * Get base completion by name.\n   * @param name Name of the completion.\n   */\n  public getBaseCompletion(name: string): Completion | undefined {\n    return this.completions.get(name);\n  }\n\n  /**\n   * Get global completions by name.\n   * @param name Name of the completion.\n   */\n  public getGlobalCompletion(name: string): Completion | undefined {\n    if (!this._parent) {\n      return;\n    }\n\n    const completion: Completion | undefined = this._parent.getBaseCompletion(\n      name,\n    );\n\n    if (!completion?.global) {\n      return this._parent.getGlobalCompletion(name);\n    }\n\n    return completion;\n  }\n\n  /**\n   * Checks whether the command has environment variables or not.\n   * @param hidden Include hidden environment variable.\n   */\n  public hasEnvVars(hidden?: boolean): boolean {\n    return this.getEnvVars(hidden).length > 0;\n  }\n\n  /**\n   * Get environment variables.\n   * @param hidden Include hidden environment variable.\n   */\n  public getEnvVars(hidden?: boolean): EnvVar[] {\n    return this.getGlobalEnvVars(hidden).concat(this.getBaseEnvVars(hidden));\n  }\n\n  /**\n   * Get base environment variables.\n   * @param hidden Include hidden environment variable.\n   */\n  public getBaseEnvVars(hidden?: boolean): EnvVar[] {\n    if (!this.envVars.length) {\n      return [];\n    }\n\n    return hidden\n      ? this.envVars.slice(0)\n      : this.envVars.filter((env) => !env.hidden);\n  }\n\n  /**\n   * Get global environment variables.\n   * @param hidden Include hidden environment variable.\n   */\n  public getGlobalEnvVars(hidden?: boolean): EnvVar[] {\n    if (this._noGlobals) {\n      return [];\n    }\n\n    const getEnvVars = (\n      cmd: Command<any> | undefined,\n      envVars: EnvVar[] = [],\n      names: string[] = [],\n    ): EnvVar[] => {\n      if (cmd) {\n        if (cmd.envVars.length) {\n          cmd.envVars.forEach((envVar: EnvVar) => {\n            if (\n              envVar.global &&\n              !this.envVars.find((env) => env.names[0] === envVar.names[0]) &&\n              names.indexOf(envVar.names[0]) === -1 &&\n              (hidden || !envVar.hidden)\n            ) {\n              names.push(envVar.names[0]);\n              envVars.push(envVar);\n            }\n          });\n        }\n\n        return getEnvVars(cmd._parent, envVars, names);\n      }\n\n      return envVars;\n    };\n\n    return getEnvVars(this._parent);\n  }\n\n  /**\n   * Checks whether the command has an environment variable with given name or not.\n   * @param name Name of the environment variable.\n   * @param hidden Include hidden environment variable.\n   */\n  public hasEnvVar(name: string, hidden?: boolean): boolean {\n    return !!this.getEnvVar(name, hidden);\n  }\n\n  /**\n   * Get environment variable by name.\n   * @param name Name of the environment variable.\n   * @param hidden Include hidden environment variable.\n   */\n  public getEnvVar(name: string, hidden?: boolean): EnvVar | undefined {\n    return this.getBaseEnvVar(name, hidden) ??\n      this.getGlobalEnvVar(name, hidden);\n  }\n\n  /**\n   * Get base environment variable by name.\n   * @param name Name of the environment variable.\n   * @param hidden Include hidden environment variable.\n   */\n  public getBaseEnvVar(name: string, hidden?: boolean): EnvVar | undefined {\n    const envVar: EnvVar | undefined = this.envVars.find((env) =>\n      env.names.indexOf(name) !== -1\n    );\n\n    return envVar && (hidden || !envVar.hidden) ? envVar : undefined;\n  }\n\n  /**\n   * Get global environment variable by name.\n   * @param name Name of the environment variable.\n   * @param hidden Include hidden environment variable.\n   */\n  public getGlobalEnvVar(name: string, hidden?: boolean): EnvVar | undefined {\n    if (!this._parent || this._noGlobals) {\n      return;\n    }\n\n    const envVar: EnvVar | undefined = this._parent.getBaseEnvVar(\n      name,\n      hidden,\n    );\n\n    if (!envVar?.global) {\n      return this._parent.getGlobalEnvVar(name, hidden);\n    }\n\n    return envVar;\n  }\n\n  /** Checks whether the command has examples or not. */\n  public hasExamples(): boolean {\n    return this.examples.length > 0;\n  }\n\n  /** Get all examples. */\n  public getExamples(): Example[] {\n    return this.examples;\n  }\n\n  /** Checks whether the command has an example with given name or not. */\n  public hasExample(name: string): boolean {\n    return !!this.getExample(name);\n  }\n\n  /** Get example with given name. */\n  public getExample(name: string): Example | undefined {\n    return this.examples.find((example) => example.name === name);\n  }\n\n  private getHelpOption(): Option | undefined {\n    return this._helpOption ?? this._parent?.getHelpOption();\n  }\n}\n\nfunction isUpgradeCommand(command: unknown): command is UpgradeCommandImpl {\n  return command instanceof Command && \"getLatestVersion\" in command;\n}\n\ninterface UpgradeCommandImpl {\n  getLatestVersion(): Promise<string>;\n}\n\ninterface DefaultOption {\n  flags: string;\n  desc?: string;\n  opts?: OptionOptions;\n}\n\ntype ActionOption = Option & { action: ActionHandler };\n\ninterface ParseContext extends ParseFlagsContext<Record<string, unknown>> {\n  action?: ActionOption;\n  env: Record<string, unknown>;\n}\n\ninterface ParseOptionsOptions {\n  stopEarly?: boolean;\n  stopOnUnknown?: boolean;\n  dotted?: boolean;\n}\n\ntype TrimLeft<TValue extends string, TTrimValue extends string | undefined> =\n  TValue extends `${TTrimValue}${infer TRest}` ? TRest\n    : TValue;\n\ntype TrimRight<TValue extends string, TTrimValue extends string> =\n  TValue extends `${infer TRest}${TTrimValue}` ? TRest\n    : TValue;\n\ntype Lower<TValue extends string> = TValue extends Uppercase<TValue>\n  ? Lowercase<TValue>\n  : Uncapitalize<TValue>;\n\ntype CamelCase<TValue extends string> = TValue extends\n  `${infer TPart}_${infer TRest}`\n  ? `${Lower<TPart>}${Capitalize<CamelCase<TRest>>}`\n  : TValue extends `${infer TPart}-${infer TRest}`\n    ? `${Lower<TPart>}${Capitalize<CamelCase<TRest>>}`\n  : Lower<TValue>;\n\ntype OneOf<TValue, TDefault> = TValue extends void ? TDefault : TValue;\n\ntype Merge<TLeft, TRight> = TLeft extends void ? TRight\n  : TRight extends void ? TLeft\n  : TLeft & TRight;\n\n// type Merge<L, R> = L extends void ? R\n//   : R extends void ? L\n//   : Omit<L, keyof R> & R;\n\ntype MergeRecursive<TLeft, TRight> = TLeft extends void ? TRight\n  : TRight extends void ? TLeft\n  : TLeft & TRight;\n\ntype OptionalOrRequiredValue<TType extends string> =\n  | `[${TType}]`\n  | `<${TType}>`;\ntype RestValue = `...${string}` | `${string}...`;\n\n/**\n * Rest args with list type and completions.\n *\n * - `[...name:type[]:completion]`\n * - `<...name:type[]:completion>`\n * - `[name...:type[]:completion]`\n * - `<name...:type[]:completion>`\n */\ntype RestArgsListTypeCompletion<TType extends string> = OptionalOrRequiredValue<\n  `${RestValue}:${TType}[]:${string}`\n>;\n\n/**\n * Rest args with list type.\n *\n * - `[...name:type[]]`\n * - `<...name:type[]>`\n * - `[name...:type[]]`\n * - `<name...:type[]>`\n */\ntype RestArgsListType<TType extends string> = OptionalOrRequiredValue<\n  `${RestValue}:${TType}[]`\n>;\n\n/**\n * Rest args with type and completions.\n *\n * - `[...name:type:completion]`\n * - `<...name:type:completion>`\n * - `[name...:type:completion]`\n * - `<name...:type:completion>`\n */\ntype RestArgsTypeCompletion<TType extends string> = OptionalOrRequiredValue<\n  `${RestValue}:${TType}:${string}`\n>;\n\n/**\n * Rest args with type.\n *\n * - `[...name:type]`\n * - `<...name:type>`\n * - `[name...:type]`\n * - `<name...:type>`\n */\ntype RestArgsType<TType extends string> = OptionalOrRequiredValue<\n  `${RestValue}:${TType}`\n>;\n\n/**\n * Rest args.\n * - `[...name]`\n * - `<...name>`\n * - `[name...]`\n * - `<name...>`\n */\ntype RestArgs = OptionalOrRequiredValue<\n  `${RestValue}`\n>;\n\n/**\n * Single arg with list type and completions.\n *\n * - `[name:type[]:completion]`\n * - `<name:type[]:completion>`\n */\ntype SingleArgListTypeCompletion<TType extends string> =\n  OptionalOrRequiredValue<\n    `${string}:${TType}[]:${string}`\n  >;\n\n/**\n * Single arg with list type.\n *\n * - `[name:type[]]`\n * - `<name:type[]>`\n */\ntype SingleArgListType<TType extends string> = OptionalOrRequiredValue<\n  `${string}:${TType}[]`\n>;\n\n/**\n * Single arg  with type and completion.\n *\n * - `[name:type:completion]`\n * - `<name:type:completion>`\n */\ntype SingleArgTypeCompletion<TType extends string> = OptionalOrRequiredValue<\n  `${string}:${TType}:${string}`\n>;\n\n/**\n * Single arg with type.\n *\n * - `[name:type]`\n * - `<name:type>`\n */\ntype SingleArgType<TType extends string> = OptionalOrRequiredValue<\n  `${string}:${TType}`\n>;\n\n/**\n * Single arg.\n *\n * - `[name]`\n * - `<name>`\n */\ntype SingleArg = OptionalOrRequiredValue<\n  `${string}`\n>;\n\ntype DefaultTypes = {\n  number: NumberType;\n  integer: IntegerType;\n  string: StringType;\n  boolean: BooleanType;\n  file: FileType;\n};\n\ntype ArgumentType<\n  TArg extends string,\n  TCustomTypes,\n  TTypes = Merge<DefaultTypes, TCustomTypes>,\n> = TArg extends RestArgsListTypeCompletion<infer Type>\n  ? TTypes extends Record<Type, infer R> ? Array<Array<R>> : unknown\n  : TArg extends RestArgsListType<infer Type>\n    ? TTypes extends Record<Type, infer R> ? Array<Array<R>> : unknown\n  : TArg extends RestArgsTypeCompletion<infer Type>\n    ? TTypes extends Record<Type, infer R> ? Array<R> : unknown\n  : TArg extends RestArgsType<infer Type>\n    ? TTypes extends Record<Type, infer R> ? Array<R> : unknown\n  : TArg extends RestArgs ? Array<string>\n  : TArg extends SingleArgListTypeCompletion<infer Type>\n    ? TTypes extends Record<Type, infer R> ? Array<R> : unknown\n  : TArg extends SingleArgListType<infer Type>\n    ? TTypes extends Record<Type, infer R> ? Array<R> : unknown\n  : TArg extends SingleArgTypeCompletion<infer Type>\n    ? TTypes extends Record<Type, infer R> ? R : unknown\n  : TArg extends SingleArgType<infer Type>\n    ? TTypes extends Record<Type, infer R> ? R : unknown\n  : TArg extends SingleArg ? string\n  : unknown;\n\ntype ArgumentTypes<TFlags extends string, T> = TFlags extends\n  `${string} ${string}` ? TypedArguments<TFlags, T>\n  : ArgumentType<TFlags, T>;\n\ntype GetArguments<TFlags extends string> = TFlags extends\n  `-${string}=${infer RestFlags}` ? GetArguments<RestFlags>\n  : TFlags extends `-${string} ${infer RestFlags}` ? GetArguments<RestFlags>\n  : TFlags;\n\ntype OptionName<Name extends string> = Name extends \"*\" ? string\n  : CamelCase<TrimRight<Name, \",\">>;\n\ntype IsRequired<TRequired extends boolean | undefined, TDefault> =\n  TRequired extends true ? true\n    : TDefault extends undefined ? false\n    : true;\n\ntype NegatableOption<\n  TName extends string,\n  TOptions,\n  TDefault,\n> = TDefault extends undefined\n  ? OptionName<TName> extends keyof TOptions\n    ? { [Key in OptionName<TName>]?: false }\n  : { [Key in OptionName<TName>]: boolean }\n  : { [Key in OptionName<TName>]: NonNullable<TDefault> | false };\n\ntype BooleanOption<\n  TName extends string,\n  TOptions,\n  TRequired extends boolean | undefined = undefined,\n  TDefault = undefined,\n> = TName extends `no-${infer Name}` ? NegatableOption<Name, TOptions, TDefault>\n  : TName extends `${infer Name}.${infer Rest}` ? (TRequired extends true ? {\n        [Key in OptionName<Name>]: BooleanOption<\n          Rest,\n          TOptions,\n          TRequired,\n          TDefault\n        >;\n      }\n      : {\n        [Key in OptionName<Name>]?: BooleanOption<\n          Rest,\n          TOptions,\n          TRequired,\n          TDefault\n        >;\n      })\n  : (TRequired extends true ? { [Key in OptionName<TName>]: true | TDefault }\n    : { [Key in OptionName<TName>]?: true | TDefault });\n\ntype ValueOption<\n  TName extends string,\n  TRestFlags extends string,\n  TTypes,\n  TRequired extends boolean | undefined = undefined,\n  TDefault = undefined,\n> = TName extends `${infer Name}.${infer RestName}`\n  ? (TRequired extends true ? {\n      [Key in OptionName<Name>]: ValueOption<\n        RestName,\n        TRestFlags,\n        TTypes,\n        TRequired,\n        TDefault\n      >;\n    }\n    : {\n      [Key in OptionName<Name>]?: ValueOption<\n        RestName,\n        TRestFlags,\n        TTypes,\n        TRequired,\n        TDefault\n      >;\n    })\n  : (TRequired extends true ? {\n      [Key in OptionName<TName>]: GetArguments<TRestFlags> extends `[${string}]`\n        ? \n          | NonNullable<TDefault>\n          | true\n          | ArgumentType<GetArguments<TRestFlags>, TTypes>\n        : \n          | NonNullable<TDefault>\n          | ArgumentType<GetArguments<TRestFlags>, TTypes>;\n    }\n    : {\n      [Key in OptionName<TName>]?: GetArguments<TRestFlags> extends\n        `[${string}]` ? \n          | NonNullable<TDefault>\n          | true\n          | ArgumentType<GetArguments<TRestFlags>, TTypes>\n        : \n          | NonNullable<TDefault>\n          | ArgumentType<GetArguments<TRestFlags>, TTypes>;\n    });\n\ntype ValuesOption<\n  TName extends string,\n  TRestFlags extends string,\n  TTypes,\n  TRequired extends boolean | undefined = undefined,\n  TDefault = undefined,\n> = TName extends `${infer Name}.${infer RestName}`\n  ? (TRequired extends true ? {\n      [Key in OptionName<Name>]: ValuesOption<\n        RestName,\n        TRestFlags,\n        TTypes,\n        TRequired,\n        TDefault\n      >;\n    }\n    : {\n      [Key in OptionName<Name>]?: ValuesOption<\n        RestName,\n        TRestFlags,\n        TTypes,\n        TRequired,\n        TDefault\n      >;\n    })\n  : (TRequired extends true ? {\n      [Key in OptionName<TName>]: GetArguments<TRestFlags> extends `[${string}]`\n        ? \n          | NonNullable<TDefault>\n          | true\n          | ArgumentTypes<GetArguments<TRestFlags>, TTypes>\n        : \n          | NonNullable<TDefault>\n          | ArgumentTypes<GetArguments<TRestFlags>, TTypes>;\n    }\n    : {\n      [Key in OptionName<TName>]?: GetArguments<TRestFlags> extends\n        `[${string}]` ? \n          | NonNullable<TDefault>\n          | true\n          | ArgumentTypes<GetArguments<TRestFlags>, TTypes>\n        : \n          | NonNullable<TDefault>\n          | ArgumentTypes<GetArguments<TRestFlags>, TTypes>;\n    });\n\ntype MapValue<TOptions, TMappedOptions, TCollect = undefined> =\n  TMappedOptions extends undefined ? TCollect extends true ? {\n        [Key in keyof TOptions]: TOptions[Key] extends\n          (Record<string, unknown> | undefined)\n          ? MapValue<TOptions[Key], TMappedOptions>\n          : Array<NonNullable<TOptions[Key]>>;\n      }\n    : TOptions\n    : {\n      [Key in keyof TOptions]: TOptions[Key] extends\n        (Record<string, unknown> | undefined)\n        ? MapValue<TOptions[Key], TMappedOptions>\n        : TMappedOptions;\n    };\n\ntype GetOptionName<TFlags> = TFlags extends `${string}--${infer Name}=${string}`\n  ? TrimRight<Name, \",\">\n  : TFlags extends `${string}--${infer Name} ${string}` ? TrimRight<Name, \",\">\n  : TFlags extends `${string}--${infer Name}` ? Name\n  : TFlags extends `-${infer Name}=${string}` ? TrimRight<Name, \",\">\n  : TFlags extends `-${infer Name} ${string}` ? TrimRight<Name, \",\">\n  : TFlags extends `-${infer Name}` ? Name\n  : unknown;\n\ntype MergeOptions<\n  TFlags,\n  TOptions,\n  TMappedOptions,\n  TName = GetOptionName<TFlags>,\n> = TName extends `no-${string}` ? Spread<TOptions, TMappedOptions>\n  : TName extends `${string}.${string}`\n    ? MergeRecursive<TOptions, TMappedOptions>\n  : Merge<TOptions, TMappedOptions>;\n\n// type MergeOptions<T, CO, O, N = GetOptionName<T>> = N extends `no-${string}`\n//   ? Spread<CO, O>\n//   : N extends `${infer Name}.${infer Child}`\n//     ? (OptionName<Name> extends keyof Merge<CO, O>\n//       ? OptionName<Child> extends\n//         keyof NonNullable<Merge<CO, O>[OptionName<Name>]> ? SpreadTwo<CO, O>\n//       : MergeRecursive<CO, O>\n//       : MergeRecursive<CO, O>)\n//   : Merge<CO, O>;\n\ntype TypedOption<\n  TFlags extends string,\n  TOptions,\n  TTypes,\n  TRequired extends boolean | undefined = undefined,\n  TDefault = undefined,\n> = number extends TTypes ? any\n  : TFlags extends `${string}--${infer Name}=${infer TRestFlags}`\n    ? ValuesOption<\n      Name,\n      TRestFlags,\n      TTypes,\n      IsRequired<TRequired, TDefault>,\n      TDefault\n    >\n  : TFlags extends `${string}--${infer Name} ${infer TRestFlags}`\n    ? ValuesOption<\n      Name,\n      TRestFlags,\n      TTypes,\n      IsRequired<TRequired, TDefault>,\n      TDefault\n    >\n  : TFlags extends `${string}--${infer Name}`\n    ? BooleanOption<Name, TOptions, IsRequired<TRequired, TDefault>, TDefault>\n  : TFlags extends `-${infer Name}=${infer TRestFlags}` ? ValuesOption<\n      Name,\n      TRestFlags,\n      TTypes,\n      IsRequired<TRequired, TDefault>,\n      TDefault\n    >\n  : TFlags extends `-${infer Name} ${infer TRestFlags}` ? ValuesOption<\n      Name,\n      TRestFlags,\n      TTypes,\n      IsRequired<TRequired, TDefault>,\n      TDefault\n    >\n  : TFlags extends `-${infer Name}`\n    ? BooleanOption<Name, TOptions, IsRequired<TRequired, TDefault>, TDefault>\n  : Record<string, unknown>;\n\ntype TypedArguments<TArgs extends string, TTypes> = number extends TTypes ? any\n  : TArgs extends `${infer TArg} ${infer TRestArgs}`\n    ? TArg extends `[${string}]`\n      ? [ArgumentType<TArg, TTypes>?, ...TypedArguments<TRestArgs, TTypes>]\n    : [ArgumentType<TArg, TTypes>, ...TypedArguments<TRestArgs, TTypes>]\n  : TArgs extends `${string}...${string}` ? [\n      ...ArgumentType<TArgs, TTypes> extends Array<infer TValue>\n        ? TArgs extends `[${string}]` ? Array<TValue>\n        : [TValue, ...Array<TValue>]\n        : never,\n    ]\n  : TArgs extends `[${string}]` ? [ArgumentType<TArgs, TTypes>?]\n  : [ArgumentType<TArgs, TTypes>];\n\ntype TypedCommandArguments<TNameAndArguments extends string, TTypes> =\n  number extends TTypes ? any\n    : TNameAndArguments extends `${string} ${infer TFlags}`\n      ? TypedArguments<TFlags, TTypes>\n    : [];\n\ntype TypedEnv<\n  TNameAndValue extends string,\n  TPrefix extends string | undefined,\n  TOptions,\n  TTypes,\n  TRequired extends boolean | undefined = undefined,\n  TDefault = undefined,\n> = number extends TTypes ? any\n  : TNameAndValue extends `${infer Name}=${infer Rest}`\n    ? ValueOption<TrimLeft<Name, TPrefix>, Rest, TTypes, TRequired, TDefault>\n  : TNameAndValue extends `${infer Name} ${infer Rest}`\n    ? ValueOption<TrimLeft<Name, TPrefix>, Rest, TTypes, TRequired, TDefault>\n  : TNameAndValue extends `${infer Name}`\n    ? BooleanOption<TrimLeft<Name, TPrefix>, TOptions, TRequired, TDefault>\n  : Record<string, unknown>;\n\ntype TypedType<\n  TName extends string,\n  THandler extends TypeOrTypeHandler<unknown>,\n> = { [Name in TName]: THandler };\n\ntype RequiredKeys<TRecord> = {\n  // deno-lint-ignore ban-types\n  [Key in keyof TRecord]-?: {} extends Pick<TRecord, Key> ? never : Key;\n}[keyof TRecord];\n\ntype OptionalKeys<TRecord> = {\n  // deno-lint-ignore ban-types\n  [Key in keyof TRecord]-?: {} extends Pick<TRecord, Key> ? Key : never;\n}[keyof TRecord];\n\ntype SpreadRequiredProperties<\n  TTarget,\n  TSource,\n  TKeys extends keyof TTarget & keyof TSource,\n> = {\n  [Key in TKeys]:\n    | Exclude<TTarget[Key], undefined>\n    | Exclude<TSource[Key], undefined>;\n};\n\ntype SpreadOptionalProperties<\n  TTarget,\n  TSource,\n  TKeys extends keyof TTarget & keyof TSource,\n> = {\n  [Key in TKeys]?: TTarget[Key] | TSource[Key];\n};\n\n/** Merge types of two objects. */\ntype Spread<TTarget, TSource> = TTarget extends void ? TSource\n  : TSource extends void ? TTarget\n  // Properties in L that don't exist in R.\n  : \n    & Omit<TTarget, keyof TSource>\n    // Properties in R that don't exist in L.\n    & Omit<TSource, keyof TTarget>\n    // Required properties in R that exist in L.\n    & SpreadRequiredProperties<\n      TTarget,\n      TSource,\n      RequiredKeys<TSource> & keyof TTarget\n    >\n    // Required properties in L that exist in R.\n    & SpreadRequiredProperties<\n      TTarget,\n      TSource,\n      RequiredKeys<TTarget> & keyof TSource\n    >\n    // Optional properties in L and R.\n    & SpreadOptionalProperties<\n      TTarget,\n      TSource,\n      OptionalKeys<TTarget> & OptionalKeys<TSource>\n    >;\n\ntype ValueOf<TValue> = TValue extends Record<string, infer V> ? ValueOf<V>\n  : TValue;\n", "/** Base key mapping. */\nexport const KeyMap: Record<string, string> = {\n  /* xterm/gnome ESC [ letter (with modifier) */\n  \"[P\": \"f1\",\n  \"[Q\": \"f2\",\n  \"[R\": \"f3\",\n  \"[S\": \"f4\",\n\n  /* xterm/gnome ESC O letter (without modifier) */\n  \"OP\": \"f1\",\n  \"OQ\": \"f2\",\n  \"OR\": \"f3\",\n  \"OS\": \"f4\",\n\n  /* xterm/rxvt ESC [ number ~ */\n  \"[11~\": \"f1\",\n  \"[12~\": \"f2\",\n  \"[13~\": \"f3\",\n  \"[14~\": \"f4\",\n\n  /* from Cygwin and used in libuv */\n  \"[[A\": \"f1\",\n  \"[[B\": \"f2\",\n  \"[[C\": \"f3\",\n  \"[[D\": \"f4\",\n  \"[[E\": \"f5\",\n\n  /* common */\n  \"[15~\": \"f5\",\n  \"[17~\": \"f6\",\n  \"[18~\": \"f7\",\n  \"[19~\": \"f8\",\n  \"[20~\": \"f9\",\n  \"[21~\": \"f10\",\n  \"[23~\": \"f11\",\n  \"[24~\": \"f12\",\n\n  /* xterm ESC [ letter */\n  \"[A\": \"up\",\n  \"[B\": \"down\",\n  \"[C\": \"right\",\n  \"[D\": \"left\",\n  \"[E\": \"clear\",\n  \"[F\": \"end\",\n  \"[H\": \"home\",\n\n  /* xterm/gnome ESC O letter */\n  \"OA\": \"up\",\n  \"OB\": \"down\",\n  \"OC\": \"right\",\n  \"OD\": \"left\",\n  \"OE\": \"clear\",\n  \"OF\": \"end\",\n  \"OH\": \"home\",\n\n  /* xterm/rxvt ESC [ number ~ */\n  \"[1~\": \"home\",\n  \"[2~\": \"insert\",\n  \"[3~\": \"delete\",\n  \"[4~\": \"end\",\n  \"[5~\": \"pageup\",\n  \"[6~\": \"pagedown\",\n\n  /* putty */\n  \"[[5~\": \"pageup\",\n  \"[[6~\": \"pagedown\",\n\n  /* rxvt */\n  \"[7~\": \"home\",\n  \"[8~\": \"end\",\n};\n\n/** Shift key mapping. */\nexport const KeyMapShift: Record<string, string> = {\n  /* rxvt keys with modifiers */\n  \"[a\": \"up\",\n  \"[b\": \"down\",\n  \"[c\": \"right\",\n  \"[d\": \"left\",\n  \"[e\": \"clear\",\n\n  \"[2$\": \"insert\",\n  \"[3$\": \"delete\",\n  \"[5$\": \"pageup\",\n  \"[6$\": \"pagedown\",\n  \"[7$\": \"home\",\n  \"[8$\": \"end\",\n\n  \"[Z\": \"tab\",\n};\n\n/** Ctrl key mapping. */\nexport const KeyMapCtrl: Record<string, string> = {\n  /* rxvt keys with modifiers */\n  \"Oa\": \"up\",\n  \"Ob\": \"down\",\n  \"Oc\": \"right\",\n  \"Od\": \"left\",\n  \"Oe\": \"clear\",\n\n  \"[2^\": \"insert\",\n  \"[3^\": \"delete\",\n  \"[5^\": \"pageup\",\n  \"[6^\": \"pagedown\",\n  \"[7^\": \"home\",\n  \"[8^\": \"end\",\n};\n\n/** Special key mapping. */\nexport const SpecialKeyMap: Record<string, string> = {\n  \"\\r\": \"return\",\n  \"\\n\": \"enter\",\n  \"\\t\": \"tab\",\n  \"\\b\": \"backspace\",\n  \"\\x7f\": \"backspace\",\n  \"\\x1b\": \"escape\",\n  \" \": \"space\",\n};\n", "import { KeyMap, KeyMapCtrl, KeyMapShift, SpecialKeyMap } from \"./key_codes.ts\";\n\n// https://en.wikipedia.org/wiki/ANSI_escape_code\n// https://github.com/nodejs/node/blob/v13.13.0/lib/internal/readline/utils.js\n\nconst kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nconst kEscape = \"\\x1b\";\n\nexport interface KeyCode {\n  name?: string;\n  sequence?: string;\n  code?: string;\n  ctrl?: boolean;\n  meta?: boolean;\n  shift?: boolean;\n  char?: string;\n}\n\n/**\n * Parse ansi escape sequence.\n * @param data Ansi escape sequence.\n * ```\n * parse(\"\\x04\\x18\");\n * ```\n * ```\n * [\n *   KeyCode { name: \"d\", sequence: \"\\x04\", ctrl: true, meta: false, shift: false },\n *   KeyCode { name: \"x\", sequence: \"\\x18\", ctrl: true, meta: false, shift: false },\n * ]\n * ```\n */\nexport function parse(data: Uint8Array | string): KeyCode[] {\n  /*\n   * Some patterns seen in terminal key escape codes, derived from combos seen\n   * at http://www.midnight-commander.org/browser/lib/tty/key.c\n   *\n   * ESC letter\n   * ESC [ letter\n   * ESC [ modifier letter\n   * ESC [ 1 ; modifier letter\n   * ESC [ num char\n   * ESC [ num ; modifier char\n   * ESC O letter\n   * ESC O modifier letter\n   * ESC O 1 ; modifier letter\n   * ESC N letter\n   * ESC [ [ num ; modifier char\n   * ESC [ [ 1 ; modifier letter\n   * ESC ESC [ num char\n   * ESC ESC O letter\n   *\n   * - char is usually ~ but $ and ^ also happen with rxvt\n   * - modifier is 1 +\n   *               (shift     * 1) +\n   *               (left_alt  * 2) +\n   *               (ctrl      * 4) +\n   *               (right_alt * 8)\n   * - two leading ESCs apparently mean the same as one leading ESC\n   */\n  let index = -1;\n  const keys: KeyCode[] = [];\n  const input: string = data instanceof Uint8Array\n    ? new TextDecoder().decode(data)\n    : data;\n\n  const hasNext = () => input.length - 1 >= index + 1;\n  const next = () => input[++index];\n\n  parseNext();\n\n  return keys;\n\n  function parseNext() {\n    let ch: string = next();\n    let s: string = ch;\n    let escaped = false;\n\n    const key: KeyCode = {\n      name: undefined,\n      char: undefined,\n      sequence: undefined,\n      code: undefined,\n      ctrl: false,\n      meta: false,\n      shift: false,\n    };\n\n    if (ch === kEscape && hasNext()) {\n      escaped = true;\n      s += ch = next();\n\n      if (ch === kEscape) {\n        s += ch = next();\n      }\n    }\n\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      // ANSI escape sequence\n      let code: string = ch;\n      let modifier = 0;\n\n      if (ch === \"O\") {\n        // ESC O letter\n        // ESC O modifier letter\n        s += ch = next();\n\n        if (ch >= \"0\" && ch <= \"9\") {\n          modifier = (Number(ch) >> 0) - 1;\n          s += ch = next();\n        }\n\n        code += ch;\n      } else if (ch === \"[\") {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += ch = next();\n\n        if (ch === \"[\") {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += ch = next();\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional, e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional, e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional, e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         */\n        const cmdStart: number = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= \"0\" && ch <= \"9\") {\n          s += ch = next();\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += ch = next();\n          }\n        }\n\n        // skip modifier\n        if (ch === \";\") {\n          s += ch = next();\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += next();\n          }\n        }\n\n        /*\n         * We buffered enough data, now trying to extract code\n         * and modifier from it\n         */\n        const cmd: string = s.slice(cmdStart);\n        let match: RegExpMatchArray | null;\n\n        if ((match = cmd.match(/^(\\d\\d?)(;(\\d))?([~^$])$/))) {\n          code += match[1] + match[4];\n          modifier = (Number(match[3]) || 1) - 1;\n        } else if ((match = cmd.match(/^((\\d;)?(\\d))?([A-Za-z])$/))) {\n          code += match[4];\n          modifier = (Number(match[3]) || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      key.ctrl = !!(modifier & 4);\n      key.meta = !!(modifier & 10);\n      key.shift = !!(modifier & 1);\n      key.code = code;\n\n      // Parse the key itself\n      if (code in KeyMap) {\n        key.name = KeyMap[code];\n      } else if (code in KeyMapShift) {\n        key.name = KeyMapShift[code];\n        key.shift = true;\n      } else if (code in KeyMapCtrl) {\n        key.name = KeyMapCtrl[code];\n        key.ctrl = true;\n      } else {\n        key.name = \"undefined\";\n      }\n    } else if (ch in SpecialKeyMap) {\n      key.name = SpecialKeyMap[ch];\n      key.meta = escaped;\n\n      if (key.name === \"space\") {\n        key.char = ch;\n      }\n    } else if (!escaped && ch <= \"\\x1a\") {\n      // ctrl+letter\n      key.name = String.fromCharCode(\n        ch.charCodeAt(0) + \"a\".charCodeAt(0) - 1,\n      );\n      key.ctrl = true;\n\n      key.char = key.name;\n    } else if (/^[0-9A-Za-z]$/.test(ch)) {\n      // Letter, number, shift+letter\n      key.name = ch.toLowerCase();\n      key.shift = /^[A-Z]$/.test(ch);\n      key.meta = escaped;\n      key.char = ch;\n    } else if (escaped) {\n      // Escape sequence timeout\n      key.name = ch.length ? undefined : \"escape\";\n      key.meta = true;\n    } else {\n      key.name = ch;\n      key.char = ch;\n    }\n\n    key.sequence = s;\n\n    if (\n      (s.length !== 0 && (key.name !== undefined || escaped)) ||\n      charLengthAt(s, 0) === s.length\n    ) {\n      keys.push(key);\n    } else {\n      throw new Error(\"Unrecognized or broken escape sequence\");\n    }\n\n    if (hasNext()) {\n      parseNext();\n    }\n  }\n}\n\nfunction charLengthAt(str: string, i: number): number {\n  const pos: number | undefined = str.codePointAt(i);\n  if (typeof pos === \"undefined\") {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return pos >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n", "const main = {\n  ARROW_UP: \"\u2191\",\n  ARROW_DOWN: \"\u2193\",\n  ARROW_LEFT: \"\u2190\",\n  ARROW_RIGHT: \"\u2192\",\n  ARROW_UP_LEFT: \"\u2196\",\n  ARROW_UP_RIGHT: \"\u2197\",\n  ARROW_DOWN_RIGHT: \"\u2198\",\n  ARROW_DOWN_LEFT: \"\u2199\",\n  RADIO_ON: \"\u25C9\",\n  RADIO_OFF: \"\u25EF\",\n  TICK: \"\u2714\",\n  CROSS: \"\u2718\",\n  ELLIPSIS: \"\u2026\",\n  POINTER_SMALL: \"\u203A\",\n  LINE: \"\u2500\",\n  POINTER: \"\u276F\",\n  INFO: \"\u2139\",\n  TAB_LEFT: \"\u21E4\",\n  TAB_RIGHT: \"\u21E5\",\n  ESCAPE: \"\u238B\",\n  BACKSPACE: \"\u232B\",\n  PAGE_UP: \"\u21DE\",\n  PAGE_DOWN: \"\u21DF\",\n  ENTER: \"\u21B5\",\n  SEARCH: \"\u2315\",\n};\n\nconst win = {\n  ...main,\n  RADIO_ON: \"(*)\",\n  RADIO_OFF: \"( )\",\n  TICK: \"\u221A\",\n  CROSS: \"\u00D7\",\n  POINTER_SMALL: \"\u00BB\",\n};\n\n/** Prompt icons. */\nexport const Figures = Deno.build.os === \"windows\" ? win : main;\n\nconst keyMap: Record<string, keyof typeof Figures> = {\n  up: \"ARROW_UP\",\n  down: \"ARROW_DOWN\",\n  left: \"ARROW_LEFT\",\n  right: \"ARROW_RIGHT\",\n  pageup: \"PAGE_UP\",\n  pagedown: \"PAGE_DOWN\",\n  tab: \"TAB_RIGHT\",\n  enter: \"ENTER\",\n  return: \"ENTER\",\n};\n\nexport function getFiguresByKeys(keys: Array<string>): Array<string> {\n  const figures: Array<string> = [];\n  for (const key of keys) {\n    const figure = Figures[keyMap[key]] ?? key;\n    if (!figures.includes(figure)) {\n      figures.push(figure);\n    }\n  }\n  return figures;\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nexport type OSType = \"windows\" | \"linux\" | \"darwin\" | \"freebsd\";\n\nexport const osType: OSType = (() => {\n  // deno-lint-ignore no-explicit-any\n  const { Deno } = globalThis as any;\n  if (typeof Deno?.build?.os === \"string\") {\n    return Deno.build.os;\n  }\n\n  // deno-lint-ignore no-explicit-any\n  const { navigator } = globalThis as any;\n  if (navigator?.appVersion?.includes?.(\"Win\")) {\n    return \"windows\";\n  }\n\n  return \"linux\";\n})();\n\nexport const isWindows = osType === \"windows\";\nexport const isLinux = osType === \"linux\";\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject, ParsedPath } from \"./_interface.ts\";\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_DOT,\n  CHAR_QUESTION_MARK,\n} from \"./_constants.ts\";\n\nimport {\n  _format,\n  assertPath,\n  encodeWhitespace,\n  isPathSeparator,\n  isWindowsDeviceRoot,\n  normalizeString,\n} from \"./_util.ts\";\nimport { assert } from \"../_util/asserts.ts\";\n\nexport const sep = \"\\\\\";\nexport const delimiter = \";\";\n\n/**\n * Resolves path segments into a `path`\n * @param pathSegments to process to path\n */\nexport function resolve(...pathSegments: string[]): string {\n  let resolvedDevice = \"\";\n  let resolvedTail = \"\";\n  let resolvedAbsolute = false;\n\n  for (let i = pathSegments.length - 1; i >= -1; i--) {\n    let path: string;\n    // deno-lint-ignore no-explicit-any\n    const { Deno } = globalThis as any;\n    if (i >= 0) {\n      path = pathSegments[i];\n    } else if (!resolvedDevice) {\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a drive-letter-less path without a CWD.\");\n      }\n      path = Deno.cwd();\n    } else {\n      if (\n        typeof Deno?.env?.get !== \"function\" || typeof Deno?.cwd !== \"function\"\n      ) {\n        throw new TypeError(\"Resolved a relative path without a CWD.\");\n      }\n      path = Deno.cwd();\n\n      // Verify that a cwd was found and that it actually points\n      // to our drive. If not, default to the drive's root.\n      if (\n        path === undefined ||\n        path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\\\`\n      ) {\n        path = `${resolvedDevice}\\\\`;\n      }\n    }\n\n    assertPath(path);\n\n    const len = path.length;\n\n    // Skip empty entries\n    if (len === 0) continue;\n\n    let rootEnd = 0;\n    let device = \"\";\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n\n    // Try to match a root\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last)}`;\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator\n      rootEnd = 1;\n      isAbsolute = true;\n    }\n\n    if (\n      device.length > 0 &&\n      resolvedDevice.length > 0 &&\n      device.toLowerCase() !== resolvedDevice.toLowerCase()\n    ) {\n      // This path points to another device so it is not applicable\n      continue;\n    }\n\n    if (resolvedDevice.length === 0 && device.length > 0) {\n      resolvedDevice = device;\n    }\n    if (!resolvedAbsolute) {\n      resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n      resolvedAbsolute = isAbsolute;\n    }\n\n    if (resolvedAbsolute && resolvedDevice.length > 0) break;\n  }\n\n  // At this point the path should be resolved to a full absolute path,\n  // but handle relative paths to be safe (might happen when process.cwd()\n  // fails)\n\n  // Normalize the tail path\n  resolvedTail = normalizeString(\n    resolvedTail,\n    !resolvedAbsolute,\n    \"\\\\\",\n    isPathSeparator,\n  );\n\n  return resolvedDevice + (resolvedAbsolute ? \"\\\\\" : \"\") + resolvedTail || \".\";\n}\n\n/**\n * Normalizes a `path`\n * @param path to normalize\n */\nexport function normalize(path: string): string {\n  assertPath(path);\n  const len = path.length;\n  if (len === 0) return \".\";\n  let rootEnd = 0;\n  let device: string | undefined;\n  let isAbsolute = false;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            // Treat separator following drive name as an absolute path\n            // indicator\n            isAbsolute = true;\n            rootEnd = 3;\n          }\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid unnecessary\n    // work\n    return \"\\\\\";\n  }\n\n  let tail: string;\n  if (rootEnd < len) {\n    tail = normalizeString(\n      path.slice(rootEnd),\n      !isAbsolute,\n      \"\\\\\",\n      isPathSeparator,\n    );\n  } else {\n    tail = \"\";\n  }\n  if (tail.length === 0 && !isAbsolute) tail = \".\";\n  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n    tail += \"\\\\\";\n  }\n  if (device === undefined) {\n    if (isAbsolute) {\n      if (tail.length > 0) return `\\\\${tail}`;\n      else return \"\\\\\";\n    } else if (tail.length > 0) {\n      return tail;\n    } else {\n      return \"\";\n    }\n  } else if (isAbsolute) {\n    if (tail.length > 0) return `${device}\\\\${tail}`;\n    else return `${device}\\\\`;\n  } else if (tail.length > 0) {\n    return device + tail;\n  } else {\n    return device;\n  }\n}\n\n/**\n * Verifies whether path is absolute\n * @param path to verify\n */\nexport function isAbsolute(path: string): boolean {\n  assertPath(path);\n  const len = path.length;\n  if (len === 0) return false;\n\n  const code = path.charCodeAt(0);\n  if (isPathSeparator(code)) {\n    return true;\n  } else if (isWindowsDeviceRoot(code)) {\n    // Possible device root\n\n    if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n      if (isPathSeparator(path.charCodeAt(2))) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n * @param paths to be joined and normalized\n */\nexport function join(...paths: string[]): string {\n  const pathsCount = paths.length;\n  if (pathsCount === 0) return \".\";\n\n  let joined: string | undefined;\n  let firstPart: string | null = null;\n  for (let i = 0; i < pathsCount; ++i) {\n    const path = paths[i];\n    assertPath(path);\n    if (path.length > 0) {\n      if (joined === undefined) joined = firstPart = path;\n      else joined += `\\\\${path}`;\n    }\n  }\n\n  if (joined === undefined) return \".\";\n\n  // Make sure that the joined path doesn't start with two slashes, because\n  // normalize() will mistake it for an UNC path then.\n  //\n  // This step is skipped when it is very clear that the user actually\n  // intended to point at an UNC path. This is assumed when the first\n  // non-empty string arguments starts with exactly two slashes followed by\n  // at least one more non-slash character.\n  //\n  // Note that for normalize() to treat a path as an UNC path it needs to\n  // have at least 2 components, so we don't filter for that here.\n  // This means that the user can use join to construct UNC paths from\n  // a server name and a share name; for example:\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n  let needsReplace = true;\n  let slashCount = 0;\n  assert(firstPart != null);\n  if (isPathSeparator(firstPart.charCodeAt(0))) {\n    ++slashCount;\n    const firstLen = firstPart.length;\n    if (firstLen > 1) {\n      if (isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n  }\n  if (needsReplace) {\n    // Find any more consecutive slashes we need to replace\n    for (; slashCount < joined.length; ++slashCount) {\n      if (!isPathSeparator(joined.charCodeAt(slashCount))) break;\n    }\n\n    // Replace the slashes if needed\n    if (slashCount >= 2) joined = `\\\\${joined.slice(slashCount)}`;\n  }\n\n  return normalize(joined);\n}\n\n/**\n * It will solve the relative path from `from` to `to`, for instance:\n *  from = 'C:\\\\orandea\\\\test\\\\aaa'\n *  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n * @param from relative path\n * @param to relative path\n */\nexport function relative(from: string, to: string): string {\n  assertPath(from);\n  assertPath(to);\n\n  if (from === to) return \"\";\n\n  const fromOrig = resolve(from);\n  const toOrig = resolve(to);\n\n  if (fromOrig === toOrig) return \"\";\n\n  from = fromOrig.toLowerCase();\n  to = toOrig.toLowerCase();\n\n  if (from === to) return \"\";\n\n  // Trim any leading backslashes\n  let fromStart = 0;\n  let fromEnd = from.length;\n  for (; fromStart < fromEnd; ++fromStart) {\n    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for (; fromEnd - 1 > fromStart; --fromEnd) {\n    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  let toStart = 0;\n  let toEnd = to.length;\n  for (; toStart < toEnd; ++toStart) {\n    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for (; toEnd - 1 > toStart; --toEnd) {\n    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return toOrig.slice(toStart + i + 1);\n        } else if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i;\n  }\n\n  // We found a mismatch before the first common path separator was seen, so\n  // return the original `to`.\n  if (i !== length && lastCommonSep === -1) {\n    return toOrig;\n  }\n\n  let out = \"\";\n  if (lastCommonSep === -1) lastCommonSep = 0;\n  // Generate the relative path based on the path difference between `to` and\n  // `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n      if (out.length === 0) out += \"..\";\n      else out += \"\\\\..\";\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) {\n    return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n  } else {\n    toStart += lastCommonSep;\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;\n    return toOrig.slice(toStart, toEnd);\n  }\n}\n\n/**\n * Resolves path to a namespace path\n * @param path to resolve to namespace\n */\nexport function toNamespacedPath(path: string): string {\n  // Note: this will *probably* throw somewhere.\n  if (typeof path !== \"string\") return path;\n  if (path.length === 0) return \"\";\n\n  const resolvedPath = resolve(path);\n\n  if (resolvedPath.length >= 3) {\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n      // Possible device root\n\n      if (\n        resolvedPath.charCodeAt(1) === CHAR_COLON &&\n        resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH\n      ) {\n        // Matched device root, convert the path to a long UNC path\n        return `\\\\\\\\?\\\\${resolvedPath}`;\n      }\n    }\n  }\n\n  return path;\n}\n\n/**\n * Return the directory path of a `path`.\n * @param path to determine the directory path for\n */\nexport function dirname(path: string): string {\n  assertPath(path);\n  const len = path.length;\n  if (len === 0) return \".\";\n  let rootEnd = -1;\n  let end = -1;\n  let matchedSlash = true;\n  let offset = 0;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = offset = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    return path;\n  }\n\n  for (let i = len - 1; i >= offset; --i) {\n    if (isPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) {\n    if (rootEnd === -1) return \".\";\n    else end = rootEnd;\n  }\n  return path.slice(0, end);\n}\n\n/**\n * Return the last portion of a `path`. Trailing directory separators are ignored.\n * @param path to process\n * @param ext of path directory\n */\nexport function basename(path: string, ext = \"\"): string {\n  if (ext !== undefined && typeof ext !== \"string\") {\n    throw new TypeError('\"ext\" argument must be a string');\n  }\n\n  assertPath(path);\n\n  let start = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i: number;\n\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n  if (path.length >= 2) {\n    const drive = path.charCodeAt(0);\n    if (isWindowsDeviceRoot(drive)) {\n      if (path.charCodeAt(1) === CHAR_COLON) start = 2;\n    }\n  }\n\n  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n    if (ext.length === path.length && ext === path) return \"\";\n    let extIdx = ext.length - 1;\n    let firstNonSlashEnd = -1;\n    for (i = path.length - 1; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          // We saw the first non-path separator, remember this index in case\n          // we need it if the extension ends up not matching\n          matchedSlash = false;\n          firstNonSlashEnd = i + 1;\n        }\n        if (extIdx >= 0) {\n          // Try to match the explicit extension\n          if (code === ext.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              // We matched the extension, so mark this as the end of our path\n              // component\n              end = i;\n            }\n          } else {\n            // Extension does not match, so our result is the entire path\n            // component\n            extIdx = -1;\n            end = firstNonSlashEnd;\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd;\n    else if (end === -1) end = path.length;\n    return path.slice(start, end);\n  } else {\n    for (i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) return \"\";\n    return path.slice(start, end);\n  }\n}\n\n/**\n * Return the extension of the `path` with leading period.\n * @param path with extension\n * @returns extension (ex. for `file.ts` returns `.ts`)\n */\nexport function extname(path: string): string {\n  assertPath(path);\n  let start = 0;\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n\n  if (\n    path.length >= 2 &&\n    path.charCodeAt(1) === CHAR_COLON &&\n    isWindowsDeviceRoot(path.charCodeAt(0))\n  ) {\n    start = startPart = 2;\n  }\n\n  for (let i = path.length - 1; i >= start; --i) {\n    const code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n\n/**\n * Generate a path from `FormatInputPathObject` object.\n * @param pathObject with path\n */\nexport function format(pathObject: FormatInputPathObject): string {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(\n      `The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`,\n    );\n  }\n  return _format(\"\\\\\", pathObject);\n}\n\n/**\n * Return a `ParsedPath` object of the `path`.\n * @param path to process\n */\nexport function parse(path: string): ParsedPath {\n  assertPath(path);\n\n  const ret: ParsedPath = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n\n  const len = path.length;\n  if (len === 0) return ret;\n\n  let rootEnd = 0;\n  let code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            if (len === 3) {\n              // `path` contains just a drive root, exit early to avoid\n              // unnecessary work\n              ret.root = ret.dir = path;\n              return ret;\n            }\n            rootEnd = 3;\n          }\n        } else {\n          // `path` contains just a drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    ret.root = ret.dir = path;\n    return ret;\n  }\n\n  if (rootEnd > 0) ret.root = path.slice(0, rootEnd);\n\n  let startDot = -1;\n  let startPart = rootEnd;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= rootEnd; --i) {\n    code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    if (end !== -1) {\n      ret.base = ret.name = path.slice(startPart, end);\n    }\n  } else {\n    ret.name = path.slice(startPart, startDot);\n    ret.base = path.slice(startPart, end);\n    ret.ext = path.slice(startDot, end);\n  }\n\n  // If the directory is the root, use the entire root as the `dir` including\n  // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n  // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n  if (startPart > 0 && startPart !== rootEnd) {\n    ret.dir = path.slice(0, startPart - 1);\n  } else ret.dir = ret.root;\n\n  return ret;\n}\n\n/**\n * Converts a file URL to a path string.\n *\n * ```ts\n *      import { fromFileUrl } from \"https://deno.land/std@$STD_VERSION/path/win32.ts\";\n *      fromFileUrl(\"file:///home/foo\"); // \"\\\\home\\\\foo\"\n *      fromFileUrl(\"file:///C:/Users/foo\"); // \"C:\\\\Users\\\\foo\"\n *      fromFileUrl(\"file://localhost/home/foo\"); // \"\\\\\\\\localhost\\\\home\\\\foo\"\n * ```\n * @param url of a file URL\n */\nexport function fromFileUrl(url: string | URL): string {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol != \"file:\") {\n    throw new TypeError(\"Must be a file URL.\");\n  }\n  let path = decodeURIComponent(\n    url.pathname.replace(/\\//g, \"\\\\\").replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"),\n  ).replace(/^\\\\*([A-Za-z]:)(\\\\|$)/, \"$1\\\\\");\n  if (url.hostname != \"\") {\n    // Note: The `URL` implementation guarantees that the drive letter and\n    // hostname are mutually exclusive. Otherwise it would not have been valid\n    // to append the hostname and path like this.\n    path = `\\\\\\\\${url.hostname}${path}`;\n  }\n  return path;\n}\n\n/**\n * Converts a path string to a file URL.\n *\n * ```ts\n *      import { toFileUrl } from \"https://deno.land/std@$STD_VERSION/path/win32.ts\";\n *      toFileUrl(\"\\\\home\\\\foo\"); // new URL(\"file:///home/foo\")\n *      toFileUrl(\"C:\\\\Users\\\\foo\"); // new URL(\"file:///C:/Users/foo\")\n *      toFileUrl(\"\\\\\\\\127.0.0.1\\\\home\\\\foo\"); // new URL(\"file://127.0.0.1/home/foo\")\n * ```\n * @param path to convert to file URL\n */\nexport function toFileUrl(path: string): URL {\n  if (!isAbsolute(path)) {\n    throw new TypeError(\"Must be an absolute path.\");\n  }\n  const [, hostname, pathname] = path.match(\n    /^(?:[/\\\\]{2}([^/\\\\]+)(?=[/\\\\](?:[^/\\\\]|$)))?(.*)/,\n  )!;\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(pathname.replace(/%/g, \"%25\"));\n  if (hostname != null && hostname != \"localhost\") {\n    url.hostname = hostname;\n    if (!url.hostname) {\n      throw new TypeError(\"Invalid hostname.\");\n    }\n  }\n  return url;\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject } from \"./_interface.ts\";\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_UPPERCASE_A,\n  CHAR_UPPERCASE_Z,\n} from \"./_constants.ts\";\n\nexport function assertPath(path: string) {\n  if (typeof path !== \"string\") {\n    throw new TypeError(\n      `Path must be a string. Received ${JSON.stringify(path)}`,\n    );\n  }\n}\n\nexport function isPosixPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nexport function isPathSeparator(code: number): boolean {\n  return isPosixPathSeparator(code) || code === CHAR_BACKWARD_SLASH;\n}\n\nexport function isWindowsDeviceRoot(code: number): boolean {\n  return (\n    (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z)\n  );\n}\n\n// Resolves . and .. elements in a path with directory names\nexport function normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code: number) => boolean,\n): string {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code: number | undefined;\n  for (let i = 0, len = path.length; i <= len; ++i) {\n    if (i < len) code = path.charCodeAt(i);\n    else if (isPathSeparator(code!)) break;\n    else code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code!)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += `${separator}..`;\n          else res = \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nexport function _format(\n  sep: string,\n  pathObject: FormatInputPathObject,\n): string {\n  const dir: string | undefined = pathObject.dir || pathObject.root;\n  const base: string = pathObject.base ||\n    (pathObject.name || \"\") + (pathObject.ext || \"\");\n  if (!dir) return base;\n  if (dir === pathObject.root) return dir + base;\n  return dir + sep + base;\n}\n\nconst WHITESPACE_ENCODINGS: Record<string, string> = {\n  \"\\u0009\": \"%09\",\n  \"\\u000A\": \"%0A\",\n  \"\\u000B\": \"%0B\",\n  \"\\u000C\": \"%0C\",\n  \"\\u000D\": \"%0D\",\n  \"\\u0020\": \"%20\",\n};\n\nexport function encodeWhitespace(string: string): string {\n  return string.replaceAll(/[\\s]/g, (c) => {\n    return WHITESPACE_ENCODINGS[c] ?? c;\n  });\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * All internal non-test code, that is files that do not have `test` or `bench` in the name, must use the assertion functions within `_utils/asserts.ts` and not `testing/asserts.ts`. This is to create a separation of concerns between internal and testing assertions.\n */\n\nexport class DenoStdInternalError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"DenoStdInternalError\";\n  }\n}\n\n/** Make an assertion, if not `true`, then throw. */\nexport function assert(expr: unknown, msg = \"\"): asserts expr {\n  if (!expr) {\n    throw new DenoStdInternalError(msg);\n  }\n}\n\n/** Use this to assert unreachable code. */\nexport function unreachable(): never {\n  throw new DenoStdInternalError(\"unreachable\");\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject, ParsedPath } from \"./_interface.ts\";\nimport { CHAR_DOT, CHAR_FORWARD_SLASH } from \"./_constants.ts\";\n\nimport {\n  _format,\n  assertPath,\n  encodeWhitespace,\n  isPosixPathSeparator,\n  normalizeString,\n} from \"./_util.ts\";\n\nexport const sep = \"/\";\nexport const delimiter = \":\";\n\n// path.resolve([from ...], to)\n/**\n * Resolves `pathSegments` into an absolute path.\n * @param pathSegments an array of path segments\n */\nexport function resolve(...pathSegments: string[]): string {\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n\n  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    let path: string;\n\n    if (i >= 0) path = pathSegments[i];\n    else {\n      // deno-lint-ignore no-explicit-any\n      const { Deno } = globalThis as any;\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a relative path without a CWD.\");\n      }\n      path = Deno.cwd();\n    }\n\n    assertPath(path);\n\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeString(\n    resolvedPath,\n    !resolvedAbsolute,\n    \"/\",\n    isPosixPathSeparator,\n  );\n\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0) return `/${resolvedPath}`;\n    else return \"/\";\n  } else if (resolvedPath.length > 0) return resolvedPath;\n  else return \".\";\n}\n\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n * @param path to be normalized\n */\nexport function normalize(path: string): string {\n  assertPath(path);\n\n  if (path.length === 0) return \".\";\n\n  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  const trailingSeparator =\n    path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n  // Normalize the path\n  path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n\n  if (path.length === 0 && !isAbsolute) path = \".\";\n  if (path.length > 0 && trailingSeparator) path += \"/\";\n\n  if (isAbsolute) return `/${path}`;\n  return path;\n}\n\n/**\n * Verifies whether provided path is absolute\n * @param path to be verified as absolute\n */\nexport function isAbsolute(path: string): boolean {\n  assertPath(path);\n  return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n}\n\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n * @param paths to be joined and normalized\n */\nexport function join(...paths: string[]): string {\n  if (paths.length === 0) return \".\";\n  let joined: string | undefined;\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n    assertPath(path);\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `/${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalize(joined);\n}\n\n/**\n * Return the relative path from `from` to `to` based on current working directory.\n * @param from path in current working directory\n * @param to path in current working directory\n */\nexport function relative(from: string, to: string): string {\n  assertPath(from);\n  assertPath(to);\n\n  if (from === to) return \"\";\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return \"\";\n\n  // Trim any leading backslashes\n  let fromStart = 1;\n  const fromEnd = from.length;\n  for (; fromStart < fromEnd; ++fromStart) {\n    if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) break;\n  }\n  const fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  let toStart = 1;\n  const toEnd = to.length;\n  for (; toStart < toEnd; ++toStart) {\n    if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) break;\n  }\n  const toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        } else if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (fromCode === CHAR_FORWARD_SLASH) lastCommonSep = i;\n  }\n\n  let out = \"\";\n  // Generate the relative path based on the path difference between `to`\n  // and `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (out.length === 0) out += \"..\";\n      else out += \"/..\";\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\n  else {\n    toStart += lastCommonSep;\n    if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) ++toStart;\n    return to.slice(toStart);\n  }\n}\n\n/**\n * Resolves path to a namespace path\n * @param path to resolve to namespace\n */\nexport function toNamespacedPath(path: string): string {\n  // Non-op on posix systems\n  return path;\n}\n\n/**\n * Return the directory path of a `path`.\n * @param path to determine the directory path for\n */\nexport function dirname(path: string): string {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n  const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  let end = -1;\n  let matchedSlash = true;\n  for (let i = path.length - 1; i >= 1; --i) {\n    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? \"/\" : \".\";\n  if (hasRoot && end === 1) return \"//\";\n  return path.slice(0, end);\n}\n\n/**\n * Return the last portion of a `path`. Trailing directory separators are ignored.\n * @param path to process\n * @param ext of path directory\n */\nexport function basename(path: string, ext = \"\"): string {\n  if (ext !== undefined && typeof ext !== \"string\") {\n    throw new TypeError('\"ext\" argument must be a string');\n  }\n  assertPath(path);\n\n  let start = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i: number;\n\n  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n    if (ext.length === path.length && ext === path) return \"\";\n    let extIdx = ext.length - 1;\n    let firstNonSlashEnd = -1;\n    for (i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          // We saw the first non-path separator, remember this index in case\n          // we need it if the extension ends up not matching\n          matchedSlash = false;\n          firstNonSlashEnd = i + 1;\n        }\n        if (extIdx >= 0) {\n          // Try to match the explicit extension\n          if (code === ext.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              // We matched the extension, so mark this as the end of our path\n              // component\n              end = i;\n            }\n          } else {\n            // Extension does not match, so our result is the entire path\n            // component\n            extIdx = -1;\n            end = firstNonSlashEnd;\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd;\n    else if (end === -1) end = path.length;\n    return path.slice(start, end);\n  } else {\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) return \"\";\n    return path.slice(start, end);\n  }\n}\n\n/**\n * Return the extension of the `path` with leading period.\n * @param path with extension\n * @returns extension (ex. for `file.ts` returns `.ts`)\n */\nexport function extname(path: string): string {\n  assertPath(path);\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  for (let i = path.length - 1; i >= 0; --i) {\n    const code = path.charCodeAt(i);\n    if (code === CHAR_FORWARD_SLASH) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n\n/**\n * Generate a path from `FormatInputPathObject` object.\n * @param pathObject with path\n */\nexport function format(pathObject: FormatInputPathObject): string {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(\n      `The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`,\n    );\n  }\n  return _format(\"/\", pathObject);\n}\n\n/**\n * Return a `ParsedPath` object of the `path`.\n * @param path to process\n */\nexport function parse(path: string): ParsedPath {\n  assertPath(path);\n\n  const ret: ParsedPath = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n  if (path.length === 0) return ret;\n  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  let start: number;\n  if (isAbsolute) {\n    ret.root = \"/\";\n    start = 1;\n  } else {\n    start = 0;\n  }\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= start; --i) {\n    const code = path.charCodeAt(i);\n    if (code === CHAR_FORWARD_SLASH) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    if (end !== -1) {\n      if (startPart === 0 && isAbsolute) {\n        ret.base = ret.name = path.slice(1, end);\n      } else {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    }\n  } else {\n    if (startPart === 0 && isAbsolute) {\n      ret.name = path.slice(1, startDot);\n      ret.base = path.slice(1, end);\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n    }\n    ret.ext = path.slice(startDot, end);\n  }\n\n  if (startPart > 0) ret.dir = path.slice(0, startPart - 1);\n  else if (isAbsolute) ret.dir = \"/\";\n\n  return ret;\n}\n\n/**\n * Converts a file URL to a path string.\n *\n * ```ts\n *      import { fromFileUrl } from \"https://deno.land/std@$STD_VERSION/path/posix.ts\";\n *      fromFileUrl(\"file:///home/foo\"); // \"/home/foo\"\n * ```\n * @param url of a file URL\n */\nexport function fromFileUrl(url: string | URL): string {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol != \"file:\") {\n    throw new TypeError(\"Must be a file URL.\");\n  }\n  return decodeURIComponent(\n    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"),\n  );\n}\n\n/**\n * Converts a path string to a file URL.\n *\n * ```ts\n *      import { toFileUrl } from \"https://deno.land/std@$STD_VERSION/path/posix.ts\";\n *      toFileUrl(\"/home/foo\"); // new URL(\"file:///home/foo\")\n * ```\n * @param path to convert to file URL\n */\nexport function toFileUrl(path: string): URL {\n  if (!isAbsolute(path)) {\n    throw new TypeError(\"Must be an absolute path.\");\n  }\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(\n    path.replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"),\n  );\n  return url;\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows, osType } from \"../_util/os.ts\";\nimport { SEP, SEP_PATTERN } from \"./separator.ts\";\nimport * as _win32 from \"./win32.ts\";\nimport * as _posix from \"./posix.ts\";\nimport type { OSType } from \"../_util/os.ts\";\n\nconst path = isWindows ? _win32 : _posix;\nconst { join, normalize } = path;\n\nexport interface GlobOptions {\n  /** Extended glob syntax.\n   * See https://www.linuxjournal.com/content/bash-extended-globbing.\n   *\n   * @default {true}\n   */\n  extended?: boolean;\n  /** Globstar syntax.\n   * See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n   * If false, `**` is treated like `*`.\n   *\n   * @default {true}\n   */\n  globstar?: boolean;\n  /** Whether globstar should be case-insensitive. */\n  caseInsensitive?: boolean;\n  /** Operating system. Defaults to the native OS. */\n  os?: OSType;\n}\n\nexport type GlobToRegExpOptions = GlobOptions;\n\nconst regExpEscapeChars = [\n  \"!\",\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"=\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"^\",\n  \"{\",\n  \"|\",\n];\nconst rangeEscapeChars = [\"-\", \"\\\\\", \"]\"];\n\n/** Convert a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment. */\nexport function globToRegExp(\n  glob: string,\n  {\n    extended = true,\n    globstar: globstarOption = true,\n    os = osType,\n    caseInsensitive = false,\n  }: GlobToRegExpOptions = {},\n): RegExp {\n  if (glob == \"\") {\n    return /(?!)/;\n  }\n\n  const sep = os == \"windows\" ? \"(?:\\\\\\\\|/)+\" : \"/+\";\n  const sepMaybe = os == \"windows\" ? \"(?:\\\\\\\\|/)*\" : \"/*\";\n  const seps = os == \"windows\" ? [\"\\\\\", \"/\"] : [\"/\"];\n  const globstar = os == \"windows\"\n    ? \"(?:[^\\\\\\\\/]*(?:\\\\\\\\|/|$)+)*\"\n    : \"(?:[^/]*(?:/|$)+)*\";\n  const wildcard = os == \"windows\" ? \"[^\\\\\\\\/]*\" : \"[^/]*\";\n  const escapePrefix = os == \"windows\" ? \"`\" : \"\\\\\";\n\n  // Remove trailing separators.\n  let newLength = glob.length;\n  for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);\n  glob = glob.slice(0, newLength);\n\n  let regExpString = \"\";\n\n  // Terminates correctly. Trust that `j` is incremented every iteration.\n  for (let j = 0; j < glob.length;) {\n    let segment = \"\";\n    const groupStack: string[] = [];\n    let inRange = false;\n    let inEscape = false;\n    let endsWithSep = false;\n    let i = j;\n\n    // Terminates with `i` at the non-inclusive end of the current segment.\n    for (; i < glob.length && !seps.includes(glob[i]); i++) {\n      if (inEscape) {\n        inEscape = false;\n        const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;\n        segment += escapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n        continue;\n      }\n\n      if (glob[i] == escapePrefix) {\n        inEscape = true;\n        continue;\n      }\n\n      if (glob[i] == \"[\") {\n        if (!inRange) {\n          inRange = true;\n          segment += \"[\";\n          if (glob[i + 1] == \"!\") {\n            i++;\n            segment += \"^\";\n          } else if (glob[i + 1] == \"^\") {\n            i++;\n            segment += \"\\\\^\";\n          }\n          continue;\n        } else if (glob[i + 1] == \":\") {\n          let k = i + 1;\n          let value = \"\";\n          while (glob[k + 1] != null && glob[k + 1] != \":\") {\n            value += glob[k + 1];\n            k++;\n          }\n          if (glob[k + 1] == \":\" && glob[k + 2] == \"]\") {\n            i = k + 2;\n            if (value == \"alnum\") segment += \"\\\\dA-Za-z\";\n            else if (value == \"alpha\") segment += \"A-Za-z\";\n            else if (value == \"ascii\") segment += \"\\x00-\\x7F\";\n            else if (value == \"blank\") segment += \"\\t \";\n            else if (value == \"cntrl\") segment += \"\\x00-\\x1F\\x7F\";\n            else if (value == \"digit\") segment += \"\\\\d\";\n            else if (value == \"graph\") segment += \"\\x21-\\x7E\";\n            else if (value == \"lower\") segment += \"a-z\";\n            else if (value == \"print\") segment += \"\\x20-\\x7E\";\n            else if (value == \"punct\") {\n              segment += \"!\\\"#$%&'()*+,\\\\-./:;<=>?@[\\\\\\\\\\\\]^_\u2018{|}~\";\n            } else if (value == \"space\") segment += \"\\\\s\\v\";\n            else if (value == \"upper\") segment += \"A-Z\";\n            else if (value == \"word\") segment += \"\\\\w\";\n            else if (value == \"xdigit\") segment += \"\\\\dA-Fa-f\";\n            continue;\n          }\n        }\n      }\n\n      if (glob[i] == \"]\" && inRange) {\n        inRange = false;\n        segment += \"]\";\n        continue;\n      }\n\n      if (inRange) {\n        if (glob[i] == \"\\\\\") {\n          segment += `\\\\\\\\`;\n        } else {\n          segment += glob[i];\n        }\n        continue;\n      }\n\n      if (\n        glob[i] == \")\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] != \"BRACE\"\n      ) {\n        segment += \")\";\n        const type = groupStack.pop()!;\n        if (type == \"!\") {\n          segment += wildcard;\n        } else if (type != \"@\") {\n          segment += type;\n        }\n        continue;\n      }\n\n      if (\n        glob[i] == \"|\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] != \"BRACE\"\n      ) {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] == \"+\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"+\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"@\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"@\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"?\") {\n        if (extended && glob[i + 1] == \"(\") {\n          i++;\n          groupStack.push(\"?\");\n          segment += \"(?:\";\n        } else {\n          segment += \".\";\n        }\n        continue;\n      }\n\n      if (glob[i] == \"!\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"!\");\n        segment += \"(?!\";\n        continue;\n      }\n\n      if (glob[i] == \"{\") {\n        groupStack.push(\"BRACE\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"}\" && groupStack[groupStack.length - 1] == \"BRACE\") {\n        groupStack.pop();\n        segment += \")\";\n        continue;\n      }\n\n      if (glob[i] == \",\" && groupStack[groupStack.length - 1] == \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] == \"*\") {\n        if (extended && glob[i + 1] == \"(\") {\n          i++;\n          groupStack.push(\"*\");\n          segment += \"(?:\";\n        } else {\n          const prevChar = glob[i - 1];\n          let numStars = 1;\n          while (glob[i + 1] == \"*\") {\n            i++;\n            numStars++;\n          }\n          const nextChar = glob[i + 1];\n          if (\n            globstarOption && numStars == 2 &&\n            [...seps, undefined].includes(prevChar) &&\n            [...seps, undefined].includes(nextChar)\n          ) {\n            segment += globstar;\n            endsWithSep = true;\n          } else {\n            segment += wildcard;\n          }\n        }\n        continue;\n      }\n\n      segment += regExpEscapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n    }\n\n    // Check for unclosed groups or a dangling backslash.\n    if (groupStack.length > 0 || inRange || inEscape) {\n      // Parse failure. Take all characters from this segment literally.\n      segment = \"\";\n      for (const c of glob.slice(j, i)) {\n        segment += regExpEscapeChars.includes(c) ? `\\\\${c}` : c;\n        endsWithSep = false;\n      }\n    }\n\n    regExpString += segment;\n    if (!endsWithSep) {\n      regExpString += i < glob.length ? sep : sepMaybe;\n      endsWithSep = true;\n    }\n\n    // Terminates with `i` at the start of the next segment.\n    while (seps.includes(glob[i])) i++;\n\n    // Check that the next value of `j` is indeed higher than the current value.\n    if (!(i > j)) {\n      throw new Error(\"Assertion failure: i > j (potential infinite loop)\");\n    }\n    j = i;\n  }\n\n  regExpString = `^${regExpString}$`;\n  return new RegExp(regExpString, caseInsensitive ? \"i\" : \"\");\n}\n\n/** Test whether the given string is a glob */\nexport function isGlob(str: string): boolean {\n  const chars: Record<string, string> = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\" };\n  const regex =\n    /\\\\(.)|(^!|\\*|\\?|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\n\n  if (str === \"\") {\n    return false;\n  }\n\n  let match: RegExpExecArray | null;\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    let idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    const open = match[1];\n    const close = open ? chars[open] : null;\n    if (open && close) {\n      const n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n\n  return false;\n}\n\n/** Like normalize(), but doesn't collapse \"**\\/..\" when `globstar` is true. */\nexport function normalizeGlob(\n  glob: string,\n  { globstar = false }: GlobOptions = {},\n): string {\n  if (glob.match(/\\0/g)) {\n    throw new Error(`Glob contains invalid characters: \"${glob}\"`);\n  }\n  if (!globstar) {\n    return normalize(glob);\n  }\n  const s = SEP_PATTERN.source;\n  const badParentPattern = new RegExp(\n    `(?<=(${s}|^)\\\\*\\\\*${s})\\\\.\\\\.(?=${s}|$)`,\n    \"g\",\n  );\n  return normalize(glob.replace(badParentPattern, \"\\0\")).replace(/\\0/g, \"..\");\n}\n\n/** Like join(), but doesn't collapse \"**\\/..\" when `globstar` is true. */\nexport function joinGlobs(\n  globs: string[],\n  { extended = true, globstar = false }: GlobOptions = {},\n): string {\n  if (!globstar || globs.length == 0) {\n    return join(...globs);\n  }\n  if (globs.length === 0) return \".\";\n  let joined: string | undefined;\n  for (const glob of globs) {\n    const path = glob;\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `${SEP}${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalizeGlob(joined, { extended, globstar });\n}\n", "// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported mostly from https://github.com/browserify/path-browserify/\n\n/**\n * Utilities for working with OS-specific file paths.\n *\n * Codes in the examples uses POSIX path but it automatically use Windows path\n * on Windows. Use methods under `posix` or `win32` object instead to handle non\n * platform specific path like:\n * ```ts\n * import { posix, win32 } from \"https://deno.land/std@$STD_VERSION/path/mod.ts\";\n * const p1 = posix.fromFileUrl(\"file:///home/foo\");\n * const p2 = win32.fromFileUrl(\"file:///home/foo\");\n * console.log(p1); // \"/home/foo\"\n * console.log(p2); // \"\\\\home\\\\foo\"\n * ```\n *\n * This module is browser compatible.\n *\n * @module\n */\n\nimport { isWindows } from \"../_util/os.ts\";\nimport * as _win32 from \"./win32.ts\";\nimport * as _posix from \"./posix.ts\";\n\nconst path = isWindows ? _win32 : _posix;\n\nexport const win32 = _win32;\nexport const posix = _posix;\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  fromFileUrl,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  relative,\n  resolve,\n  sep,\n  toFileUrl,\n  toNamespacedPath,\n} = path;\n\nexport * from \"./common.ts\";\nexport { SEP, SEP_PATTERN } from \"./separator.ts\";\nexport * from \"./_interface.ts\";\nexport * from \"./glob.ts\";\n", "import type { Cursor } from \"../ansi/cursor_position.ts\";\nimport { tty } from \"../ansi/tty.ts\";\nimport { KeyCode, parse } from \"../keycode/key_code.ts\";\nimport {\n  bold,\n  brightBlue,\n  dim,\n  green,\n  italic,\n  red,\n  stripColor,\n} from \"./deps.ts\";\nimport { Figures } from \"./figures.ts\";\n\n/** Prompt validation return tape. */\nexport type ValidateResult = string | boolean | Promise<string | boolean>;\n\n/** Input keys options. */\nexport interface GenericPromptKeys {\n  submit?: Array<string>;\n}\n\n/** Generic prompt options. */\nexport interface GenericPromptOptions<TValue, TRawValue> {\n  message: string;\n  default?: TValue;\n  hideDefault?: boolean;\n  validate?: (value: TRawValue) => ValidateResult;\n  transform?: (value: TRawValue) => TValue | undefined;\n  hint?: string;\n  pointer?: string;\n  indent?: string;\n  keys?: GenericPromptKeys;\n  cbreak?: boolean;\n  prefix?: string;\n}\n\n/** Generic prompt settings. */\nexport interface GenericPromptSettings<TValue, TRawValue>\n  extends GenericPromptOptions<TValue, TRawValue> {\n  pointer: string;\n  indent: string;\n  prefix: string;\n}\n\n/** Static generic prompt interface. */\nexport interface StaticGenericPrompt<\n  TValue,\n  TRawValue,\n  TOptions extends GenericPromptOptions<TValue, TRawValue>,\n  TSettings extends GenericPromptSettings<TValue, TRawValue>,\n  TPrompt extends GenericPrompt<TValue, TRawValue, TSettings>,\n> {\n  inject?(value: TValue): void;\n\n  prompt(options: TOptions): Promise<TValue>;\n}\n\n/** Generic prompt representation. */\nexport abstract class GenericPrompt<\n  TValue,\n  TRawValue,\n  TSettings extends GenericPromptSettings<TValue, TRawValue>,\n> {\n  protected static injectedValue: unknown | undefined;\n  protected readonly settings: TSettings;\n  protected readonly tty = tty;\n  protected readonly indent: string;\n  protected readonly cursor: Cursor = {\n    x: 0,\n    y: 0,\n  };\n  #value: TValue | undefined;\n  #lastError: string | undefined;\n  #isFirstRun = true;\n  #encoder = new TextEncoder();\n\n  /**\n   * Inject prompt value. Can be used for unit tests or pre selections.\n   * @param value Input value.\n   */\n  public static inject(value: unknown): void {\n    GenericPrompt.injectedValue = value;\n  }\n\n  protected constructor(settings: TSettings) {\n    this.settings = {\n      ...settings,\n      keys: {\n        submit: [\"enter\", \"return\"],\n        ...(settings.keys ?? {}),\n      },\n    };\n    this.indent = this.settings.indent ?? \" \";\n  }\n\n  /** Execute the prompt and show cursor on end. */\n  public async prompt(): Promise<TValue> {\n    try {\n      return await this.#execute();\n    } finally {\n      this.tty.cursorShow();\n    }\n  }\n\n  /** Clear prompt output. */\n  protected clear(): void {\n    this.tty.cursorLeft.eraseDown();\n  }\n\n  /** Execute the prompt. */\n  #execute = async (): Promise<TValue> => {\n    // Throw errors on unit tests.\n    if (typeof GenericPrompt.injectedValue !== \"undefined\" && this.#lastError) {\n      throw new Error(this.error());\n    }\n\n    await this.render();\n    this.#lastError = undefined;\n\n    if (!await this.read()) {\n      return this.#execute();\n    }\n\n    if (typeof this.#value === \"undefined\") {\n      throw new Error(\"internal error: failed to read value\");\n    }\n\n    this.clear();\n    const successMessage: string | undefined = this.success(\n      this.#value,\n    );\n    if (successMessage) {\n      console.log(successMessage);\n    }\n\n    GenericPrompt.injectedValue = undefined;\n    this.tty.cursorShow();\n\n    return this.#value;\n  };\n\n  /** Render prompt. */\n  protected async render(): Promise<void> {\n    const result: [string, string | undefined, string | undefined] =\n      await Promise.all([\n        this.message(),\n        this.body?.(),\n        this.footer(),\n      ]);\n\n    const content: string = result.filter(Boolean).join(\"\\n\");\n    const lines = content.split(\"\\n\");\n\n    const columns = getColumns();\n    const linesCount: number = columns\n      ? lines.reduce((prev, next) => {\n        const length = stripColor(next).length;\n        return prev + (length > columns ? Math.ceil(length / columns) : 1);\n      }, 0)\n      : content.split(\"\\n\").length;\n\n    const y: number = linesCount - this.cursor.y - 1;\n\n    if (!this.#isFirstRun || this.#lastError) {\n      this.clear();\n    }\n    this.#isFirstRun = false;\n\n    if (Deno.build.os === \"windows\") {\n      console.log(content);\n      this.tty.cursorUp();\n    } else {\n      Deno.stdout.writeSync(this.#encoder.encode(content));\n    }\n\n    if (y) {\n      this.tty.cursorUp(y);\n    }\n    this.tty.cursorTo(this.cursor.x);\n  }\n\n  /** Read user input from stdin, handle events and validate user input. */\n  protected async read(): Promise<boolean> {\n    if (typeof GenericPrompt.injectedValue !== \"undefined\") {\n      const value: TRawValue = GenericPrompt.injectedValue as TRawValue;\n      await this.#validateValue(value);\n    } else {\n      const events: Array<KeyCode> = await this.#readKey();\n\n      if (!events.length) {\n        return false;\n      }\n\n      for (const event of events) {\n        await this.handleEvent(event);\n      }\n    }\n\n    return typeof this.#value !== \"undefined\";\n  }\n\n  protected submit(): Promise<void> {\n    return this.#validateValue(this.getValue());\n  }\n\n  protected message(): string {\n    return `${this.settings.indent}${this.settings.prefix}` +\n      bold(this.settings.message) + this.defaults();\n  }\n\n  protected defaults(): string {\n    let defaultMessage = \"\";\n    if (\n      typeof this.settings.default !== \"undefined\" && !this.settings.hideDefault\n    ) {\n      defaultMessage += dim(` (${this.format(this.settings.default)})`);\n    }\n    return defaultMessage;\n  }\n\n  /** Get prompt success message. */\n  protected success(value: TValue): string | undefined {\n    return `${this.settings.indent}${this.settings.prefix}` +\n      bold(this.settings.message) + this.defaults() +\n      \" \" + this.settings.pointer +\n      \" \" + green(this.format(value));\n  }\n\n  protected body?(): string | undefined | Promise<string | undefined>;\n\n  protected footer(): string | undefined {\n    return this.error() ?? this.hint();\n  }\n\n  protected error(): string | undefined {\n    return this.#lastError\n      ? this.settings.indent + red(bold(`${Figures.CROSS} `) + this.#lastError)\n      : undefined;\n  }\n\n  protected hint(): string | undefined {\n    return this.settings.hint\n      ? this.settings.indent +\n        italic(brightBlue(dim(`${Figures.POINTER} `) + this.settings.hint))\n      : undefined;\n  }\n\n  protected setErrorMessage(message: string) {\n    this.#lastError = message;\n  }\n\n  /**\n   * Handle user input event.\n   * @param event Key event.\n   */\n  protected async handleEvent(event: KeyCode): Promise<void> {\n    switch (true) {\n      case event.name === \"c\" && event.ctrl:\n        this.clear();\n        this.tty.cursorShow();\n        Deno.exit(130);\n        return;\n      case this.isKey(this.settings.keys, \"submit\", event):\n        await this.submit();\n        break;\n    }\n  }\n\n  /**\n   * Map input value to output value.\n   * @param value Input value.\n   * @return Output value.\n   */\n  protected abstract transform(value: TRawValue): TValue | undefined;\n\n  /**\n   * Validate input value.\n   * @param value User input value.\n   * @return True on success, false or error message on error.\n   */\n  protected abstract validate(value: TRawValue): ValidateResult;\n\n  /**\n   * Format output value.\n   * @param value Output value.\n   */\n  protected abstract format(value: TValue): string;\n\n  /** Get input value. */\n  protected abstract getValue(): TRawValue;\n\n  /** Read user input from stdin and pars ansi codes. */\n  #readKey = async (): Promise<Array<KeyCode>> => {\n    const data: Uint8Array = await this.#readChar();\n\n    return data.length ? parse(data) : [];\n  };\n\n  /** Read user input from stdin. */\n  #readChar = async (): Promise<Uint8Array> => {\n    const buffer = new Uint8Array(8);\n    const isTty = Deno.isatty(Deno.stdin.rid);\n\n    if (isTty) {\n      // cbreak is only supported on deno >= 1.6.0, suppress ts-error.\n      (Deno.stdin.setRaw as setRaw)(\n        true,\n        { cbreak: this.settings.cbreak === true },\n      );\n    }\n    const nread: number | null = await Deno.stdin.read(buffer);\n\n    if (isTty) {\n      Deno.stdin.setRaw(false);\n    }\n\n    if (nread === null) {\n      return buffer;\n    }\n\n    return buffer.subarray(0, nread);\n  };\n\n  /**\n   * Map input value to output value. If a custom transform handler ist set, the\n   * custom handler will be executed, otherwise the default transform handler\n   * from the prompt will be executed.\n   * @param value The value to transform.\n   */\n  #transformValue = (value: TRawValue): TValue | undefined => {\n    return this.settings.transform\n      ? this.settings.transform(value)\n      : this.transform(value);\n  };\n\n  /**\n   * Validate input value. Set error message if validation fails and transform\n   * output value on success.\n   * If a default value is set, the default will be used as value without any\n   * validation.\n   * If a custom validation handler ist set, the custom handler will\n   * be executed, otherwise a prompt specific default validation handler will be\n   * executed.\n   * @param value The value to validate.\n   */\n  #validateValue = async (value: TRawValue): Promise<void> => {\n    if (!value && typeof this.settings.default !== \"undefined\") {\n      this.#value = this.settings.default;\n      return;\n    }\n\n    this.#value = undefined;\n    this.#lastError = undefined;\n\n    const validation =\n      await (this.settings.validate\n        ? this.settings.validate(value)\n        : this.validate(value));\n\n    if (validation === false) {\n      this.#lastError = `Invalid answer.`;\n    } else if (typeof validation === \"string\") {\n      this.#lastError = validation;\n    } else {\n      this.#value = this.#transformValue(value);\n    }\n  };\n\n  /**\n   * Check if key event has given name or sequence.\n   * @param keys  Key map.\n   * @param name  Key name.\n   * @param event Key event.\n   */\n  protected isKey<TKey extends unknown, TName extends keyof TKey>(\n    keys: TKey | undefined,\n    name: TName,\n    event: KeyCode,\n  ): boolean {\n    // deno-lint-ignore no-explicit-any\n    const keyNames: Array<unknown> | undefined = keys?.[name] as any;\n    return typeof keyNames !== \"undefined\" && (\n      (typeof event.name !== \"undefined\" &&\n        keyNames.indexOf(event.name) !== -1) ||\n      (typeof event.sequence !== \"undefined\" &&\n        keyNames.indexOf(event.sequence) !== -1)\n    );\n  }\n}\n\ntype setRaw = (\n  mode: boolean,\n  options?: { cbreak?: boolean },\n) => void;\n\nfunction getColumns(): number | null {\n  try {\n    // Catch error in none tty mode: Inappropriate ioctl for device (os error 25)\n    // And keep backwards compatibility for deno < 1.27.0.\n    // deno-lint-ignore no-explicit-any\n    return (Deno as any).consoleSize(Deno.stdout.rid).columns;\n  } catch (_error) {\n    return null;\n  }\n}\n", "import type { KeyCode } from \"../keycode/key_code.ts\";\nimport {\n  GenericInput,\n  GenericInputKeys,\n  GenericInputPromptOptions,\n  GenericInputPromptSettings,\n} from \"./_generic_input.ts\";\nimport {\n  bold,\n  brightBlue,\n  dim,\n  dirname,\n  join,\n  normalize,\n  stripColor,\n  underline,\n} from \"./deps.ts\";\nimport { Figures, getFiguresByKeys } from \"./figures.ts\";\nimport { distance } from \"../_utils/distance.ts\";\n\ninterface LocalStorage {\n  getItem(key: string): string | null;\n  removeItem(key: string): void;\n  setItem(key: string, value: string): void;\n}\n\n/** Input keys options. */\nexport interface GenericSuggestionsKeys extends GenericInputKeys {\n  complete?: string[];\n  next?: string[];\n  previous?: string[];\n  nextPage?: string[];\n  previousPage?: string[];\n}\n\nexport type SuggestionHandler = (\n  input: string,\n) => Array<string | number> | Promise<Array<string | number>>;\n\nexport type CompleteHandler = (\n  input: string,\n  suggestion?: string,\n) => Promise<string> | string;\n\n/** Generic input prompt options. */\nexport interface GenericSuggestionsOptions<TValue, TRawValue>\n  extends GenericInputPromptOptions<TValue, TRawValue> {\n  keys?: GenericSuggestionsKeys;\n  id?: string;\n  suggestions?: Array<string | number> | SuggestionHandler;\n  complete?: CompleteHandler;\n  files?: boolean | RegExp;\n  list?: boolean;\n  info?: boolean;\n  listPointer?: string;\n  maxRows?: number;\n}\n\n/** Generic input prompt settings. */\nexport interface GenericSuggestionsSettings<TValue, TRawValue>\n  extends GenericInputPromptSettings<TValue, TRawValue> {\n  keys?: GenericSuggestionsKeys;\n  id?: string;\n  suggestions?: Array<string | number> | SuggestionHandler;\n  complete?: CompleteHandler;\n  files?: boolean | RegExp;\n  list?: boolean;\n  info?: boolean;\n  listPointer: string;\n  maxRows: number;\n}\n\nconst sep = Deno.build.os === \"windows\" ? \"\\\\\" : \"/\";\n\n/** Generic input prompt representation. */\nexport abstract class GenericSuggestions<\n  TValue,\n  TRawValue,\n  TSettings extends GenericSuggestionsSettings<TValue, TRawValue>,\n> extends GenericInput<TValue, TRawValue, TSettings> {\n  protected suggestionsIndex = -1;\n  protected suggestionsOffset = 0;\n  protected suggestions: Array<string | number> = [];\n  #hasReadPermissions?: boolean;\n\n  /**\n   * Prompt constructor.\n   * @param settings Prompt settings.\n   */\n  protected constructor(settings: TSettings) {\n    super({\n      ...settings,\n      keys: {\n        complete: [\"tab\"],\n        next: [\"up\"],\n        previous: [\"down\"],\n        nextPage: [\"pageup\"],\n        previousPage: [\"pagedown\"],\n        ...(settings.keys ?? {}),\n      },\n    });\n  }\n\n  protected get localStorage(): LocalStorage | null {\n    // Keep support for deno < 1.10.\n    if (this.settings.id && \"localStorage\" in window) {\n      try {\n        // deno-lint-ignore no-explicit-any\n        return (window as any).localStorage;\n      } catch (_) {\n        // Ignore error if --location is not set.\n      }\n    }\n    return null;\n  }\n\n  protected loadSuggestions(): Array<string | number> {\n    if (this.settings.id) {\n      const json = this.localStorage?.getItem(this.settings.id);\n      const suggestions: Array<string | number> = json ? JSON.parse(json) : [];\n      if (!Array.isArray(suggestions)) {\n        return [];\n      }\n      return suggestions;\n    }\n    return [];\n  }\n\n  protected saveSuggestions(...suggestions: Array<string | number>): void {\n    if (this.settings.id) {\n      this.localStorage?.setItem(\n        this.settings.id,\n        JSON.stringify([\n          ...suggestions,\n          ...this.loadSuggestions(),\n        ].filter(uniqueSuggestions)),\n      );\n    }\n  }\n\n  protected async render(): Promise<void> {\n    if (this.settings.files && this.#hasReadPermissions === undefined) {\n      const status = await Deno.permissions.request({ name: \"read\" });\n      // disable path completion if read permissions are denied.\n      this.#hasReadPermissions = status.state === \"granted\";\n    }\n    await this.match();\n    return super.render();\n  }\n\n  protected async match(): Promise<void> {\n    this.suggestions = await this.getSuggestions();\n    this.suggestionsIndex = Math.max(\n      this.getCurrentInputValue().trim().length === 0 ? -1 : 0,\n      Math.min(this.suggestions.length - 1, this.suggestionsIndex),\n    );\n    this.suggestionsOffset = Math.max(\n      0,\n      Math.min(\n        this.suggestions.length - this.getListHeight(),\n        this.suggestionsOffset,\n      ),\n    );\n  }\n\n  protected input(): string {\n    return super.input() + dim(this.getSuggestion());\n  }\n\n  protected getSuggestion(): string {\n    return this.suggestions[this.suggestionsIndex]?.toString()\n      .substr(\n        this.getCurrentInputValue().length,\n      ) ?? \"\";\n  }\n\n  protected async getUserSuggestions(\n    input: string,\n  ): Promise<Array<string | number>> {\n    return typeof this.settings.suggestions === \"function\"\n      ? await this.settings.suggestions(input)\n      : this.settings.suggestions ?? [];\n  }\n\n  #isFileModeEnabled(): boolean {\n    return !!this.settings.files && this.#hasReadPermissions === true;\n  }\n\n  protected async getFileSuggestions(\n    input: string,\n  ): Promise<Array<string | number>> {\n    if (!this.#isFileModeEnabled()) {\n      return [];\n    }\n\n    const path = await Deno.stat(input)\n      .then((file) => file.isDirectory ? input : dirname(input))\n      .catch(() => dirname(input));\n\n    return await listDir(path, this.settings.files);\n  }\n\n  protected async getSuggestions(): Promise<Array<string | number>> {\n    const input = this.getCurrentInputValue();\n    const suggestions = [\n      ...this.loadSuggestions(),\n      ...await this.getUserSuggestions(input),\n      ...await this.getFileSuggestions(input),\n    ].filter(uniqueSuggestions);\n\n    if (!input.length) {\n      return suggestions;\n    }\n\n    return suggestions\n      .filter((value: string | number) =>\n        stripColor(value.toString())\n          .toLowerCase()\n          .startsWith(input.toLowerCase())\n      )\n      .sort((a: string | number, b: string | number) =>\n        distance((a || a).toString(), input) -\n        distance((b || b).toString(), input)\n      );\n  }\n\n  protected body(): string | Promise<string> {\n    return this.getList() + this.getInfo();\n  }\n\n  protected getInfo(): string {\n    if (!this.settings.info) {\n      return \"\";\n    }\n    const selected: number = this.suggestionsIndex + 1;\n    const matched: number = this.suggestions.length;\n    const actions: Array<[string, Array<string>]> = [];\n\n    if (this.suggestions.length) {\n      if (this.settings.list) {\n        actions.push(\n          [\"Next\", getFiguresByKeys(this.settings.keys?.next ?? [])],\n          [\"Previous\", getFiguresByKeys(this.settings.keys?.previous ?? [])],\n          [\"Next Page\", getFiguresByKeys(this.settings.keys?.nextPage ?? [])],\n          [\n            \"Previous Page\",\n            getFiguresByKeys(this.settings.keys?.previousPage ?? []),\n          ],\n        );\n      } else {\n        actions.push(\n          [\"Next\", getFiguresByKeys(this.settings.keys?.next ?? [])],\n          [\"Previous\", getFiguresByKeys(this.settings.keys?.previous ?? [])],\n        );\n      }\n      actions.push(\n        [\"Complete\", getFiguresByKeys(this.settings.keys?.complete ?? [])],\n      );\n    }\n    actions.push(\n      [\"Submit\", getFiguresByKeys(this.settings.keys?.submit ?? [])],\n    );\n\n    let info = this.settings.indent;\n    if (this.suggestions.length) {\n      info += brightBlue(Figures.INFO) + bold(` ${selected}/${matched} `);\n    }\n    info += actions\n      .map((cur) => `${cur[0]}: ${bold(cur[1].join(\" \"))}`)\n      .join(\", \");\n\n    return info;\n  }\n\n  protected getList(): string {\n    if (!this.suggestions.length || !this.settings.list) {\n      return \"\";\n    }\n    const list: Array<string> = [];\n    const height: number = this.getListHeight();\n    for (\n      let i = this.suggestionsOffset;\n      i < this.suggestionsOffset + height;\n      i++\n    ) {\n      list.push(\n        this.getListItem(\n          this.suggestions[i],\n          this.suggestionsIndex === i,\n        ),\n      );\n    }\n    if (list.length && this.settings.info) {\n      list.push(\"\");\n    }\n    return list.join(\"\\n\");\n  }\n\n  /**\n   * Render option.\n   * @param value        Option.\n   * @param isSelected  Set to true if option is selected.\n   */\n  protected getListItem(\n    value: string | number,\n    isSelected?: boolean,\n  ): string {\n    let line = this.settings.indent ?? \"\";\n    line += isSelected ? `${this.settings.listPointer} ` : \"  \";\n    if (isSelected) {\n      line += underline(this.highlight(value));\n    } else {\n      line += this.highlight(value);\n    }\n    return line;\n  }\n\n  /** Get suggestions row height. */\n  protected getListHeight(\n    suggestions: Array<string | number> = this.suggestions,\n  ): number {\n    return Math.min(\n      suggestions.length,\n      this.settings.maxRows || suggestions.length,\n    );\n  }\n\n  /**\n   * Handle user input event.\n   * @param event Key event.\n   */\n  protected async handleEvent(event: KeyCode): Promise<void> {\n    switch (true) {\n      case this.isKey(this.settings.keys, \"next\", event):\n        if (this.settings.list) {\n          this.selectPreviousSuggestion();\n        } else {\n          this.selectNextSuggestion();\n        }\n        break;\n      case this.isKey(this.settings.keys, \"previous\", event):\n        if (this.settings.list) {\n          this.selectNextSuggestion();\n        } else {\n          this.selectPreviousSuggestion();\n        }\n        break;\n      case this.isKey(this.settings.keys, \"nextPage\", event):\n        if (this.settings.list) {\n          this.selectPreviousSuggestionsPage();\n        } else {\n          this.selectNextSuggestionsPage();\n        }\n        break;\n      case this.isKey(this.settings.keys, \"previousPage\", event):\n        if (this.settings.list) {\n          this.selectNextSuggestionsPage();\n        } else {\n          this.selectPreviousSuggestionsPage();\n        }\n        break;\n      case this.isKey(this.settings.keys, \"complete\", event):\n        await this.#completeValue();\n        break;\n      case this.isKey(this.settings.keys, \"moveCursorRight\", event):\n        if (this.inputIndex < this.inputValue.length) {\n          this.moveCursorRight();\n        } else {\n          await this.#completeValue();\n        }\n        break;\n      default:\n        await super.handleEvent(event);\n    }\n  }\n\n  /** Delete char right. */\n  protected deleteCharRight(): void {\n    if (this.inputIndex < this.inputValue.length) {\n      super.deleteCharRight();\n      if (!this.getCurrentInputValue().length) {\n        this.suggestionsIndex = -1;\n        this.suggestionsOffset = 0;\n      }\n    }\n  }\n\n  async #completeValue() {\n    this.inputValue = await this.complete();\n    this.inputIndex = this.inputValue.length;\n    this.suggestionsIndex = 0;\n    this.suggestionsOffset = 0;\n  }\n\n  protected async complete(): Promise<string> {\n    let input: string = this.getCurrentInputValue();\n    const suggestion: string | undefined = this\n      .suggestions[this.suggestionsIndex]?.toString();\n\n    if (this.settings.complete) {\n      input = await this.settings.complete(input, suggestion);\n    } else if (\n      this.#isFileModeEnabled() &&\n      input.at(-1) !== sep &&\n      await isDirectory(input) &&\n      (\n        this.getCurrentInputValue().at(-1) !== \".\" ||\n        this.getCurrentInputValue().endsWith(\"..\")\n      )\n    ) {\n      input += sep;\n    } else if (suggestion) {\n      input = suggestion;\n    }\n\n    return this.#isFileModeEnabled() ? normalize(input) : input;\n  }\n\n  /** Select previous suggestion. */\n  protected selectPreviousSuggestion(): void {\n    if (this.suggestions.length) {\n      if (this.suggestionsIndex > -1) {\n        this.suggestionsIndex--;\n        if (this.suggestionsIndex < this.suggestionsOffset) {\n          this.suggestionsOffset--;\n        }\n      }\n    }\n  }\n\n  /** Select next suggestion. */\n  protected selectNextSuggestion(): void {\n    if (this.suggestions.length) {\n      if (this.suggestionsIndex < this.suggestions.length - 1) {\n        this.suggestionsIndex++;\n        if (\n          this.suggestionsIndex >=\n            this.suggestionsOffset + this.getListHeight()\n        ) {\n          this.suggestionsOffset++;\n        }\n      }\n    }\n  }\n\n  /** Select previous suggestions page. */\n  protected selectPreviousSuggestionsPage(): void {\n    if (this.suggestions.length) {\n      const height: number = this.getListHeight();\n      if (this.suggestionsOffset >= height) {\n        this.suggestionsIndex -= height;\n        this.suggestionsOffset -= height;\n      } else if (this.suggestionsOffset > 0) {\n        this.suggestionsIndex -= this.suggestionsOffset;\n        this.suggestionsOffset = 0;\n      }\n    }\n  }\n\n  /** Select next suggestions page. */\n  protected selectNextSuggestionsPage(): void {\n    if (this.suggestions.length) {\n      const height: number = this.getListHeight();\n      if (this.suggestionsOffset + height + height < this.suggestions.length) {\n        this.suggestionsIndex += height;\n        this.suggestionsOffset += height;\n      } else if (this.suggestionsOffset + height < this.suggestions.length) {\n        const offset = this.suggestions.length - height;\n        this.suggestionsIndex += offset - this.suggestionsOffset;\n        this.suggestionsOffset = offset;\n      }\n    }\n  }\n}\n\nfunction uniqueSuggestions(\n  value: unknown,\n  index: number,\n  self: Array<unknown>,\n) {\n  return typeof value !== \"undefined\" && value !== \"\" &&\n    self.indexOf(value) === index;\n}\n\nfunction isDirectory(path: string): Promise<boolean> {\n  return Deno.stat(path)\n    .then((file) => file.isDirectory)\n    .catch(() => false);\n}\n\nasync function listDir(\n  path: string,\n  mode?: boolean | RegExp,\n): Promise<Array<string>> {\n  const fileNames: string[] = [];\n\n  for await (const file of Deno.readDir(path || \".\")) {\n    if (\n      mode === true && (file.name.startsWith(\".\") || file.name.endsWith(\"~\"))\n    ) {\n      continue;\n    }\n    const filePath = join(path, file.name);\n\n    if (mode instanceof RegExp && !mode.test(filePath)) {\n      continue;\n    }\n    fileNames.push(filePath);\n  }\n\n  return fileNames.sort(function (a, b) {\n    return a.toLowerCase().localeCompare(b.toLowerCase());\n  });\n}\n", "// Copyright Isaac Z. Schlueter and Contributors. All rights reserved. ISC license.\n// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * The semantic version parser.\n *\n * Adapted directly from [semver](https://github.com/npm/node-semver).\n *\n * ## Versions\n *\n * A \"version\" is described by the `v2.0.0` specification found at\n * <https://semver.org>.\n *\n * A leading `\"=\"` or `\"v\"` character is stripped off and ignored.\n *\n * ## Ranges\n *\n * A `version range` is a set of `comparators` which specify versions that satisfy\n * the range.\n *\n * A `comparator` is composed of an `operator` and a `version`. The set of\n * primitive `operators` is:\n *\n * - `<` Less than\n * - `<=` Less than or equal to\n * - `>` Greater than\n * - `>=` Greater than or equal to\n * - `=` Equal. If no operator is specified, then equality is assumed, so this\n *   operator is optional, but MAY be included.\n *\n * For example, the comparator `>=1.2.7` would match the versions `1.2.7`, `1.2.8`,\n * `2.5.3`, and `1.3.9`, but not the versions `1.2.6` or `1.1.0`.\n *\n * Comparators can be joined by whitespace to form a `comparator set`, which is\n * satisfied by the **intersection** of all of the comparators it includes.\n *\n * A range is composed of one or more comparator sets, joined by `||`. A version\n * matches a range if and only if every comparator in at least one of the\n * `||`-separated comparator sets is satisfied by the version.\n *\n * For example, the range `>=1.2.7 <1.3.0` would match the versions `1.2.7`,\n * `1.2.8`, and `1.2.99`, but not the versions `1.2.6`, `1.3.0`, or `1.1.0`.\n *\n * The range `1.2.7 || >=1.2.9 <2.0.0` would match the versions `1.2.7`, `1.2.9`,\n * and `1.4.6`, but not the versions `1.2.8` or `2.0.0`.\n *\n * ### Prerelease Tags\n *\n * If a version has a prerelease tag (for example, `1.2.3-alpha.3`) then it will\n * only be allowed to satisfy comparator sets if at least one comparator with the\n * same `[major, minor, patch]` tuple also has a prerelease tag.\n *\n * For example, the range `>1.2.3-alpha.3` would be allowed to match the version\n * `1.2.3-alpha.7`, but it would _not_ be satisfied by `3.4.5-alpha.9`, even though\n * `3.4.5-alpha.9` is technically \"greater than\" `1.2.3-alpha.3` according to the\n * SemVer sort rules. The version range only accepts prerelease tags on the `1.2.3`\n * version. The version `3.4.5` _would_ satisfy the range, because it does not have\n * a prerelease flag, and `3.4.5` is greater than `1.2.3-alpha.7`.\n *\n * The purpose for this behavior is twofold. First, prerelease versions frequently\n * are updated very quickly, and contain many breaking changes that are (by the\n * author\"s design) not yet fit for public consumption. Therefore, by default, they\n * are excluded from range matching semantics.\n *\n * Second, a user who has opted into using a prerelease version has clearly\n * indicated the intent to use _that specific_ set of alpha/beta/rc versions. By\n * including a prerelease tag in the range, the user is indicating that they are\n * aware of the risk. However, it is still not appropriate to assume that they have\n * opted into taking a similar risk on the _next_ set of prerelease versions.\n *\n * Note that this behavior can be suppressed (treating all prerelease versions as\n * if they were normal versions, for the purpose of range matching) by setting the\n * `includePrerelease` flag on the options object to any [functions](#functions)\n * that do range matching.\n *\n * #### Prerelease Identifiers\n *\n * The method `.increment` takes an additional `identifier` string argument that\n * will append the value of the string as a prerelease identifier:\n *\n * ```javascript\n * semver.increment(\"1.2.3\", \"prerelease\", \"beta\");\n * // \"1.2.4-beta.0\"\n * ```\n *\n * ### Build Metadata\n *\n * Build metadata has no affect on comparisons and must be a `.` delimited\n * alpha-numeric string. When parsing a version it is retained on the `build: string[]` field\n * of the semver instance. When incrementing there is an additional parameter that\n * can set the build metadata on the semver instance.\n *\n * To print the full version including build metadata you must call `semver.format({ style: \"full\" })`.\n *\n * For compatibility reasons the `.version` field will not contain the build metadata, you can only\n * get a full version string by calling the format function.\n *\n * ### Advanced Range Syntax\n *\n * Advanced range syntax desugars to primitive comparators in deterministic ways.\n *\n * Advanced ranges may be combined in the same way as primitive comparators using\n * white space or `||`.\n *\n * #### Hyphen Ranges `X.Y.Z - A.B.C`\n *\n * Specifies an inclusive set.\n *\n * - `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`\n *\n * If a partial version is provided as the first version in the inclusive range,\n * then the missing pieces are replaced with zeroes.\n *\n * - `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`\n *\n * If a partial version is provided as the second version in the inclusive range,\n * then all versions that start with the supplied parts of the tuple are accepted,\n * but nothing that would be greater than the provided tuple parts.\n *\n * - `1.2.3 - 2.3` := `>=1.2.3 <2.4.0`\n * - `1.2.3 - 2` := `>=1.2.3 <3.0.0`\n *\n * #### X-Ranges `1.2.x` `1.X` `1.2.*` `*`\n *\n * Any of `X`, `x`, or `*` may be used to \"stand in\" for one of the numeric values\n * in the `[major, minor, patch]` tuple.\n *\n * - `*` := `>=0.0.0` (Any version satisfies)\n * - `1.x` := `>=1.0.0 <2.0.0` (Matching major version)\n * - `1.2.x` := `>=1.2.0 <1.3.0` (Matching major and minor versions)\n *\n * A partial version range is treated as an X-Range, so the special character is in\n * fact optional.\n *\n * - `\"\"` (empty string) := `*` := `>=0.0.0`\n * - `1` := `1.x.x` := `>=1.0.0 <2.0.0`\n * - `1.2` := `1.2.x` := `>=1.2.0 <1.3.0`\n *\n * #### Tilde Ranges `~1.2.3` `~1.2` `~1`\n *\n * Allows patch-level changes if a minor version is specified on the comparator.\n * Allows minor-level changes if not.\n *\n * - `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0`\n * - `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0` (Same as `1.2.x`)\n * - `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0` (Same as `1.x`)\n * - `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0`\n * - `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0` (Same as `0.2.x`)\n * - `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0` (Same as `0.x`)\n * - `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0` Note that prereleases in the\n *   `1.2.3` version will be allowed, if they are greater than or equal to\n *   `beta.2`. So, `1.2.3-beta.4` would be allowed, but `1.2.4-beta.2` would not,\n *   because it is a prerelease of a different `[major, minor, patch]` tuple.\n *\n * #### Caret Ranges `^1.2.3` `^0.2.5` `^0.0.4`\n *\n * Allows changes that do not modify the left-most non-zero element in the\n * `[major, minor, patch]` tuple. In other words, this allows patch and minor\n * updates for versions `1.0.0` and above, patch updates for versions\n * `0.X >=0.1.0`, and _no_ updates for versions `0.0.X`.\n *\n * Many authors treat a `0.x` version as if the `x` were the major\n * \"breaking-change\" indicator.\n *\n * Caret ranges are ideal when an author may make breaking changes between `0.2.4`\n * and `0.3.0` releases, which is a common practice. However, it presumes that\n * there will _not_ be breaking changes between `0.2.4` and `0.2.5`. It allows for\n * changes that are presumed to be additive (but non-breaking), according to\n * commonly observed practices.\n *\n * - `^1.2.3` := `>=1.2.3 <2.0.0`\n * - `^0.2.3` := `>=0.2.3 <0.3.0`\n * - `^0.0.3` := `>=0.0.3 <0.0.4`\n * - `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0` Note that prereleases in the\n *   `1.2.3` version will be allowed, if they are greater than or equal to\n *   `beta.2`. So, `1.2.3-beta.4` would be allowed, but `1.2.4-beta.2` would not,\n *   because it is a prerelease of a different `[major, minor, patch]` tuple.\n * - `^0.0.3-beta` := `>=0.0.3-beta <0.0.4` Note that prereleases in the `0.0.3`\n *   version _only_ will be allowed, if they are greater than or equal to `beta`.\n *   So, `0.0.3-pr.2` would be allowed.\n *\n * When parsing caret ranges, a missing `patch` value desugars to the number `0`,\n * but will allow flexibility within that value, even if the major and minor\n * versions are both `0`.\n *\n * - `^1.2.x` := `>=1.2.0 <2.0.0`\n * - `^0.0.x` := `>=0.0.0 <0.1.0`\n * - `^0.0` := `>=0.0.0 <0.1.0`\n *\n * A missing `minor` and `patch` values will desugar to zero, but also allow\n * flexibility within those values, even if the major version is zero.\n *\n * - `^1.x` := `>=1.0.0 <2.0.0`\n * - `^0.x` := `>=0.0.0 <1.0.0`\n *\n * ### Range Grammar\n *\n * Putting all this together, here is a Backus-Naur grammar for ranges, for the\n * benefit of parser authors:\n *\n * ```bnf\n * range-set  ::= range ( logical-or range ) *\n * logical-or ::= ( \" \" ) * \"||\" ( \" \" ) *\n * range      ::= hyphen | simple ( \" \" simple ) * | \"\"\n * hyphen     ::= partial \" - \" partial\n * simple     ::= primitive | partial | tilde | caret\n * primitive  ::= ( \"<\" | \">\" | \">=\" | \"<=\" | \"=\" ) partial\n * partial    ::= xr ( \".\" xr ( \".\" xr qualifier ? )? )?\n * xr         ::= \"x\" | \"X\" | \"*\" | nr\n * nr         ::= \"0\" | [\"1\"-\"9\"] ( [\"0\"-\"9\"] ) *\n * tilde      ::= \"~\" partial\n * caret      ::= \"^\" partial\n * qualifier  ::= ( \"-\" pre )? ( \"+\" build )?\n * pre        ::= parts\n * build      ::= parts\n * parts      ::= part ( \".\" part ) *\n * part       ::= nr | [-0-9A-Za-z]+\n * ```\n *\n * Note that, since ranges may be non-contiguous, a version might not be greater\n * than a range, less than a range, _or_ satisfy a range! For example, the range\n * `1.2 <1.2.9 || >2.0.0` would have a hole from `1.2.9` until `2.0.0`, so the\n * version `1.2.10` would not be greater than the range (because `2.0.1` satisfies,\n * which is higher), nor less than the range (since `1.2.8` satisfies, which is\n * lower), and it also does not satisfy the range.\n *\n * If you want to know if a version satisfies or does not satisfy a range, use the\n * {@linkcode satisfies} function.\n *\n * This module is browser compatible.\n *\n * @example\n * ```ts\n * import * as semver from \"https://deno.land/std@$STD_VERSION/semver/mod.ts\";\n *\n * semver.valid(\"1.2.3\"); // \"1.2.3\"\n * semver.valid(\"a.b.c\"); // null\n * semver.satisfies(\"1.2.3\", \"1.x || >=2.5.0 || 5.0.0 - 7.2.3\"); // true\n * semver.gt(\"1.2.3\", \"9.8.7\"); // false\n * semver.lt(\"1.2.3\", \"9.8.7\"); // true\n * semver.minVersion(\">=1.0.0\"); // \"1.0.0\"\n * ```\n *\n * @module\n */\n\nexport type ReleaseType =\n  | \"pre\"\n  | \"major\"\n  | \"premajor\"\n  | \"minor\"\n  | \"preminor\"\n  | \"patch\"\n  | \"prepatch\"\n  | \"prerelease\";\n\nexport type Operator =\n  | \"===\"\n  | \"!==\"\n  | \"\"\n  | \"=\"\n  | \"==\"\n  | \"!=\"\n  | \">\"\n  | \">=\"\n  | \"<\"\n  | \"<=\";\n\nexport interface Options {\n  /**\n   * Set to suppress the default behavior of excluding prerelease tagged\n   * versions from ranges unless they are explicitly opted into.\n   */\n  includePrerelease?: boolean;\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexport const SEMVER_SPEC_VERSION = \"2.0.0\";\n\nconst MAX_LENGTH = 256;\n\n// The actual regexps\nconst re: RegExp[] = [];\nconst src: string[] = [];\nlet R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nconst NUMERICIDENTIFIER: number = R++;\nsrc[NUMERICIDENTIFIER] = \"0|[1-9]\\\\d*\";\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nconst NONNUMERICIDENTIFIER: number = R++;\nsrc[NONNUMERICIDENTIFIER] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nconst MAINVERSION: number = R++;\nconst nid = src[NUMERICIDENTIFIER];\nsrc[MAINVERSION] = `(${nid})\\\\.(${nid})\\\\.(${nid})`;\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nconst PRERELEASEIDENTIFIER: number = R++;\nsrc[PRERELEASEIDENTIFIER] = \"(?:\" + src[NUMERICIDENTIFIER] + \"|\" +\n  src[NONNUMERICIDENTIFIER] + \")\";\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nconst PRERELEASE: number = R++;\nsrc[PRERELEASE] = \"(?:-(\" +\n  src[PRERELEASEIDENTIFIER] +\n  \"(?:\\\\.\" +\n  src[PRERELEASEIDENTIFIER] +\n  \")*))\";\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nconst BUILDIDENTIFIER: number = R++;\nsrc[BUILDIDENTIFIER] = \"[0-9A-Za-z-]+\";\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nconst BUILD: number = R++;\nsrc[BUILD] = \"(?:\\\\+(\" + src[BUILDIDENTIFIER] + \"(?:\\\\.\" +\n  src[BUILDIDENTIFIER] + \")*))\";\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nconst FULL: number = R++;\nconst FULLPLAIN = \"v?\" + src[MAINVERSION] + src[PRERELEASE] + \"?\" + src[BUILD] +\n  \"?\";\n\nsrc[FULL] = \"^\" + FULLPLAIN + \"$\";\n\nconst GTLT: number = R++;\nsrc[GTLT] = \"((?:<|>)?=?)\";\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nconst XRANGEIDENTIFIER: number = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + \"|x|X|\\\\*\";\n\nconst XRANGEPLAIN: number = R++;\nsrc[XRANGEPLAIN] = \"[v=\\\\s]*(\" +\n  src[XRANGEIDENTIFIER] +\n  \")\" +\n  \"(?:\\\\.(\" +\n  src[XRANGEIDENTIFIER] +\n  \")\" +\n  \"(?:\\\\.(\" +\n  src[XRANGEIDENTIFIER] +\n  \")\" +\n  \"(?:\" +\n  src[PRERELEASE] +\n  \")?\" +\n  src[BUILD] +\n  \"?\" +\n  \")?)?\";\n\nconst XRANGE: number = R++;\nsrc[XRANGE] = \"^\" + src[GTLT] + \"\\\\s*\" + src[XRANGEPLAIN] + \"$\";\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nconst LONETILDE: number = R++;\nsrc[LONETILDE] = \"(?:~>?)\";\n\nconst TILDE: number = R++;\nsrc[TILDE] = \"^\" + src[LONETILDE] + src[XRANGEPLAIN] + \"$\";\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nconst LONECARET: number = R++;\nsrc[LONECARET] = \"(?:\\\\^)\";\n\nconst CARET: number = R++;\nsrc[CARET] = \"^\" + src[LONECARET] + src[XRANGEPLAIN] + \"$\";\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nconst COMPARATOR: number = R++;\nsrc[COMPARATOR] = \"^\" + src[GTLT] + \"\\\\s*(\" + FULLPLAIN + \")$|^$\";\n\n// Something like `1.2.3 - 1.2.4`\nconst HYPHENRANGE: number = R++;\nsrc[HYPHENRANGE] = \"^\\\\s*(\" +\n  src[XRANGEPLAIN] +\n  \")\" +\n  \"\\\\s+-\\\\s+\" +\n  \"(\" +\n  src[XRANGEPLAIN] +\n  \")\" +\n  \"\\\\s*$\";\n\n// Star ranges basically just allow anything at all.\nconst STAR: number = R++;\nsrc[STAR] = \"(<|>)?=?\\\\s*\\\\*\";\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (let i = 0; i < R; i++) {\n  if (!re[i]) {\n    re[i] = new RegExp(src[i]);\n  }\n}\n\n/**\n * Attempt to parse a string as a semantic version, returning either a `SemVer`\n * object or `null`.\n */\nexport function parse(\n  version: string | SemVer | null,\n  options?: Options,\n): SemVer | null {\n  if (typeof options !== \"object\") {\n    options = {\n      includePrerelease: false,\n    };\n  }\n\n  if (version instanceof SemVer) {\n    return version;\n  }\n\n  if (typeof version !== \"string\") {\n    return null;\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null;\n  }\n\n  const r: RegExp = re[FULL];\n  if (!r.test(version)) {\n    return null;\n  }\n\n  try {\n    return new SemVer(version, options);\n  } catch {\n    return null;\n  }\n}\n\n/** Returns the parsed version, or null if it's not valid. */\nexport function valid(\n  version: string | SemVer | null,\n  options?: Options,\n): string | null {\n  if (version === null) return null;\n  const v: SemVer | null = parse(version, options);\n  return v ? v.version : null;\n}\n\nexport class SemVer {\n  raw!: string;\n  options!: Options;\n\n  major!: number;\n  minor!: number;\n  patch!: number;\n  version!: string;\n  build!: ReadonlyArray<string>;\n  prerelease!: Array<string | number>;\n\n  constructor(version: string | SemVer, options?: Options) {\n    if (typeof options !== \"object\") {\n      options = {\n        includePrerelease: false,\n      };\n    }\n    if (version instanceof SemVer) {\n      version = version.version;\n    } else if (typeof version !== \"string\") {\n      throw new TypeError(\"Invalid Version: \" + version);\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        \"version is longer than \" + MAX_LENGTH + \" characters\",\n      );\n    }\n\n    if (!(this instanceof SemVer)) {\n      return new SemVer(version, options);\n    }\n\n    this.options = options;\n\n    const m = version.trim().match(re[FULL]);\n\n    if (!m) {\n      throw new TypeError(\"Invalid Version: \" + version);\n    }\n\n    // these are actually numbers\n    this.major = +m[1];\n    this.minor = +m[2];\n    this.patch = +m[3];\n\n    if (this.major > Number.MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError(\"Invalid major version\");\n    }\n\n    if (this.minor > Number.MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError(\"Invalid minor version\");\n    }\n\n    if (this.patch > Number.MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError(\"Invalid patch version\");\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = [];\n    } else {\n      this.prerelease = m[4].split(\".\").map((id: string) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num: number = +id;\n          if (num >= 0 && num < Number.MAX_SAFE_INTEGER) {\n            return num;\n          }\n        }\n        return id;\n      });\n    }\n\n    this.build = m[5] ? m[5].split(\".\") : [];\n    this.format();\n    this.raw = this.version;\n  }\n\n  format(\n    opts: { style?: \"release\" | \"prerelease\" | \"build\" | \"full\" } = {},\n  ): string {\n    const { style } = opts;\n\n    // todo: Consider a refactor of this class to have no side effects. Increment should return\n    // a new SemVer instance with the new values. This would be a breaking change.\n    // see https://github.com/denoland/deno_std/issues/3110 for discussion details\n    const release = this.version = this.major + \".\" + this.minor + \".\" +\n      this.patch;\n    if (this.prerelease.length) {\n      this.version += \"-\" + this.prerelease.join(\".\");\n    }\n\n    switch (style) {\n      case \"build\":\n        return [release, this.build.join(\".\")].filter((v) => v).join(\"+\");\n      case \"full\":\n        return [this.version, this.build.join(\".\")].filter((v) => v).join(\"+\");\n      case \"release\":\n        return release;\n      case \"prerelease\":\n        return this.version;\n      default:\n        // todo: Have this function return the full version by default. This would be a breaking change.\n        // see this issue for discussion details https://github.com/denoland/deno_std/issues/3110\n        return this.version;\n    }\n  }\n\n  compare(other: string | SemVer): 1 | 0 | -1 {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    return this.compareMain(other) || this.comparePre(other);\n  }\n\n  compareMain(other: string | SemVer): 1 | 0 | -1 {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    );\n  }\n\n  comparePre(other: string | SemVer): 1 | 0 | -1 {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1;\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1;\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0;\n    }\n\n    let i = 0;\n    do {\n      const a: string | number = this.prerelease[i];\n      const b: string | number = other.prerelease[i];\n      if (a === undefined && b === undefined) {\n        return 0;\n      } else if (b === undefined) {\n        return 1;\n      } else if (a === undefined) {\n        return -1;\n      } else if (a === b) {\n        continue;\n      } else {\n        return compareIdentifiers(a, b);\n      }\n    } while (++i);\n    return 1;\n  }\n\n  compareBuild(other: string | SemVer): 1 | 0 | -1 {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    let i = 0;\n    do {\n      const a: string = this.build[i];\n      const b: string = other.build[i];\n      if (a === undefined && b === undefined) {\n        return 0;\n      } else if (b === undefined) {\n        return 1;\n      } else if (a === undefined) {\n        return -1;\n      } else if (a === b) {\n        continue;\n      } else {\n        return compareIdentifiers(a, b);\n      }\n    } while (++i);\n    return 1;\n  }\n\n  increment(\n    release: ReleaseType,\n    identifier?: string,\n    metadata?: string,\n  ): SemVer {\n    switch (release) {\n      case \"premajor\":\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor = 0;\n        this.major++;\n        this.increment(\"pre\", identifier);\n        break;\n      case \"preminor\":\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor++;\n        this.increment(\"pre\", identifier);\n        break;\n      case \"prepatch\":\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0;\n        this.increment(\"patch\", identifier);\n        this.increment(\"pre\", identifier);\n        break;\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case \"prerelease\":\n        if (this.prerelease.length === 0) {\n          this.increment(\"patch\", identifier);\n        }\n        this.increment(\"pre\", identifier);\n        break;\n\n      case \"major\":\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++;\n        }\n        this.minor = 0;\n        this.patch = 0;\n        this.prerelease = [];\n        break;\n      case \"minor\":\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++;\n        }\n        this.patch = 0;\n        this.prerelease = [];\n        break;\n      case \"patch\":\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++;\n        }\n        this.prerelease = [];\n        break;\n      // This probably shouldn't be used publicly.\n      // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n      case \"pre\":\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0];\n        } else {\n          let i: number = this.prerelease.length;\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === \"number\") {\n              // deno-fmt-ignore\n              (this.prerelease[i] as number)++;\n              i = -2;\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0);\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1] as number)) {\n              this.prerelease = [identifier, 0];\n            }\n          } else {\n            this.prerelease = [identifier, 0];\n          }\n        }\n        break;\n\n      default:\n        throw new Error(\"invalid increment argument: \" + release);\n    }\n    this.build = metadata === undefined ? this.build : metadata.split(\".\");\n    this.format();\n    this.raw = this.version;\n    return this;\n  }\n\n  toString(): string {\n    return this.version;\n  }\n}\n\n/**\n * Returns the version incremented by the release type\n * (major, minor, patch, or prerelease), or null if it's not valid.\n *\n * `premajor` in one call will bump the version up to the next major version and\n * down to a prerelease of that major version. `preminor`, and `prepatch` work\n * the same way.\n *\n * If called from a non-prerelease version, the `prerelease` will work the same\n * as `prepatch`. It increments the patch version, then makes a prerelease. If\n * the input version is already a prerelease it simply increments it.\n *\n * If the original version has build metadata and the `metadata` parameter is\n * `undefined`, then it will be unchanged.\n */\nexport function increment(\n  version: string | SemVer,\n  release: ReleaseType,\n  options?: Options,\n  identifier?: string,\n  metadata?: string,\n): string | null {\n  if (typeof options === \"string\") {\n    metadata = identifier;\n    identifier = options;\n    options = undefined;\n  }\n  try {\n    return new SemVer(version, options).increment(release, identifier, metadata)\n      .format({ style: \"full\" });\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Returns difference between two versions by the release type  (`major`,\n * `premajor`, `minor`, `preminor`, `patch`, `prepatch`, or `prerelease`), or\n * null if the versions are the same.\n */\nexport function difference(\n  version1: string | SemVer,\n  version2: string | SemVer,\n  options?: Options,\n): ReleaseType | null {\n  if (eq(version1, version2, options)) {\n    return null;\n  } else {\n    const v1: SemVer | null = parse(version1);\n    const v2: SemVer | null = parse(version2);\n    let prefix = \"\";\n    let defaultResult: ReleaseType | null = null;\n\n    if (v1 && v2) {\n      if (v1.prerelease.length || v2.prerelease.length) {\n        prefix = \"pre\";\n        defaultResult = \"prerelease\";\n      }\n\n      for (const key in v1) {\n        if (key === \"major\" || key === \"minor\" || key === \"patch\") {\n          if (v1[key] !== v2[key]) {\n            return (prefix + key) as ReleaseType;\n          }\n        }\n      }\n    }\n    return defaultResult; // may be undefined\n  }\n}\n\nconst numeric = /^[0-9]+$/;\n\nexport function compareIdentifiers(\n  a: string | number | null,\n  b: string | number | null,\n): 1 | 0 | -1 {\n  const anum: boolean = numeric.test(a as string);\n  const bnum: boolean = numeric.test(b as string);\n\n  if (a === null || b === null) throw \"Comparison against null invalid\";\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n}\n\nexport function rcompareIdentifiers(\n  a: string | null,\n  b: string | null,\n): 1 | 0 | -1 {\n  return compareIdentifiers(b, a);\n}\n\n/** Returns the major version number. */\nexport function major(\n  v: string | SemVer,\n  options?: Options,\n): number {\n  return new SemVer(v, options).major;\n}\n\n/** Returns the minor version number. */\nexport function minor(\n  v: string | SemVer,\n  options?: Options,\n): number {\n  return new SemVer(v, options).minor;\n}\n\n/** Returns the patch version number. */\nexport function patch(\n  v: string | SemVer,\n  options?: Options,\n): number {\n  return new SemVer(v, options).patch;\n}\n\n/**\n * Returns `0` if `v1 == v2`, or `1` if `v1` is greater, or `-1` if `v2` is\n * greater. Sorts in ascending order if passed to `Array.sort()`,\n */\nexport function compare(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): 1 | 0 | -1 {\n  return new SemVer(v1, options).compare(new SemVer(v2, options));\n}\n\n/**\n * The same as {@linkcode compare} but considers `build` when two versions are\n * equal. Sorts in ascending order if passed to `Array.sort()`.\n */\nexport function compareBuild(\n  a: string | SemVer,\n  b: string | SemVer,\n  options?: Options,\n): 1 | 0 | -1 {\n  const versionA = new SemVer(a, options);\n  const versionB = new SemVer(b, options);\n  return versionA.compare(versionB) || versionA.compareBuild(versionB);\n}\n\n/**\n * Returns `0` if `v1 == v2`, or `-1` if `v1` is greater, or `1` if `v2` is\n * greater. Sorts in descending order if passed to `Array.sort()`,\n */\nexport function rcompare(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): 1 | 0 | -1 {\n  return compare(v2, v1, options);\n}\n\nexport function sort<T extends string | SemVer>(\n  list: T[],\n  options?: Options,\n): T[] {\n  return list.sort((a, b) => {\n    return compareBuild(a, b, options);\n  });\n}\n\nexport function rsort<T extends string | SemVer>(\n  list: T[],\n  options?: Options,\n): T[] {\n  return list.sort((a, b) => {\n    return compareBuild(b, a, options);\n  });\n}\n\n/** Greater than comparison */\nexport function gt(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): boolean {\n  return compare(v1, v2, options) > 0;\n}\n\n/** Less than comparison */\nexport function lt(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): boolean {\n  return compare(v1, v2, options) < 0;\n}\n\n/**\n * This is true if they're logically equivalent, even if they're not the exact\n * same string.\n */\nexport function eq(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): boolean {\n  return compare(v1, v2, options) === 0;\n}\n\n/**\n * This is true if they're not logically equivalent, even if they're the exact\n * same string.\n */\nexport function neq(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): boolean {\n  return compare(v1, v2, options) !== 0;\n}\n\n/** Greater than or equal comparison */\nexport function gte(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): boolean {\n  return compare(v1, v2, options) >= 0;\n}\n\n/** Less than or equal comparison */\nexport function lte(\n  v1: string | SemVer,\n  v2: string | SemVer,\n  options?: Options,\n): boolean {\n  return compare(v1, v2, options) <= 0;\n}\n\n/**\n * Pass in a comparison string, and it'll call the corresponding comparison\n * function. `\"===\"` and `\"!==\"` do simple string comparison, but are included\n * for completeness. Throws if an invalid comparison string is provided.\n */\nexport function cmp(\n  v1: string | SemVer,\n  operator: Operator,\n  v2: string | SemVer,\n  options?: Options,\n): boolean {\n  switch (operator) {\n    case \"===\":\n      if (typeof v1 === \"object\") v1 = v1.version;\n      if (typeof v2 === \"object\") v2 = v2.version;\n      return v1 === v2;\n\n    case \"!==\":\n      if (typeof v1 === \"object\") v1 = v1.version;\n      if (typeof v2 === \"object\") v2 = v2.version;\n      return v1 !== v2;\n\n    case \"\":\n    case \"=\":\n    case \"==\":\n      return eq(v1, v2, options);\n\n    case \"!=\":\n      return neq(v1, v2, options);\n\n    case \">\":\n      return gt(v1, v2, options);\n\n    case \">=\":\n      return gte(v1, v2, options);\n\n    case \"<\":\n      return lt(v1, v2, options);\n\n    case \"<=\":\n      return lte(v1, v2, options);\n\n    default:\n      throw new TypeError(\"Invalid operator: \" + operator);\n  }\n}\n\nconst ANY: SemVer = {} as SemVer;\n\nexport class Comparator {\n  semver!: SemVer;\n  operator!: \"\" | \"=\" | \"<\" | \">\" | \"<=\" | \">=\";\n  value!: string;\n  options!: Options;\n\n  constructor(comp: string | Comparator, options?: Options) {\n    if (typeof options !== \"object\") {\n      options = {\n        includePrerelease: false,\n      };\n    }\n\n    if (comp instanceof Comparator) {\n      return comp;\n    }\n\n    if (!(this instanceof Comparator)) {\n      return new Comparator(comp, options);\n    }\n\n    this.options = options;\n    this.parse(comp);\n\n    if (this.semver === ANY) {\n      this.value = \"\";\n    } else {\n      this.value = this.operator + this.semver.version;\n    }\n  }\n\n  parse(comp: string) {\n    const r = re[COMPARATOR];\n    const m = comp.match(r);\n\n    if (!m) {\n      throw new TypeError(\"Invalid comparator: \" + comp);\n    }\n\n    const m1 = m[1] as \"\" | \"=\" | \"<\" | \">\" | \"<=\" | \">=\";\n    this.operator = m1 !== undefined ? m1 : \"\";\n\n    if (this.operator === \"=\") {\n      this.operator = \"\";\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY;\n    } else {\n      this.semver = new SemVer(m[2], this.options);\n    }\n  }\n\n  test(version: string | SemVer): boolean {\n    if (this.semver === ANY || version === ANY) {\n      return true;\n    }\n\n    if (typeof version === \"string\") {\n      version = new SemVer(version, this.options);\n    }\n\n    return cmp(version, this.operator, this.semver, this.options);\n  }\n\n  intersects(comp: Comparator, options?: Options): boolean {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError(\"a Comparator is required\");\n    }\n\n    if (typeof options !== \"object\") {\n      options = {\n        includePrerelease: false,\n      };\n    }\n\n    let rangeTmp: Range;\n\n    if (this.operator === \"\") {\n      if (this.value === \"\") {\n        return true;\n      }\n      rangeTmp = new Range(comp.value, options);\n      return satisfies(this.value, rangeTmp, options);\n    } else if (comp.operator === \"\") {\n      if (comp.value === \"\") {\n        return true;\n      }\n      rangeTmp = new Range(this.value, options);\n      return satisfies(comp.semver, rangeTmp, options);\n    }\n\n    const sameDirectionIncreasing: boolean =\n      (this.operator === \">=\" || this.operator === \">\") &&\n      (comp.operator === \">=\" || comp.operator === \">\");\n    const sameDirectionDecreasing: boolean =\n      (this.operator === \"<=\" || this.operator === \"<\") &&\n      (comp.operator === \"<=\" || comp.operator === \"<\");\n    const sameSemVer: boolean = this.semver.version === comp.semver.version;\n    const differentDirectionsInclusive: boolean =\n      (this.operator === \">=\" || this.operator === \"<=\") &&\n      (comp.operator === \">=\" || comp.operator === \"<=\");\n    const oppositeDirectionsLessThan: boolean =\n      cmp(this.semver, \"<\", comp.semver, options) &&\n      (this.operator === \">=\" || this.operator === \">\") &&\n      (comp.operator === \"<=\" || comp.operator === \"<\");\n    const oppositeDirectionsGreaterThan: boolean =\n      cmp(this.semver, \">\", comp.semver, options) &&\n      (this.operator === \"<=\" || this.operator === \"<\") &&\n      (comp.operator === \">=\" || comp.operator === \">\");\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    );\n  }\n\n  toString(): string {\n    return this.value;\n  }\n}\n\nexport class Range {\n  range!: string;\n  raw!: string;\n  options!: Options;\n  includePrerelease!: boolean;\n  set!: ReadonlyArray<ReadonlyArray<Comparator>>;\n\n  constructor(\n    range: string | Range | Comparator,\n    options?: Options,\n  ) {\n    if (typeof options !== \"object\") {\n      options = {\n        includePrerelease: false,\n      };\n    }\n\n    if (range instanceof Range) {\n      if (\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range;\n      } else {\n        return new Range(range.raw, options);\n      }\n    }\n\n    if (range instanceof Comparator) {\n      return new Range(range.value, options);\n    }\n\n    if (!(this instanceof Range)) {\n      return new Range(range, options);\n    }\n\n    this.options = options;\n    this.includePrerelease = !!options.includePrerelease;\n\n    // First, split based on boolean or ||\n    this.raw = range;\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      .map((range) => this.parseRange(range.trim()))\n      .filter((c) => {\n        // throw out any that are not relevant for whatever reason\n        return c.length;\n      });\n\n    if (!this.set.length) {\n      throw new TypeError(\"Invalid SemVer Range: \" + range);\n    }\n\n    this.format();\n  }\n\n  format(): string {\n    this.range = this.set\n      .map((comps) => comps.join(\" \").trim())\n      .join(\"||\")\n      .trim();\n    return this.range;\n  }\n\n  parseRange(range: string): ReadonlyArray<Comparator> {\n    range = range.trim();\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr: RegExp = re[HYPHENRANGE];\n    range = range.replace(hr, hyphenReplace);\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(\" \");\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const set: string[] = range\n      .split(\" \")\n      .map((comp) => parseComparator(comp, this.options))\n      .join(\" \")\n      .split(/\\s+/);\n\n    return set.map((comp) => new Comparator(comp, this.options));\n  }\n\n  test(version: string | SemVer): boolean {\n    if (typeof version === \"string\") {\n      version = new SemVer(version, this.options);\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  intersects(range?: Range, options?: Options): boolean {\n    if (!(range instanceof Range)) {\n      throw new TypeError(\"a Range is required\");\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(\n                  rangeComparator,\n                  options,\n                );\n              });\n            })\n          );\n        })\n      );\n    });\n  }\n\n  toString(): string {\n    return this.range;\n  }\n}\n\nfunction testSet(\n  set: ReadonlyArray<Comparator>,\n  version: SemVer,\n  options: Options,\n): boolean {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false;\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      if (set[i].semver === ANY) {\n        continue;\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed: SemVer = set[i].semver;\n        if (\n          allowed.major === version.major &&\n          allowed.minor === version.minor &&\n          allowed.patch === version.patch\n        ) {\n          return true;\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nfunction isSatisfiable(\n  comparators: readonly Comparator[],\n  options?: Options,\n): boolean {\n  let result = true;\n  const remainingComparators: Comparator[] = comparators.slice();\n  let testComparator = remainingComparators.pop();\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator?.intersects(otherComparator, options);\n    });\n\n    testComparator = remainingComparators.pop();\n  }\n\n  return result;\n}\n\n// Mostly just for testing and legacy API reasons\nexport function toComparators(\n  range: string | Range,\n  options?: Options,\n): string[][] {\n  return new Range(range, options).set.map((comp) => {\n    return comp\n      .map((c) => c.value)\n      .join(\" \")\n      .trim()\n      .split(\" \");\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp: string, options: Options): string {\n  comp = replaceCarets(comp, options);\n  comp = replaceTildes(comp, options);\n  comp = replaceXRanges(comp, options);\n  comp = replaceStars(comp, options);\n  return comp;\n}\n\nfunction isX(id: string): boolean {\n  return !id || id.toLowerCase() === \"x\" || id === \"*\";\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp: string, options: Options): string {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((comp) => replaceTilde(comp, options))\n    .join(\" \");\n}\n\nfunction replaceTilde(comp: string, _options: Options): string {\n  const r: RegExp = re[TILDE];\n  return comp.replace(\n    r,\n    (_: string, M: string, m: string, p: string, pr: string) => {\n      let ret: string;\n\n      if (isX(M)) {\n        ret = \"\";\n      } else if (isX(m)) {\n        ret = \">=\" + M + \".0.0 <\" + (+M + 1) + \".0.0\";\n      } else if (isX(p)) {\n        // ~1.2 == >=1.2.0 <1.3.0\n        ret = \">=\" + M + \".\" + m + \".0 <\" + M + \".\" + (+m + 1) + \".0\";\n      } else if (pr) {\n        ret = \">=\" +\n          M +\n          \".\" +\n          m +\n          \".\" +\n          p +\n          \"-\" +\n          pr +\n          \" <\" +\n          M +\n          \".\" +\n          (+m + 1) +\n          \".0\";\n      } else {\n        // ~1.2.3 == >=1.2.3 <1.3.0\n        ret = \">=\" + M + \".\" + m + \".\" + p + \" <\" + M + \".\" + (+m + 1) + \".0\";\n      }\n\n      return ret;\n    },\n  );\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp: string, options: Options): string {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((comp) => replaceCaret(comp, options))\n    .join(\" \");\n}\n\nfunction replaceCaret(comp: string, _options: Options): string {\n  const r: RegExp = re[CARET];\n  return comp.replace(r, (_: string, M, m, p, pr) => {\n    let ret: string;\n\n    if (isX(M)) {\n      ret = \"\";\n    } else if (isX(m)) {\n      ret = \">=\" + M + \".0.0 <\" + (+M + 1) + \".0.0\";\n    } else if (isX(p)) {\n      if (M === \"0\") {\n        ret = \">=\" + M + \".\" + m + \".0 <\" + M + \".\" + (+m + 1) + \".0\";\n      } else {\n        ret = \">=\" + M + \".\" + m + \".0 <\" + (+M + 1) + \".0.0\";\n      }\n    } else if (pr) {\n      if (M === \"0\") {\n        if (m === \"0\") {\n          ret = \">=\" +\n            M +\n            \".\" +\n            m +\n            \".\" +\n            p +\n            \"-\" +\n            pr +\n            \" <\" +\n            M +\n            \".\" +\n            m +\n            \".\" +\n            (+p + 1);\n        } else {\n          ret = \">=\" +\n            M +\n            \".\" +\n            m +\n            \".\" +\n            p +\n            \"-\" +\n            pr +\n            \" <\" +\n            M +\n            \".\" +\n            (+m + 1) +\n            \".0\";\n        }\n      } else {\n        ret = \">=\" + M + \".\" + m + \".\" + p + \"-\" + pr + \" <\" + (+M + 1) +\n          \".0.0\";\n      }\n    } else {\n      if (M === \"0\") {\n        if (m === \"0\") {\n          ret = \">=\" + M + \".\" + m + \".\" + p + \" <\" + M + \".\" + m + \".\" +\n            (+p + 1);\n        } else {\n          ret = \">=\" + M + \".\" + m + \".\" + p + \" <\" + M + \".\" + (+m + 1) + \".0\";\n        }\n      } else {\n        ret = \">=\" + M + \".\" + m + \".\" + p + \" <\" + (+M + 1) + \".0.0\";\n      }\n    }\n\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp: string, options: Options): string {\n  return comp\n    .split(/\\s+/)\n    .map((comp) => replaceXRange(comp, options))\n    .join(\" \");\n}\n\nfunction replaceXRange(comp: string, _options: Options): string {\n  comp = comp.trim();\n  const r: RegExp = re[XRANGE];\n  return comp.replace(r, (ret: string, gtlt, M, m, p, _pr) => {\n    const xM: boolean = isX(M);\n    const xm: boolean = xM || isX(m);\n    const xp: boolean = xm || isX(p);\n    const anyX: boolean = xp;\n\n    if (gtlt === \"=\" && anyX) {\n      gtlt = \"\";\n    }\n\n    if (xM) {\n      if (gtlt === \">\" || gtlt === \"<\") {\n        // nothing is allowed\n        ret = \"<0.0.0\";\n      } else {\n        // nothing is forbidden\n        ret = \"*\";\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0;\n      }\n      p = 0;\n\n      if (gtlt === \">\") {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = \">=\";\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === \"<=\") {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = \"<\";\n        if (xm) {\n          M = +M + 1;\n        } else {\n          m = +m + 1;\n        }\n      }\n\n      ret = gtlt + M + \".\" + m + \".\" + p;\n    } else if (xm) {\n      ret = \">=\" + M + \".0.0 <\" + (+M + 1) + \".0.0\";\n    } else if (xp) {\n      ret = \">=\" + M + \".\" + m + \".0 <\" + M + \".\" + (+m + 1) + \".0\";\n    }\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp: string, _options: Options): string {\n  return comp.trim().replace(re[STAR], \"\");\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace(\n  _$0: string,\n  from: string,\n  fM: string,\n  fm: string,\n  fp: string,\n  _fpr: string,\n  _fb: string,\n  to: string,\n  tM: string,\n  tm: string,\n  tp: string,\n  tpr: string,\n  _tb: string,\n) {\n  if (isX(fM)) {\n    from = \"\";\n  } else if (isX(fm)) {\n    from = \">=\" + fM + \".0.0\";\n  } else if (isX(fp)) {\n    from = \">=\" + fM + \".\" + fm + \".0\";\n  } else {\n    from = \">=\" + from;\n  }\n\n  if (isX(tM)) {\n    to = \"\";\n  } else if (isX(tm)) {\n    to = \"<\" + (+tM + 1) + \".0.0\";\n  } else if (isX(tp)) {\n    to = \"<\" + tM + \".\" + (+tm + 1) + \".0\";\n  } else if (tpr) {\n    to = \"<=\" + tM + \".\" + tm + \".\" + tp + \"-\" + tpr;\n  } else {\n    to = \"<=\" + to;\n  }\n\n  return (from + \" \" + to).trim();\n}\n\n/** Returns true if the version satisfies the range. */\nexport function satisfies(\n  version: string | SemVer,\n  range: string | Range,\n  options?: Options,\n): boolean {\n  try {\n    range = new Range(range, options);\n  } catch {\n    return false;\n  }\n  return range.test(version);\n}\n\n/**\n * Returns the highest version in the list that satisfies the range, or `null`\n * if none of them do.\n */\nexport function maxSatisfying<T extends string | SemVer>(\n  versions: ReadonlyArray<T>,\n  range: string | Range,\n  options?: Options,\n): T | null {\n  //todo\n  let max: T | SemVer | null = null;\n  let maxSV: SemVer | null = null;\n  let rangeObj: Range;\n  try {\n    rangeObj = new Range(range, options);\n  } catch {\n    return null;\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || (maxSV && maxSV.compare(v) === -1)) {\n        // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, options);\n      }\n    }\n  });\n  return max;\n}\n\n/**\n * Returns the lowest version in the list that satisfies the range, or `null` if\n * none of them do.\n */\nexport function minSatisfying<T extends string | SemVer>(\n  versions: ReadonlyArray<T>,\n  range: string | Range,\n  options?: Options,\n): T | null {\n  //todo\n  let min: string | SemVer | null = null;\n  let minSV: SemVer | null = null;\n  let rangeObj: Range;\n  try {\n    rangeObj = new Range(range, options);\n  } catch {\n    return null;\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV!.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, options);\n      }\n    }\n  });\n  return min;\n}\n\n/** Returns the lowest version that can possibly match the given range. */\nexport function minVersion(\n  range: string | Range,\n  options?: Options,\n): SemVer | null {\n  range = new Range(range, options);\n\n  let minver: SemVer | null = new SemVer(\"0.0.0\");\n  if (range.test(minver)) {\n    return minver;\n  }\n\n  minver = new SemVer(\"0.0.0-0\");\n  if (range.test(minver)) {\n    return minver;\n  }\n\n  minver = null;\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i];\n\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version);\n      switch (comparator.operator) {\n        case \">\":\n          if (compver.prerelease.length === 0) {\n            compver.patch++;\n          } else {\n            compver.prerelease.push(0);\n          }\n          compver.raw = compver.format();\n        /* fallthrough */\n        case \"\":\n        case \">=\":\n          if (!minver || gt(minver, compver)) {\n            minver = compver;\n          }\n          break;\n        case \"<\":\n        case \"<=\":\n          /* Ignore maximum versions */\n          break;\n        /* istanbul ignore next */\n        default:\n          throw new Error(\"Unexpected operation: \" + comparator.operator);\n      }\n    });\n  }\n\n  if (minver && range.test(minver)) {\n    return minver;\n  }\n\n  return null;\n}\n\n/** Returns the valid range or null if it's not valid. */\nexport function validRange(\n  range: string | Range | null,\n  options?: Options,\n): string | null {\n  try {\n    if (range === null) return null;\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || \"*\";\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Returns true if version is less than all the versions possible in the range.\n */\nexport function ltr(\n  version: string | SemVer,\n  range: string | Range,\n  options?: Options,\n): boolean {\n  return outside(version, range, \"<\", options);\n}\n\n/**\n * Returns true if version is greater than all the versions possible in the range.\n */\nexport function gtr(\n  version: string | SemVer,\n  range: string | Range,\n  options?: Options,\n): boolean {\n  return outside(version, range, \">\", options);\n}\n\n/**\n * Returns true if the version is outside the bounds of the range in either the\n * high or low direction. The hilo argument must be either the string '>' or\n * '<'. (This is the function called by {@linkcode gtr} and {@linkcode ltr}.)\n */\nexport function outside(\n  version: string | SemVer,\n  range: string | Range,\n  hilo: \">\" | \"<\",\n  options?: Options,\n): boolean {\n  version = new SemVer(version, options);\n  range = new Range(range, options);\n\n  let gtfn: typeof gt;\n  let ltefn: typeof lte;\n  let ltfn: typeof lt;\n  let comp: string;\n  let ecomp: string;\n  switch (hilo) {\n    case \">\":\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = \">\";\n      ecomp = \">=\";\n      break;\n    case \"<\":\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = \"<\";\n      ecomp = \"<=\";\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators: readonly Comparator[] = range.set[i];\n\n    let high: Comparator | null = null;\n    let low: Comparator | null = null;\n\n    for (let comparator of comparators) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator(\">=0.0.0\");\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator;\n      }\n    }\n\n    if (high === null || low === null) return true;\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high!.operator === comp || high!.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if (\n      (!low!.operator || low!.operator === comp) &&\n      ltefn(version, low!.semver)\n    ) {\n      return false;\n    } else if (low!.operator === ecomp && ltfn(version, low!.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns an array of prerelease components, or null if none exist.\n *\n * @example\n * `prerelease(\"1.2.3-alpha.1\") -> [\"alpha\", 1]`\n */\nexport function prerelease(\n  version: string | SemVer,\n  options?: Options,\n): ReadonlyArray<string | number> | null {\n  const parsed = parse(version, options);\n  return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n}\n\n/** Returns true if the two supplied ranges or comparators intersect. */\nexport function intersects(\n  range1: string | Range | Comparator,\n  range2: string | Range | Comparator,\n  options?: Options,\n): boolean {\n  range1 = new Range(range1, options);\n  range2 = new Range(range2, options);\n  return range1.intersects(range2);\n}\n\nexport default SemVer;\n", "const moduleTypes = {\n  denoLand: 'deno_land',\n  npmPackage: 'npm_package',\n  rawGitHub: 'raw_github',\n  unknown: 'unknown',\n} as const;\n\nexport interface Module {\n  type: ModuleType;\n  name: string;\n  version: string | null;\n}\n\nexport type ModuleType = typeof moduleTypes[keyof typeof moduleTypes];\n\nexport default moduleTypes;\n", "import * as semver from \"semver\";\nimport { SemVer } from \"semver\";\nimport moduleTypes from './moduleTypes.ts';\n\nconst resolveNpmPackage = async function (pkgName: string) {\n  const url = `https://registry.npmjs.org/${pkgName}`;\n  const res = await fetch(url);\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text());\n  const versions = Object.keys(data['versions'])\n    .map((v) => semver.parse(v))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst resolveDenoLandPackage = async function (pkgName: string) {\n  const url = `https://apiland.deno.dev/v2/modules/${pkgName}`;\n  const res = await fetch(url);\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text());\n  const versions = (data['versions'] as string[])\n    .map((v) => semver.parse(v))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst resolveRawGitHubContent = async function (\n  repoName: string,\n  token?: string,\n) {\n  const headers = {\n    'Accept': 'application/vnd.github+json',\n    'X-GitHub-Api-Version': '2022-11-28',\n  };\n  if (typeof token === 'string') {\n    Object.defineProperty(headers, 'Authorization', {\n      value: `Bearer ${token}`,\n    });\n  }\n\n  const res = await fetch(\n    `https://api.github.com/repos/${repoName}/releases`,\n    { headers },\n  );\n  if (!res.ok) {\n    return null;\n  }\n  const data = JSON.parse(await res.text()) as Required<{ tag_name: string }>[];\n  const versions = (data)\n    .map((v) => semver.parse(v.tag_name))\n    .filter((v) => v !== null) as SemVer[];\n\n  return versions;\n};\n\nconst pkgResolverMap = {\n  [moduleTypes.npmPackage]: resolveNpmPackage,\n  [moduleTypes.denoLand]: resolveDenoLandPackage,\n  [moduleTypes.rawGitHub]: resolveRawGitHubContent,\n};\n\nexport { resolveDenoLandPackage, resolveNpmPackage, resolveRawGitHubContent };\n\nexport default pkgResolverMap;\n", "import * as semver from \"semver\";\nimport { SemVer } from \"semver\";\nimport { Module } from './moduleTypes.ts';\nimport pkgResolverMap from './pkgResolver.ts';\n\ninterface ModuleVersionCheckOptions {\n  level: 'major' | 'minor' | 'patch';\n  usePrerelease: boolean;\n  gitHubToken?: string;\n}\n\ntype ModuleVersionCheckResult = {\n  fixed: boolean;\n  outdated: 'major' | 'minor' | 'patch' | 'pre_release' | 'none' | 'not_found';\n  latest: string | null;\n};\n\nconst versionsCache = new Map<string, SemVer[] | null>();\nconst getVersions = async function (\n  type: keyof typeof pkgResolverMap,\n  name: string,\n  ...args: string[]\n) {\n  const cacheName = type + ':' + name;\n  const cachedVersions = versionsCache.get(cacheName);\n  if (typeof cachedVersions !== 'undefined') {\n    return cachedVersions;\n  }\n\n  const versions = await pkgResolverMap[type](name, ...args);\n  versionsCache.set(cacheName, versions);\n\n  return versions;\n};\n\nconst getLargestVersion = (versions: SemVer[]) =>\n  versions.reduce((max, ver) => semver.gt(ver, max) ? ver : max);\n\nconst checkModuleVersion = async function (\n  module: Module,\n  options: ModuleVersionCheckOptions,\n): Promise<ModuleVersionCheckResult | null> {\n  const pkgVersion = module.version ?? '';\n  const versionFixed = semver.parse(pkgVersion) !== null;\n\n  if (!(module.type in pkgResolverMap)) {\n    return null;\n  }\n  const type = module.type as keyof typeof pkgResolverMap;\n\n  const additionalArgs = [];\n  if (type === 'raw_github' && typeof options?.gitHubToken === 'string') {\n    additionalArgs.push(options.gitHubToken);\n  }\n\n  let versionList = await getVersions(type, module.name, ...additionalArgs);\n  if (versionList === null) {\n    return {\n      fixed: versionFixed,\n      outdated: 'not_found',\n      latest: null,\n    };\n  }\n  if (!options.usePrerelease) {\n    versionList = versionList.filter((version) =>\n      version.prerelease.length === 0\n    );\n  }\n\n  // extract versions in the specified range;\n  // fixed versions are interpreted as a range of `=x.y.z`\n  const versionsInRange = versionList.filter((v) =>\n    semver.satisfies(\n      v,\n      pkgVersion,\n      { includePrerelease: options.usePrerelease },\n    )\n  );\n  if (versionsInRange.length < 1) {\n    return {\n      fixed: versionFixed,\n      outdated: 'not_found',\n      latest: null,\n    };\n  }\n  const latestVerInRange = getLargestVersion(versionsInRange);\n\n  const versionsGreater = versionList.filter((v) =>\n    semver.gtr(\n      v,\n      pkgVersion,\n      { includePrerelease: options.usePrerelease },\n    )\n  ).filter((v) => {\n    switch (options.level) {\n      case 'major':\n        return true;\n      case 'minor':\n        return semver.major(latestVerInRange) === v.major;\n      case 'patch':\n        return semver.major(latestVerInRange) === v.major &&\n          semver.minor(latestVerInRange) === v.minor;\n    }\n  });\n\n  let outdated: ModuleVersionCheckResult['outdated'] = 'none';\n  let latestVer: SemVer | null = null;\n  if (versionsGreater.length > 0) {\n    latestVer = getLargestVersion(versionsGreater);\n\n    if (latestVer.major > latestVerInRange.major) {\n      outdated = 'major';\n    } else if (latestVer.minor > latestVerInRange.minor) {\n      outdated = 'minor';\n    } else if (latestVer.patch > latestVerInRange.patch) {\n      outdated = 'patch';\n    } else if (\n      options.usePrerelease &&\n      semver.gt(latestVer, latestVerInRange, { includePrerelease: true })\n    ) {\n      outdated = 'pre_release';\n    }\n  }\n\n  // console.log(\n  //   name,\n  //   versionsInRange.map((v) => v.version),\n  //   versionsGreater.map((v) => v.version),\n  //   outdated,\n  // );\n\n  return {\n    fixed: versionFixed,\n    outdated,\n    latest: latestVer?.version ?? null,\n  };\n};\n\nexport type { ModuleVersionCheckOptions, ModuleVersionCheckResult }\n\nexport default checkModuleVersion;\n", "/**\n * @example \"package@version\" -> [\"package\", \"version\"]\n * @example \"package\" -> [\"package\", \"\"]\n * @example \"@author/package@version\" -> [\"@author/package\", \"version\"]\n * @example \"@author/package\" -> [\"@author/package\"]\n */\nconst decomposePackageNameVersion = function (\n  pkgStr: string,\n): [string, string] {\n  const index = pkgStr.lastIndexOf('@');\n  if (index <= 0) {\n    return [pkgStr, ''];\n  } else {\n    return [pkgStr.slice(0, index), pkgStr.slice(index + 1)];\n  }\n};\n\nconst matchStringOrRegExp = (test: string | RegExp, target: string) =>\n  (typeof test === 'string') ? test === target : test.test(target);\n\nexport { decomposePackageNameVersion, matchStringOrRegExp };\n", "import { decomposePackageNameVersion } from './util.ts';\nimport { default as moduleTypes, Module } from './moduleTypes.ts';\n\ninterface ModuleNameParser {\n  test: RegExp;\n  parse: (moduleName: string) => Module;\n}\n\nconst denoLandUrlParser: ModuleNameParser = {\n  test: /^https?:\\/\\/deno.land/,\n  parse: (moduleName) => {\n    const path = new URL(moduleName).pathname.split('/').slice(1);\n    const pkgStr = path[0] === 'x' ? path[1] : path[0];\n    const [name, version] = decomposePackageNameVersion(pkgStr);\n\n    return {\n      type: moduleTypes.denoLand,\n      name,\n      version,\n    };\n  },\n};\n\nconst rawGitHubUrlParser: ModuleNameParser = {\n  test: /^https?:\\/\\/raw.githubusercontent.com/,\n  parse: (moduleName) => {\n    const path = new URL(moduleName).pathname.split('/').slice(1);\n    const name = `${path[0]}/${path[1]}`;\n    const version = path[2];\n\n    return {\n      type: moduleTypes.rawGitHub,\n      name,\n      version,\n    };\n  },\n};\n\nconst denoNpmModuleParser: ModuleNameParser = {\n  test: /^npm:/,\n  parse: (moduleName) => {\n    const [name, version] = decomposePackageNameVersion(moduleName.slice(4));\n    return {\n      type: moduleTypes.npmPackage,\n      name,\n      version,\n    };\n  },\n};\n\nconst parseModuleName = function (\n  url: string,\n  parsers: ModuleNameParser[],\n): ReturnType<ModuleNameParser['parse']> | null {\n  for (const parser of parsers) {\n    if (parser.test.test(url)) {\n      return parser.parse(url);\n    }\n  }\n\n  return null;\n};\n\nexport type { ModuleNameParser };\n\nexport {\n  denoLandUrlParser,\n  denoNpmModuleParser,\n  parseModuleName,\n  rawGitHubUrlParser,\n};\n", "import { ModuleNameParser, parseModuleName } from './moduleNameParser.ts';\nimport { default as moduleTypes, Module } from './moduleTypes.ts';\n\ninterface Importmap {\n  imports?: { [key: string]: string };\n  scope?: {\n    [key: string]: { [key: string]: string };\n  };\n}\n\ntype PackageJson = Required<{\n  dependencies: { [key: string]: string };\n  devDependencies: { [key: string]: string };\n}>;\n\nconst resolvePackageJson = function (content: string): Module[] {\n  const packageJson = JSON.parse(content) as PackageJson;\n\n  // TODO: support imports other than npm\n  const results: Module[] = [];\n  for (const name in packageJson.dependencies) {\n    results.push({\n      type: moduleTypes.npmPackage,\n      name,\n      version: packageJson.dependencies[name],\n    });\n  }\n  for (const name in packageJson.devDependencies) {\n    results.push({\n      type: moduleTypes.npmPackage,\n      name,\n      version: packageJson.devDependencies[name],\n    });\n  }\n\n  return results;\n};\n\nconst parseModuleNameWrapper = function (\n  moduleName: string,\n  parsers: ModuleNameParser[],\n): Module {\n  return parseModuleName(moduleName, parsers) ?? {\n    type: moduleTypes.unknown,\n    name: moduleName,\n    version: null,\n  };\n};\n\nconst resolveImportMap = function (\n  content: string,\n  parsers: ModuleNameParser[],\n): Module[] {\n  const importmap = JSON.parse(content) as Importmap;\n\n  const moduleNames = [\n    ...Object.values(importmap?.imports ?? {}),\n    ...Object.values(importmap?.scope ?? {})\n      .flatMap((map) => Object.values(map)),\n  ];\n\n  return moduleNames.map((moduleName) =>\n    parseModuleNameWrapper(moduleName, parsers)\n  );\n};\n\nconst resolveDenoModuleNameStrings = function (\n  content: string,\n  parsers: ModuleNameParser[],\n): Module[] {\n  const regExps = [\n    /\"https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+\"/g,\n    /'https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+'/g,\n    /`https?:\\/\\/[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+`/g,\n    /\"npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+\"/g,\n    /'npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+'/g,\n    /`npm:[\\w/:%#\\$&\\?\\(\\)~\\.=\\+\\-@]+`/g,\n  ];\n\n  const moduleNames = regExps.flatMap((regExp) => [...content.matchAll(regExp)])\n    .map((match) => match[0].slice(1, -1));\n\n  return moduleNames.map((moduleName) =>\n    parseModuleNameWrapper(moduleName, parsers)\n  );\n};\n\nexport { resolveDenoModuleNameStrings, resolveImportMap, resolvePackageJson };\n", "import * as fs from \"fs\";\nimport * as posix from \"posix\";\nimport { Module } from \"./moduleTypes.ts\"\nimport * as moduleNameParser from './moduleNameParser.ts';\nimport * as fileResolver from './fileResolver.ts';\n\ninterface FileConfig {\n  file: string,\n  enabled?: (cwd: string) => boolean,\n  resolver: (content: string) => Module[],\n  // replacer\n}\n\nconst isDenoProjectCache = new Map<string, boolean>();\nconst isDenoProject = (cwd: string) => {\n  const cachedResult = isDenoProjectCache.get(cwd);\n  if(typeof cachedResult === 'boolean') {\n    return cachedResult;\n  }\n\n  if(fs.existsSync(posix.join(cwd, 'deno.json'), { isFile: true })) {\n    isDenoProjectCache.set(cwd, true);\n    return true;\n  }\n  if(fs.existsSync(posix.join(cwd, 'deno.jsonc'), { isFile: true })) {\n    isDenoProjectCache.set(cwd, true);\n    return true;\n  }\n\n  isDenoProjectCache.set(cwd, false);\n  return false;\n}\n\nconst npmPackageJson: FileConfig = {\n  file: 'package.json',\n  resolver: (content) => {\n    return fileResolver.resolvePackageJson(content);\n  }\n}\n\nconst denoImportMap: FileConfig = {\n  file: 'import_map.json',\n  enabled: isDenoProject,\n  resolver: (content) => {\n    return fileResolver.resolveImportMap(content, [\n      moduleNameParser.denoLandUrlParser,\n      moduleNameParser.rawGitHubUrlParser,\n      moduleNameParser.denoNpmModuleParser,\n    ]);\n  }\n}\n\nconst denoDepsTs: FileConfig = {\n  file: 'deps.ts',\n  enabled: isDenoProject,\n  resolver: (content) => {\n    return fileResolver.resolveDenoModuleNameStrings(content, [\n      moduleNameParser.denoLandUrlParser,\n      moduleNameParser.rawGitHubUrlParser,\n      moduleNameParser.denoNpmModuleParser,\n    ])\n  }\n}\n\nconst denoDepsJs: FileConfig = {\n  file: '**/deps.js',\n  enabled: isDenoProject,\n  resolver: (content) => {\n    return fileResolver.resolveDenoModuleNameStrings(content, [\n      moduleNameParser.denoLandUrlParser,\n      moduleNameParser.rawGitHubUrlParser,\n      moduleNameParser.denoNpmModuleParser,\n    ])\n  }\n}\n\nconst configurations = [\n  npmPackageJson,\n  denoImportMap,\n  denoDepsTs,\n  denoDepsJs,\n];\n\nexport { configurations };\n", "import * as fs from \"fs\";\nimport * as posix from \"posix\";\nimport * as cliffy from \"cliffy\";\nimport { Module } from './moduleTypes.ts';\nimport checkModuleVersion, { ModuleVersionCheckResult } from './moduleVersionChecker.ts';\nimport { configurations as fileConfigs } from './files.ts';\n\nconst enumerateFiles = async function* (basePath: string, files: string[]) {\n  for (const filename of files) {\n    for await (const file of fs.expandGlob(posix.resolve(basePath, filename))) {\n      if (file.isFile) {\n        yield [file.path, filename];\n      }\n    }\n  }\n};\n\nconst main = async function () {\n  const command = new cliffy.Command()\n    .name('deps-scanner-js')\n    .description('Dependency scanner for Node.js and Deno project')\n    .option('-l, --level [level:string]', 'version update limit', {\n      default: 'major'\n    })\n    .option('--prerelease', 'use prerelease')\n    .arguments('[path]');\n\n  const { options, args } = await command.parse(Deno.args);\n  let level_ = (typeof options.level === 'string') ? options.level.toLowerCase() : options.level;\n  if(level_ !== 'major' && level_ !== 'minor' && level_ !== 'patch') {\n    console.error(`${level_} is not a valid level.`);\n    Deno.exit(1);\n  }\n  const level = level_ as 'major' | 'minor' | 'patch';\n  const usePrerelease = options.prerelease === true;\n\n  const cwd = Deno.cwd();\n  const fileGlobs: string[] = [];\n  for(const config of fileConfigs) {\n    if(config.enabled === undefined || config.enabled(cwd)) {\n      fileGlobs.push(config.file);\n    }\n  }\n\n  // gather modules from files\n  const moduleMap = new Map<string, Module>();\n  for await (const [path, globName] of enumerateFiles(cwd, fileGlobs)) {\n    console.log(`Scanning ${path}...`);\n\n    const content = await Deno.readTextFile(path);\n\n    for(const config of fileConfigs) {\n      if(config.file === globName) {\n        config.resolver(content).forEach((module) => {\n          moduleMap.set(`${module.type}-${module.name}`, module);\n        });\n      }\n    }\n  }\n  const modules = [...moduleMap.values()];\n\n  // check updates\n  const results: [Module, ModuleVersionCheckResult][] = [];\n  for (const module of modules) {\n    const result = await checkModuleVersion(module, {\n      level,\n      usePrerelease,\n    });\n\n    if (result === null) {\n      console.log(`\u2754${module.name} cannot be resolved (${module.type})`);\n    } else if (result.outdated === 'not_found') {\n      console.log(`\u2754 ${module.name} not found on remote (${module.type})`);\n    } else if (result.outdated === 'none') {\n      if (result.fixed) {\n        console.log(`\u2705 ${module.name} is up to date`);\n      } else {\n        console.log(`\u26A0\uFE0F ${module.name} may up to date (version not fixed)`);\n      }\n    } else {\n      if (result.fixed) {\n        console.log(`\u274C ${module.name} is outdated (${result.outdated})`);\n      } else {\n        console.log(\n          `\u274C ${module.name} is outdated (${result.outdated}) and version is not fixed`,\n        );\n      }\n    }\n\n    if (result !== null) {\n      results.push([\n        module,\n        result,\n      ]);\n    }\n  }\n\n  // show result\n  const outdatedModules = results.filter(([, result]) => {\n    return result.outdated !== 'none' && result.outdated !== 'not_found';\n  });\n  const notFoundModules = results.filter(([_, result]) =>\n    result.outdated === 'not_found'\n  );\n  const notFixedModules = results.filter(([_, result]) => !result.fixed);\n\n  console.log();\n  console.log(\n    `\\x1b[1m${outdatedModules.length}\\x1b[0m module${\n      outdatedModules.length > 1 ? 's are' : ' is'\n    } outdated.`,\n  );\n  if (notFoundModules.length > 0) {\n    console.log('Could not find following modules:');\n    console.log(\n      '  ' + notFoundModules.map(([module]) => module.name).join(', '),\n    );\n  }\n  if (notFixedModules.length > 0) {\n    console.log('Version not fixed at following modules:');\n    console.log(\n      '  ' + notFixedModules.map(([module]) => module.name).join(', '),\n    );\n  }\n\n  if(outdatedModules.length > 0) {\n    let logTable: string[][] = [\n      ['', 'package', 'current', 'latest'],\n    ];\n    const outdatedTextMap = {\n      'major': '\\x1b[31mMajor\\x1b[0m',\n      'minor': '\\x1b[33mMinor\\x1b[0m',\n      'patch': '\\x1b[34mPatch\\x1b[0m',\n      'pre_release': '\\x1b[36mPre\\x1b[0m',\n      'none': 'Latest',\n      'not_found': 'Not Found',\n    };\n    for (const [module, result] of outdatedModules) {\n      logTable.push([\n        `${outdatedTextMap[result.outdated]}`,\n        module.name,\n        module.version ?? '(null)',\n        result.latest ?? '(null)',\n      ]);\n    }\n    const colWidths = new Array(logTable[0].length)\n      .fill(0)\n      .map((_, i) =>\n        logTable.reduce(\n          (max, arr) => arr[i].length > max ? arr[i].length : max,\n          0,\n        )\n      );\n\n    logTable = logTable.map((arr) =>\n      arr.map((v, i) => `${v}${' '.repeat(colWidths[i])}`.slice(0, colWidths[i]))\n    );\n    // adjust for ANSI escape sequence\n    colWidths[0] = 5;\n    logTable[0][0] = '     ';\n\n    console.log(logTable[0].join(' '));\n    console.log(colWidths.map((len) => '-'.repeat(len)).join(' '));\n    console.log(logTable.slice(1).map((arr) => arr.join(' ')).join('\\n'));\n  }\n};\n\nmain();\n"],
  "mappings": "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",
  "names": ["osType", "Deno", "navigator", "isWindows", "win32_exports", "__export", "basename", "delimiter", "dirname", "extname", "format", "fromFileUrl", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "toFileUrl", "toNamespacedPath", "assertPath", "path", "isPosixPathSeparator", "code", "isPathSeparator", "isWindowsDeviceRoot", "normalizeString", "allowAboveRoot", "separator", "res", "lastSegmentLength", "lastSlash", "dots", "i", "len", "lastSlashIndex", "_format", "sep", "pathObject", "dir", "base", "WHITESPACE_ENCODINGS", "encodeWhitespace", "string", "c", "lastPathSegment", "isSep", "start", "matchedNonSeparator", "end", "stripTrailingSeparators", "segment", "stripSuffix", "name", "suffix", "lenDiff", "DenoStdInternalError", "message", "assert", "expr", "msg", "sep", "delimiter", "resolve", "pathSegments", "resolvedDevice", "resolvedTail", "resolvedAbsolute", "path", "Deno", "assertPath", "len", "rootEnd", "device", "isAbsolute", "code", "isPathSeparator", "j", "last", "firstPart", "isWindowsDeviceRoot", "normalizeString", "normalize", "tail", "join", "paths", "pathsCount", "joined", "i", "needsReplace", "slashCount", "assert", "firstLen", "relative", "from", "to", "fromOrig", "toOrig", "fromStart", "fromEnd", "fromLen", "toStart", "toEnd", "toLen", "length", "lastCommonSep", "fromCode", "toCode", "out", "toNamespacedPath", "resolvedPath", "dirname", "end", "matchedSlash", "offset", "stripTrailingSeparators", "isPosixPathSeparator", "basename", "suffix", "start", "drive", "lastSegment", "lastPathSegment", "strippedSegment", "stripSuffix", "extname", "startDot", "startPart", "preDotState", "format", "pathObject", "_format", "parse", "ret", "fromFileUrl", "url", "toFileUrl", "hostname", "pathname", "encodeWhitespace", "posix_exports", "__export", "basename", "delimiter", "dirname", "extname", "format", "fromFileUrl", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "toFileUrl", "toNamespacedPath", "sep", "delimiter", "resolve", "pathSegments", "resolvedPath", "resolvedAbsolute", "i", "path", "Deno", "assertPath", "isPosixPathSeparator", "normalizeString", "normalize", "isAbsolute", "trailingSeparator", "join", "paths", "joined", "len", "relative", "from", "to", "fromStart", "fromEnd", "fromLen", "toStart", "toEnd", "toLen", "length", "lastCommonSep", "fromCode", "toCode", "out", "toNamespacedPath", "dirname", "end", "matchedNonSeparator", "stripTrailingSeparators", "basename", "suffix", "lastSegment", "lastPathSegment", "strippedSegment", "stripSuffix", "extname", "startDot", "startPart", "matchedSlash", "preDotState", "code", "format", "pathObject", "_format", "parse", "ret", "start", "fromFileUrl", "url", "toFileUrl", "encodeWhitespace", "SEP", "isWindows", "SEP_PATTERN", "path", "isWindows", "win32_exports", "posix_exports", "join", "normalize", "regExpEscapeChars", "rangeEscapeChars", "globToRegExp", "glob", "extended", "globstarOption", "os", "osType", "caseInsensitive", "sep", "sepMaybe", "seps", "globstar", "wildcard", "escapePrefix", "newLength", "regExpString", "j", "segment", "groupStack", "inRange", "inEscape", "endsWithSep", "i", "k", "value", "type", "prevChar", "numStars", "nextChar", "c", "isGlob", "str", "chars", "regex", "match", "idx", "open", "close", "n", "normalizeGlob", "s", "SEP_PATTERN", "badParentPattern", "joinGlobs", "globs", "joined", "SEP", "path", "isWindows", "win32_exports", "posix_exports", "basename", "delimiter", "dirname", "extname", "format", "fromFileUrl", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "toFileUrl", "toNamespacedPath", "path", "createWalkEntry", "path", "toPathString", "normalize", "name", "basename", "info", "pathUrl", "fromFileUrl", "existsSync", "path", "options", "stat", "error", "WalkError", "cause", "path", "include", "exts", "match", "skip", "ext", "pattern", "wrapErrorWithPath", "err", "root", "walk", "maxDepth", "includeFiles", "includeDirs", "followSymlinks", "toPathString", "createWalkEntry", "entry", "assert", "join", "isSymlink", "isDirectory", "normalize", "split", "path", "s", "SEP_PATTERN", "segments", "isAbsolute_", "isAbsolute", "isWindows", "throwUnlessNotFound", "error", "comparePath", "a", "b", "expandGlob", "glob", "root", "exclude", "includeDirs", "extended", "globstar", "caseInsensitive", "followSymlinks", "globOptions", "absRoot", "resolve", "resolveFromRoot", "excludePatterns", "globToRegExp", "shouldInclude", "p", "isGlobAbsolute", "hasTrailingSep", "winRoot", "toPathString", "fixedRoot", "isGlob", "seg", "assert", "joinGlobs", "fixedRootInfo", "createWalkEntry", "advanceMatch", "walkInfo", "globSegment", "parentPath", "walk", "globPattern", "walkEntry", "currentMatches", "segment", "nextMatchMap", "currentMatch", "nextMatch", "entry", "EXISTS_ERROR", "ansi_escapes_exports", "__export", "bel", "clearScreen", "clearTerminal", "cursorBackward", "cursorDown", "cursorForward", "cursorHide", "cursorLeft", "cursorMove", "cursorNextLine", "cursorPosition", "cursorPrevLine", "cursorRestore", "cursorSave", "cursorShow", "cursorTo", "cursorUp", "eraseDown", "eraseLine", "eraseLineEnd", "eraseLineStart", "eraseLines", "eraseScreen", "eraseUp", "image", "link", "scrollDown", "scrollUp", "base64abc", "encode", "data", "uint8", "result", "i", "l", "ESC", "CSI", "OSC", "SEP", "bel", "cursorPosition", "cursorTo", "x", "y", "cursorMove", "ret", "cursorUp", "count", "cursorDown", "cursorForward", "cursorBackward", "cursorNextLine", "cursorPrevLine", "cursorLeft", "cursorHide", "cursorShow", "cursorSave", "cursorRestore", "scrollUp", "scrollDown", "eraseScreen", "eraseUp", "eraseDown", "eraseLine", "eraseLineEnd", "eraseLineStart", "eraseLines", "clear", "i", "clearScreen", "clearTerminal", "link", "text", "url", "image", "buffer", "options", "encode", "ansi", "factory", "result", "stack", "args", "update", "text", "str", "methodList", "ansi_escapes_exports", "name", "method", "prop", "colors_exports", "__export", "bgBlack", "bgBlue", "bgBrightBlack", "bgBrightBlue", "bgBrightCyan", "bgBrightGreen", "bgBrightMagenta", "bgBrightRed", "bgBrightWhite", "bgBrightYellow", "bgCyan", "bgGreen", "bgMagenta", "bgRed", "bgRgb24", "bgRgb8", "bgWhite", "bgYellow", "black", "blue", "bold", "brightBlack", "brightBlue", "brightCyan", "brightGreen", "brightMagenta", "brightRed", "brightWhite", "brightYellow", "cyan", "dim", "getColorEnabled", "gray", "green", "hidden", "inverse", "italic", "magenta", "red", "reset", "rgb24", "rgb8", "setColorEnabled", "strikethrough", "stripColor", "underline", "white", "yellow", "Deno", "noColor", "enabled", "value", "code", "open", "close", "run", "str", "clampAndTruncate", "n", "max", "min", "color", "ANSI_PATTERN", "string", "proto", "methodNames", "colors_exports", "name", "factory", "colors", "stack", "str", "args", "lastIndex", "index", "tmp", "getCursorPosition", "stdin", "stdout", "data", "cursorPosition", "y", "x", "tty", "factory", "options", "result", "stack", "stdout", "stdin", "args", "update", "text", "getCursorPosition", "methodList", "ansi_escapes_exports", "name", "method", "prev", "cur", "distance", "a", "b", "matrix", "i", "j", "paramCaseToCamelCase", "str", "g", "underscoreToCamelCase", "getOption", "flags", "name", "flag", "isOption", "didYouMeanOption", "option", "options", "optionNames", "getFlag", "didYouMean", "didYouMeanType", "type", "types", "message", "match", "closest", "matchWildCardOptions", "matched", "matchWildCardOption", "parts", "parts2", "count", "i", "arr", "minDistance", "minIndex", "dist", "distance", "getDefaultValue", "FlagsError", "message", "UnknownRequiredOptionError", "option", "options", "getFlag", "didYouMeanOption", "UnknownConflictingOptionError", "UnknownTypeError", "type", "types", "didYouMeanType", "ValidationError", "DuplicateOptionError", "name", "InvalidOptionError", "UnknownOptionError", "MissingOptionValueError", "InvalidOptionValueError", "expected", "value", "UnexpectedOptionValueError", "OptionNotCombinableError", "ConflictingOptionError", "conflictingOption", "DependingOptionError", "dependingOption", "MissingRequiredOptionError", "UnexpectedRequiredArgumentError", "arg", "UnexpectedArgumentAfterVariadicArgumentError", "InvalidTypeError", "label", "didYouMeanCommand", "command", "commands", "excludes", "commandNames", "didYouMean", "ARGUMENT_REGEX", "ARGUMENT_DETAILS_REGEX", "splitArguments", "args", "parts", "typeParts", "typeDefinition", "parseArgumentsDefinition", "argsDefinition", "validate", "all", "argumentDetails", "hasOptional", "hasVariadic", "arg", "UnexpectedArgumentAfterVariadicArgumentError", "type", "details", "UnexpectedRequiredArgumentError", "istVariadicLeft", "istVariadicRight", "dedent", "str", "lines", "text", "indent", "line", "getDescription", "description", "short", "CommandError", "message", "ValidationError", "exitCode", "DuplicateOptionNameError", "name", "getFlag", "MissingCommandNameError", "DuplicateCommandNameError", "DuplicateCommandAliasError", "alias", "CommandNotFoundError", "commands", "excluded", "didYouMeanCommand", "DuplicateTypeError", "DuplicateCompletionError", "DuplicateExampleError", "DuplicateEnvVarError", "MissingRequiredEnvVarError", "envVar", "TooManyEnvVarValuesError", "UnexpectedOptionalEnvVarValueError", "UnexpectedVariadicEnvVarValueError", "DefaultCommandNotFoundError", "CommandExecutableNotFoundError", "UnknownCommandError", "ValidationError", "name", "commands", "excluded", "didYouMeanCommand", "NoArgumentsAllowedError", "MissingArgumentsError", "names", "MissingArgumentError", "TooManyArgumentsError", "args", "boolean", "type", "InvalidTypeError", "number", "type", "value", "InvalidTypeError", "string", "value", "validateFlags", "ctx", "opts", "options", "defaultValues", "setDefaultValues", "optionNames", "validateStandaloneOption", "name", "option", "validateUnknownOption", "validateConflictingOptions", "validateDependingOptions", "validateRequiredValues", "validateRequiredOptions", "getOption", "UnknownOptionError", "defaultValue", "propName", "paramCaseToCamelCase", "getDefaultValue", "_", "opt", "OptionNotCombinableError", "flag", "isset", "ConflictingOptionError", "DependingOptionError", "isArray", "MissingOptionValueError", "optionsValues", "MissingRequiredOptionError", "flagName", "flags", "integer", "type", "value", "InvalidTypeError", "DefaultTypes", "string", "number", "integer", "boolean", "parseFlags", "argsOrCtx", "opts", "args", "ctx", "validateOptions", "options", "parseArgs", "validateFlags", "parseDottedOptions", "opt", "flag", "getOption", "UnknownRequiredOptionError", "UnknownConflictingOptionError", "optionsMap", "inLiteral", "argsIndex", "parseNext", "option", "negate", "propName", "arg", "optionArgsIndex", "next", "UnknownOptionError", "inOptionalArg", "UnexpectedRequiredArgumentError", "result", "increase", "hasNext", "parsed", "nextValue", "value", "parseValue", "InvalidOptionValueError", "currentValue", "UnexpectedArgumentAfterVariadicArgumentError", "parseDefaultType", "current", "isShort", "isLong", "InvalidOptionError", "splitFlags", "equalSignIndex", "name", "matchWildCardOptions", "positiveName", "paramCaseToCamelCase", "DuplicateOptionError", "UnexpectedOptionValueError", "previous", "MissingOptionValueError", "getDefaultValue", "key", "subKey", "index", "parts", "normalized", "flags", "val", "type", "parseType", "UnknownTypeError", "Type", "BooleanType", "Type", "type", "boolean", "StringType", "Type", "type", "string", "FileType", "StringType", "NumberType", "Type", "type", "number", "border", "Cell", "value", "cell", "enable", "override", "span", "direction", "Row", "cells", "row", "cell", "Cell", "enable", "override", "direction", "consumeWords", "length", "content", "consumed", "words", "word", "nextLength", "strLength", "longest", "index", "rows", "maxWidth", "cellLengths", "row", "cell", "Cell", "line", "str", "stripColor", "i", "charCode", "TableLayout", "table", "options", "opts", "key", "hasBodyBorder", "hasHeaderBorder", "hasBorder", "rows", "#getRows", "columns", "row", "length", "diff", "i", "padding", "width", "colIndex", "minColWidth", "maxColWidth", "colWidth", "longest", "header", "cell", "Cell", "newRow", "rowSpan", "colSpan", "rowIndex", "span", "Row", "result", "isMultiline", "prevRow", "nextRow", "isMultilineRow", "noBorder", "prevCell", "maxLength", "o", "current", "next", "strLength", "words", "consumeWords", "breakWord", "fillLength", "align", "a1", "a2", "b1", "b2", "a1Border", "a2Border", "b1Border", "b2Border", "hasColSpan", "hasRowSpan", "a1ColSpan", "a2ColSpan", "b1ColSpan", "b2ColSpan", "a1RowSpan", "a2RowSpan", "b1RowSpan", "b2RowSpan", "hasAllBorder", "_Table", "rows", "table", "Row", "chars", "row", "header", "TableLayout", "width", "override", "padding", "enable", "direction", "hasBorder", "cell", "Cell", "Table", "border", "HelpGenerator", "cmd", "options", "areColorsEnabled", "getColorEnabled", "setColorEnabled", "result", "usage", "rows", "bold", "brightMagenta", "highlightArguments", "yellow", "Table", "meta", "name", "value", "dedent", "groups", "option", "group", "flag", "brightBlue", "red", "getDescription", "commands", "command", "envVars", "envVar", "highlightArgumentDetails", "examples", "example", "dim", "capitalize", "hints", "inspect", "italic", "getFlag", "type", "Type", "possibleValues", "label", "string", "colors", "argsDefinition", "types", "parseArgumentsDefinition", "arg", "str", "green", "IntegerType", "Type", "type", "integer", "Command", "flags", "desc", "opts", "nameAndArguments", "cmdOrDescription", "override", "result", "splitArguments", "name", "aliases", "MissingCommandNameError", "DuplicateCommandNameError", "description", "cmd", "alias", "DuplicateCommandAliasError", "CommandNotFoundError", "version", "value", "help", "options", "HelpGenerator", "usage", "args", "fn", "allowEmpty", "stopEarly", "useRawArgs", "handler", "DuplicateTypeError", "Type", "completeHandler", "parent", "complete", "DuplicateCompletionError", "parseArgumentsDefinition", "option", "arg", "part", "isLong", "DuplicateOptionNameError", "DuplicateExampleError", "envName", "DuplicateEnvVarError", "details", "TooManyEnvVarValuesError", "UnexpectedOptionalEnvVarValueError", "UnexpectedVariadicEnvVarValueError", "ctx", "preParseGlobals", "subCommand", "optionName", "error", "isHelpOption", "envVars", "envVar", "helpOption", "isVersionOption", "StringType", "NumberType", "IntegerType", "BooleanType", "FileType", "long", "DefaultCommandNotFoundError", "command", "status", "CommandExecutableNotFoundError", "stopOnUnknown", "dotted", "parseFlags", "type", "typeSettings", "UnknownTypeError", "validate", "env", "parseType", "propertyName", "underscoreToCamelCase", "MissingRequiredEnvVarError", "names", "params", "expectedArg", "MissingArgumentError", "parseArgValue", "parseArgType", "TooManyArgumentsError", "required", "MissingArgumentsError", "UnknownCommandError", "NoArgumentsAllowedError", "ValidationError", "red", "bold", "getDescription", "brightBlue", "k", "v", "code", "mainCommand", "upgradeCommand", "isUpgradeCommand", "latestVersion", "currentVersion", "versionHelpText", "yellow", "hidden", "opt", "getGlobals", "noGlobals", "getGlobalOption", "index", "commands", "getCommands", "_", "getGlobalCommand", "getTypes", "types", "getCompletions", "completions", "completion", "getEnvVars", "example", "KeyMap", "KeyMapShift", "KeyMapCtrl", "SpecialKeyMap", "kUTF16SurrogateThreshold", "kEscape", "parse", "data", "index", "keys", "input", "hasNext", "next", "parseNext", "ch", "s", "escaped", "key", "code", "modifier", "cmdStart", "cmd", "match", "KeyMap", "KeyMapShift", "KeyMapCtrl", "SpecialKeyMap", "charLengthAt", "str", "i", "pos", "main", "win", "Figures", "osType", "Deno", "navigator", "isWindows", "win32_exports", "__export", "basename", "delimiter", "dirname", "extname", "format", "fromFileUrl", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "toFileUrl", "toNamespacedPath", "assertPath", "path", "isPosixPathSeparator", "code", "isPathSeparator", "isWindowsDeviceRoot", "normalizeString", "allowAboveRoot", "separator", "res", "lastSegmentLength", "lastSlash", "dots", "i", "len", "lastSlashIndex", "_format", "sep", "pathObject", "dir", "base", "WHITESPACE_ENCODINGS", "encodeWhitespace", "string", "c", "DenoStdInternalError", "message", "assert", "expr", "msg", "sep", "delimiter", "resolve", "pathSegments", "resolvedDevice", "resolvedTail", "resolvedAbsolute", "path", "Deno", "assertPath", "len", "rootEnd", "device", "isAbsolute", "code", "isPathSeparator", "j", "last", "firstPart", "isWindowsDeviceRoot", "normalizeString", "normalize", "tail", "join", "paths", "pathsCount", "joined", "i", "needsReplace", "slashCount", "assert", "firstLen", "relative", "from", "to", "fromOrig", "toOrig", "fromStart", "fromEnd", "fromLen", "toStart", "toEnd", "toLen", "length", "lastCommonSep", "fromCode", "toCode", "out", "toNamespacedPath", "resolvedPath", "dirname", "end", "matchedSlash", "offset", "basename", "ext", "start", "drive", "extIdx", "firstNonSlashEnd", "extname", "startDot", "startPart", "preDotState", "format", "pathObject", "_format", "parse", "ret", "fromFileUrl", "url", "toFileUrl", "hostname", "pathname", "encodeWhitespace", "posix_exports", "__export", "basename", "delimiter", "dirname", "extname", "format", "fromFileUrl", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "toFileUrl", "toNamespacedPath", "sep", "delimiter", "resolve", "pathSegments", "resolvedPath", "resolvedAbsolute", "i", "path", "Deno", "assertPath", "normalizeString", "isPosixPathSeparator", "normalize", "isAbsolute", "trailingSeparator", "join", "paths", "joined", "len", "relative", "from", "to", "fromStart", "fromEnd", "fromLen", "toStart", "toEnd", "toLen", "length", "lastCommonSep", "fromCode", "toCode", "out", "toNamespacedPath", "dirname", "hasRoot", "end", "matchedSlash", "basename", "ext", "start", "extIdx", "firstNonSlashEnd", "code", "extname", "startDot", "startPart", "preDotState", "format", "pathObject", "_format", "parse", "ret", "fromFileUrl", "url", "toFileUrl", "encodeWhitespace", "path", "isWindows", "win32_exports", "posix_exports", "join", "normalize", "path", "isWindows", "win32_exports", "posix_exports", "basename", "delimiter", "dirname", "extname", "format", "fromFileUrl", "isAbsolute", "join", "normalize", "parse", "relative", "resolve", "sep", "toFileUrl", "toNamespacedPath", "path", "_value", "_lastError", "_isFirstRun", "_encoder", "_execute", "_readKey", "_readChar", "_transformValue", "_validateValue", "_GenericPrompt", "settings", "tty", "__privateAdd", "__privateGet", "__privateSet", "successMessage", "data", "parse", "buffer", "isTty", "nread", "value", "validation", "content", "lines", "columns", "getColumns", "y", "prev", "next", "length", "stripColor", "events", "event", "bold", "defaultMessage", "dim", "green", "red", "Figures", "italic", "brightBlue", "message", "keys", "name", "keyNames", "GenericPrompt", "sep", "re", "src", "R", "NUMERICIDENTIFIER", "NONNUMERICIDENTIFIER", "MAINVERSION", "nid", "PRERELEASEIDENTIFIER", "PRERELEASE", "BUILDIDENTIFIER", "BUILD", "FULL", "FULLPLAIN", "GTLT", "XRANGEIDENTIFIER", "XRANGEPLAIN", "XRANGE", "LONETILDE", "TILDE", "LONECARET", "CARET", "COMPARATOR", "HYPHENRANGE", "STAR", "i", "parse", "version", "options", "SemVer", "SemVer", "version", "options", "m", "re", "FULL", "id", "num", "opts", "style", "release", "v", "other", "compareIdentifiers", "i", "a", "b", "identifier", "metadata", "numeric", "compareIdentifiers", "a", "b", "anum", "bnum", "major", "v", "options", "SemVer", "minor", "compare", "v1", "v2", "options", "SemVer", "gt", "v1", "v2", "options", "compare", "lt", "eq", "neq", "gte", "lte", "cmp", "operator", "ANY", "Comparator", "comp", "r", "re", "COMPARATOR", "m", "m1", "SemVer", "version", "rangeTmp", "Range", "satisfies", "sameDirectionIncreasing", "sameDirectionDecreasing", "sameSemVer", "differentDirectionsInclusive", "oppositeDirectionsLessThan", "oppositeDirectionsGreaterThan", "range", "c", "comps", "hr", "HYPHENRANGE", "hyphenReplace", "parseComparator", "i", "testSet", "thisComparators", "isSatisfiable", "rangeComparators", "thisComparator", "rangeComparator", "set", "allowed", "comparators", "result", "remainingComparators", "testComparator", "otherComparator", "parseComparator", "comp", "options", "replaceCarets", "replaceTildes", "replaceXRanges", "replaceStars", "isX", "id", "replaceTilde", "_options", "r", "re", "TILDE", "_", "M", "m", "p", "pr", "ret", "replaceCaret", "CARET", "replaceXRange", "XRANGE", "gtlt", "_pr", "xM", "xm", "xp", "anyX", "STAR", "hyphenReplace", "_$0", "from", "fM", "fm", "fp", "_fpr", "_fb", "to", "tM", "tm", "tp", "tpr", "_tb", "satisfies", "version", "range", "Range", "gtr", "version", "range", "options", "outside", "hilo", "SemVer", "Range", "gtfn", "ltefn", "ltfn", "comp", "ecomp", "gt", "lte", "lt", "gte", "satisfies", "i", "comparators", "high", "low", "comparator", "ANY", "Comparator", "moduleTypes", "moduleTypes_default", "resolveNpmPackage", "pkgName", "url", "res", "data", "v", "parse", "resolveDenoLandPackage", "resolveRawGitHubContent", "repoName", "token", "headers", "pkgResolverMap", "moduleTypes_default", "pkgResolver_default", "pkgResolverMap", "versionsCache", "getVersions", "type", "name", "args", "cacheName", "cachedVersions", "versions", "pkgResolver_default", "getLargestVersion", "max", "ver", "gt", "checkModuleVersion", "module", "options", "pkgVersion", "versionFixed", "parse", "additionalArgs", "versionList", "version", "versionsInRange", "v", "satisfies", "latestVerInRange", "versionsGreater", "gtr", "major", "minor", "outdated", "latestVer", "moduleVersionChecker_default", "decomposePackageNameVersion", "pkgStr", "index", "denoLandUrlParser", "moduleName", "path", "pkgStr", "name", "version", "decomposePackageNameVersion", "moduleTypes_default", "rawGitHubUrlParser", "denoNpmModuleParser", "parseModuleName", "url", "parsers", "parser", "resolvePackageJson", "content", "packageJson", "results", "name", "moduleTypes_default", "parseModuleNameWrapper", "moduleName", "parsers", "parseModuleName", "resolveImportMap", "importmap", "map", "resolveDenoModuleNameStrings", "regExp", "match", "isDenoProjectCache", "isDenoProject", "cwd", "cachedResult", "existsSync", "join", "npmPackageJson", "content", "resolvePackageJson", "denoImportMap", "resolveImportMap", "denoLandUrlParser", "rawGitHubUrlParser", "denoNpmModuleParser", "denoDepsTs", "resolveDenoModuleNameStrings", "denoDepsJs", "configurations", "enumerateFiles", "basePath", "files", "filename", "file", "expandGlob", "resolve", "main", "command", "Command", "options", "args", "level_", "level", "usePrerelease", "cwd", "fileGlobs", "config", "configurations", "moduleMap", "path", "globName", "content", "module", "modules", "results", "result", "moduleVersionChecker_default", "outdatedModules", "notFoundModules", "_", "notFixedModules", "logTable", "outdatedTextMap", "colWidths", "i", "max", "arr", "v", "len"]
}
